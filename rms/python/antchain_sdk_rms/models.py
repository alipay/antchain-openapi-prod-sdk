# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List


class Config(TeaModel):
    """
    Model for initing client
    """
    def __init__(
        self,
        access_key_id: str = None,
        access_key_secret: str = None,
        security_token: str = None,
        protocol: str = None,
        read_timeout: int = None,
        connect_timeout: int = None,
        http_proxy: str = None,
        https_proxy: str = None,
        endpoint: str = None,
        no_proxy: str = None,
        max_idle_conns: int = None,
        user_agent: str = None,
        socks_5proxy: str = None,
        socks_5net_work: str = None,
        max_idle_time_millis: int = None,
        keep_alive_duration_millis: int = None,
        max_requests: int = None,
        max_requests_per_host: int = None,
    ):
        # accesskey id
        self.access_key_id = access_key_id
        # accesskey secret
        self.access_key_secret = access_key_secret
        # security token
        self.security_token = security_token
        # http protocol
        self.protocol = protocol
        # read timeout
        self.read_timeout = read_timeout
        # connect timeout
        self.connect_timeout = connect_timeout
        # http proxy
        self.http_proxy = http_proxy
        # https proxy
        self.https_proxy = https_proxy
        # endpoint
        self.endpoint = endpoint
        # proxy white list
        self.no_proxy = no_proxy
        # max idle conns
        self.max_idle_conns = max_idle_conns
        # user agent
        self.user_agent = user_agent
        # socks5 proxy
        self.socks_5proxy = socks_5proxy
        # socks5 network
        self.socks_5net_work = socks_5net_work
        # 长链接最大空闲时长
        self.max_idle_time_millis = max_idle_time_millis
        # 长链接最大连接时长
        self.keep_alive_duration_millis = keep_alive_duration_millis
        # 最大连接数（长链接最大总数）
        self.max_requests = max_requests
        # 每个目标主机的最大连接数（分主机域名的长链接最大总数
        self.max_requests_per_host = max_requests_per_host

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.access_key_id is not None:
            result['accessKeyId'] = self.access_key_id
        if self.access_key_secret is not None:
            result['accessKeySecret'] = self.access_key_secret
        if self.security_token is not None:
            result['securityToken'] = self.security_token
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.read_timeout is not None:
            result['readTimeout'] = self.read_timeout
        if self.connect_timeout is not None:
            result['connectTimeout'] = self.connect_timeout
        if self.http_proxy is not None:
            result['httpProxy'] = self.http_proxy
        if self.https_proxy is not None:
            result['httpsProxy'] = self.https_proxy
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.no_proxy is not None:
            result['noProxy'] = self.no_proxy
        if self.max_idle_conns is not None:
            result['maxIdleConns'] = self.max_idle_conns
        if self.user_agent is not None:
            result['userAgent'] = self.user_agent
        if self.socks_5proxy is not None:
            result['socks5Proxy'] = self.socks_5proxy
        if self.socks_5net_work is not None:
            result['socks5NetWork'] = self.socks_5net_work
        if self.max_idle_time_millis is not None:
            result['maxIdleTimeMillis'] = self.max_idle_time_millis
        if self.keep_alive_duration_millis is not None:
            result['keepAliveDurationMillis'] = self.keep_alive_duration_millis
        if self.max_requests is not None:
            result['maxRequests'] = self.max_requests
        if self.max_requests_per_host is not None:
            result['maxRequestsPerHost'] = self.max_requests_per_host
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessKeyId') is not None:
            self.access_key_id = m.get('accessKeyId')
        if m.get('accessKeySecret') is not None:
            self.access_key_secret = m.get('accessKeySecret')
        if m.get('securityToken') is not None:
            self.security_token = m.get('securityToken')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('readTimeout') is not None:
            self.read_timeout = m.get('readTimeout')
        if m.get('connectTimeout') is not None:
            self.connect_timeout = m.get('connectTimeout')
        if m.get('httpProxy') is not None:
            self.http_proxy = m.get('httpProxy')
        if m.get('httpsProxy') is not None:
            self.https_proxy = m.get('httpsProxy')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('noProxy') is not None:
            self.no_proxy = m.get('noProxy')
        if m.get('maxIdleConns') is not None:
            self.max_idle_conns = m.get('maxIdleConns')
        if m.get('userAgent') is not None:
            self.user_agent = m.get('userAgent')
        if m.get('socks5Proxy') is not None:
            self.socks_5proxy = m.get('socks5Proxy')
        if m.get('socks5NetWork') is not None:
            self.socks_5net_work = m.get('socks5NetWork')
        if m.get('maxIdleTimeMillis') is not None:
            self.max_idle_time_millis = m.get('maxIdleTimeMillis')
        if m.get('keepAliveDurationMillis') is not None:
            self.keep_alive_duration_millis = m.get('keepAliveDurationMillis')
        if m.get('maxRequests') is not None:
            self.max_requests = m.get('maxRequests')
        if m.get('maxRequestsPerHost') is not None:
            self.max_requests_per_host = m.get('maxRequestsPerHost')
        return self


class XCondition(TeaModel):
    def __init__(
        self,
        expr: str = None,
        operator: str = None,
        value: str = None,
        values: List[str] = None,
        all: bool = None,
    ):
        # 表达式
        self.expr = expr
        # operator
        self.operator = operator
        # value
        self.value = value
        # 
        self.values = values
        # 
        self.all = all

    def validate(self):
        self.validate_required(self.expr, 'expr')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        result = dict()
        if self.expr is not None:
            result['expr'] = self.expr
        if self.operator is not None:
            result['operator'] = self.operator
        if self.value is not None:
            result['value'] = self.value
        if self.values is not None:
            result['values'] = self.values
        if self.all is not None:
            result['all'] = self.all
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('values') is not None:
            self.values = m.get('values')
        if m.get('all') is not None:
            self.all = m.get('all')
        return self


class XMetricQueryMetadata(TeaModel):
    def __init__(
        self,
        name: str = None,
        datasource_uuid: str = None,
        metric_name: str = None,
        table_name: str = None,
        conditions: List[XCondition] = None,
    ):
        # query clause name
        self.name = name
        # 32位datasource uuid
        self.datasource_uuid = datasource_uuid
        # metric name
        self.metric_name = metric_name
        # 
        self.table_name = table_name
        # 
        self.conditions = conditions

    def validate(self):
        self.validate_required(self.datasource_uuid, 'datasource_uuid')
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.datasource_uuid is not None:
            result['datasource_uuid'] = self.datasource_uuid
        if self.metric_name is not None:
            result['metric_name'] = self.metric_name
        if self.table_name is not None:
            result['table_name'] = self.table_name
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('datasource_uuid') is not None:
            self.datasource_uuid = m.get('datasource_uuid')
        if m.get('metric_name') is not None:
            self.metric_name = m.get('metric_name')
        if m.get('table_name') is not None:
            self.table_name = m.get('table_name')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = XCondition()
                self.conditions.append(temp_model.from_map(k))
        return self


class XTranslateExpression(TeaModel):
    def __init__(
        self,
        type: str = None,
        from_: str = None,
        to: str = None,
    ):
        # expression type
        self.type = type
        # from
        self.from_ = from_
        # to
        self.to = to

    def validate(self):
        self.validate_required(self.type, 'type')
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')

    def to_map(self):
        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class XCalculationParameter(TeaModel):
    def __init__(
        self,
        expression: str = None,
        constant: bool = None,
    ):
        # x
        self.expression = expression
        # x
        self.constant = constant

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.expression is not None:
            result['expression'] = self.expression
        if self.constant is not None:
            result['constant'] = self.constant
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('constant') is not None:
            self.constant = m.get('constant')
        return self


class XMetricInfo(TeaModel):
    def __init__(
        self,
        name: str = None,
        description: str = None,
        type: str = None,
        unit: str = None,
    ):
        # 
        self.name = name
        # 
        self.description = description
        # 
        self.type = type
        # 
        self.unit = unit

    def validate(self):
        self.validate_required(self.name, 'name')

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.description is not None:
            result['description'] = self.description
        if self.type is not None:
            result['type'] = self.type
        if self.unit is not None:
            result['unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('unit') is not None:
            self.unit = m.get('unit')
        return self


class XTranslate(TeaModel):
    def __init__(
        self,
        default_value: str = None,
        include_not_matched: bool = None,
        translate_expressions: List[XTranslateExpression] = None,
    ):
        # 
        self.default_value = default_value
        # 
        self.include_not_matched = include_not_matched
        # 
        self.translate_expressions = translate_expressions

    def validate(self):
        if self.translate_expressions:
            for k in self.translate_expressions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.default_value is not None:
            result['default_value'] = self.default_value
        if self.include_not_matched is not None:
            result['include_not_matched'] = self.include_not_matched
        result['translate_expressions'] = []
        if self.translate_expressions is not None:
            for k in self.translate_expressions:
                result['translate_expressions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('default_value') is not None:
            self.default_value = m.get('default_value')
        if m.get('include_not_matched') is not None:
            self.include_not_matched = m.get('include_not_matched')
        self.translate_expressions = []
        if m.get('translate_expressions') is not None:
            for k in m.get('translate_expressions'):
                temp_model = XTranslateExpression()
                self.translate_expressions.append(temp_model.from_map(k))
        return self


class XCalculationExpression(TeaModel):
    def __init__(
        self,
        function: str = None,
        parameters: List[XCalculationParameter] = None,
        query: str = None,
        query_metadatas: List[XMetricQueryMetadata] = None,
        type: str = None,
    ):
        # x
        self.function = function
        # x
        self.parameters = parameters
        # PromQL
        self.query = query
        # 
        self.query_metadatas = query_metadatas
        # calculation type
        self.type = type

    def validate(self):
        if self.parameters:
            for k in self.parameters:
                if k:
                    k.validate()
        if self.query_metadatas:
            for k in self.query_metadatas:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.function is not None:
            result['function'] = self.function
        result['parameters'] = []
        if self.parameters is not None:
            for k in self.parameters:
                result['parameters'].append(k.to_map() if k else None)
        if self.query is not None:
            result['query'] = self.query
        result['query_metadatas'] = []
        if self.query_metadatas is not None:
            for k in self.query_metadatas:
                result['query_metadatas'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('function') is not None:
            self.function = m.get('function')
        self.parameters = []
        if m.get('parameters') is not None:
            for k in m.get('parameters'):
                temp_model = XCalculationParameter()
                self.parameters.append(temp_model.from_map(k))
        if m.get('query') is not None:
            self.query = m.get('query')
        self.query_metadatas = []
        if m.get('query_metadatas') is not None:
            for k in m.get('query_metadatas'):
                temp_model = XMetricQueryMetadata()
                self.query_metadatas.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AiExtraAttr(TeaModel):
    def __init__(
        self,
        time_range_thres: str = None,
        abnormal_value_thres: str = None,
        value_range_thres: str = None,
        algo_score_thres: str = None,
    ):
        # time_range_thres
        self.time_range_thres = time_range_thres
        # abnormal_value_thres
        self.abnormal_value_thres = abnormal_value_thres
        # value_range_thres
        self.value_range_thres = value_range_thres
        # algo_score_thres
        self.algo_score_thres = algo_score_thres

    def validate(self):
        self.validate_required(self.time_range_thres, 'time_range_thres')
        self.validate_required(self.abnormal_value_thres, 'abnormal_value_thres')
        self.validate_required(self.value_range_thres, 'value_range_thres')
        self.validate_required(self.algo_score_thres, 'algo_score_thres')

    def to_map(self):
        result = dict()
        if self.time_range_thres is not None:
            result['time_range_thres'] = self.time_range_thres
        if self.abnormal_value_thres is not None:
            result['abnormal_value_thres'] = self.abnormal_value_thres
        if self.value_range_thres is not None:
            result['value_range_thres'] = self.value_range_thres
        if self.algo_score_thres is not None:
            result['algo_score_thres'] = self.algo_score_thres
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('time_range_thres') is not None:
            self.time_range_thres = m.get('time_range_thres')
        if m.get('abnormal_value_thres') is not None:
            self.abnormal_value_thres = m.get('abnormal_value_thres')
        if m.get('value_range_thres') is not None:
            self.value_range_thres = m.get('value_range_thres')
        if m.get('algo_score_thres') is not None:
            self.algo_score_thres = m.get('algo_score_thres')
        return self


class XMatchExpression(TeaModel):
    def __init__(
        self,
        type: str = None,
        expr: str = None,
        left: str = None,
        left_index: int = None,
        right: str = None,
        value_type: str = None,
    ):
        # match expression type
        self.type = type
        # metadata field expr
        self.expr = expr
        # left character
        self.left = left
        # left index
        self.left_index = left_index
        # 
        self.right = right
        # 
        self.value_type = value_type

    def validate(self):
        self.validate_required(self.type, 'type')

    def to_map(self):
        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.expr is not None:
            result['expr'] = self.expr
        if self.left is not None:
            result['left'] = self.left
        if self.left_index is not None:
            result['left_index'] = self.left_index
        if self.right is not None:
            result['right'] = self.right
        if self.value_type is not None:
            result['value_type'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('expr') is not None:
            self.expr = m.get('expr')
        if m.get('left') is not None:
            self.left = m.get('left')
        if m.get('left_index') is not None:
            self.left_index = m.get('left_index')
        if m.get('right') is not None:
            self.right = m.get('right')
        if m.get('value_type') is not None:
            self.value_type = m.get('value_type')
        return self


class Threshold(TeaModel):
    def __init__(
        self,
        level_1: str = None,
        level_2: str = None,
        level_3: str = None,
        im: str = None,
        sms: str = None,
        control_plan: str = None,
    ):
        # level1
        self.level_1 = level_1
        # level2
        self.level_2 = level_2
        # level3
        self.level_3 = level_3
        # im
        self.im = im
        # sms
        self.sms = sms
        # control_plan
        self.control_plan = control_plan

    def validate(self):
        self.validate_required(self.level_1, 'level_1')
        self.validate_required(self.level_2, 'level_2')
        self.validate_required(self.level_3, 'level_3')
        self.validate_required(self.im, 'im')
        self.validate_required(self.sms, 'sms')
        self.validate_required(self.control_plan, 'control_plan')

    def to_map(self):
        result = dict()
        if self.level_1 is not None:
            result['level1'] = self.level_1
        if self.level_2 is not None:
            result['level2'] = self.level_2
        if self.level_3 is not None:
            result['level3'] = self.level_3
        if self.im is not None:
            result['im'] = self.im
        if self.sms is not None:
            result['sms'] = self.sms
        if self.control_plan is not None:
            result['control_plan'] = self.control_plan
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('level1') is not None:
            self.level_1 = m.get('level1')
        if m.get('level2') is not None:
            self.level_2 = m.get('level2')
        if m.get('level3') is not None:
            self.level_3 = m.get('level3')
        if m.get('im') is not None:
            self.im = m.get('im')
        if m.get('sms') is not None:
            self.sms = m.get('sms')
        if m.get('control_plan') is not None:
            self.control_plan = m.get('control_plan')
        return self


class XStringKeyValue(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class DimFilter(TeaModel):
    def __init__(
        self,
        dim_index: int = None,
        dim_name: str = None,
        white_names: List[str] = None,
        black_names: List[str] = None,
    ):
        # dim_index
        self.dim_index = dim_index
        # dim_name
        self.dim_name = dim_name
        # white_names
        self.white_names = white_names
        # black_names
        self.black_names = black_names

    def validate(self):
        self.validate_required(self.dim_index, 'dim_index')
        self.validate_required(self.dim_name, 'dim_name')
        self.validate_required(self.white_names, 'white_names')
        self.validate_required(self.black_names, 'black_names')

    def to_map(self):
        result = dict()
        if self.dim_index is not None:
            result['dim_index'] = self.dim_index
        if self.dim_name is not None:
            result['dim_name'] = self.dim_name
        if self.white_names is not None:
            result['white_names'] = self.white_names
        if self.black_names is not None:
            result['black_names'] = self.black_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dim_index') is not None:
            self.dim_index = m.get('dim_index')
        if m.get('dim_name') is not None:
            self.dim_name = m.get('dim_name')
        if m.get('white_names') is not None:
            self.white_names = m.get('white_names')
        if m.get('black_names') is not None:
            self.black_names = m.get('black_names')
        return self


class WorkspaceDTO(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        display_name: str = None,
        outside_ws_id: str = None,
        tenant_id: int = None,
        outside_tenant_id: str = None,
        stack_view: bool = None,
    ):
        # id
        self.id = id
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_ws_id
        self.outside_ws_id = outside_ws_id
        # tenant_id
        self.tenant_id = tenant_id
        # outside_tenant_id
        self.outside_tenant_id = outside_tenant_id
        # stack_view
        self.stack_view = stack_view

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.outside_ws_id, 'outside_ws_id')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.outside_tenant_id, 'outside_tenant_id')
        self.validate_required(self.stack_view, 'stack_view')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_ws_id is not None:
            result['outside_ws_id'] = self.outside_ws_id
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.outside_tenant_id is not None:
            result['outside_tenant_id'] = self.outside_tenant_id
        if self.stack_view is not None:
            result['stack_view'] = self.stack_view
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_ws_id') is not None:
            self.outside_ws_id = m.get('outside_ws_id')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('outside_tenant_id') is not None:
            self.outside_tenant_id = m.get('outside_tenant_id')
        if m.get('stack_view') is not None:
            self.stack_view = m.get('stack_view')
        return self


class AiAlarmParams(TeaModel):
    def __init__(
        self,
        value_fields: List[str] = None,
        ai_algo_code: str = None,
        ai_extra_attr: AiExtraAttr = None,
    ):
        # value_fields
        self.value_fields = value_fields
        # ai_algo_code
        self.ai_algo_code = ai_algo_code
        # ai_extra_attr
        self.ai_extra_attr = ai_extra_attr

    def validate(self):
        self.validate_required(self.value_fields, 'value_fields')
        self.validate_required(self.ai_algo_code, 'ai_algo_code')
        self.validate_required(self.ai_extra_attr, 'ai_extra_attr')
        if self.ai_extra_attr:
            self.ai_extra_attr.validate()

    def to_map(self):
        result = dict()
        if self.value_fields is not None:
            result['value_fields'] = self.value_fields
        if self.ai_algo_code is not None:
            result['ai_algo_code'] = self.ai_algo_code
        if self.ai_extra_attr is not None:
            result['ai_extra_attr'] = self.ai_extra_attr.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value_fields') is not None:
            self.value_fields = m.get('value_fields')
        if m.get('ai_algo_code') is not None:
            self.ai_algo_code = m.get('ai_algo_code')
        if m.get('ai_extra_attr') is not None:
            temp_model = AiExtraAttr()
            self.ai_extra_attr = temp_model.from_map(m['ai_extra_attr'])
        return self


class TimeRange(TeaModel):
    def __init__(
        self,
        start: int = None,
        end: int = None,
    ):
        # start
        self.start = start
        # end
        self.end = end

    def validate(self):
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')

    def to_map(self):
        result = dict()
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        return self


class Trigger(TeaModel):
    def __init__(
        self,
        value_field: str = None,
        value_index: int = None,
        type: str = None,
        n: int = None,
        compare: str = None,
        compare_percent: str = None,
        threshold: Threshold = None,
        threshold_copy: Threshold = None,
        value_is_percent: bool = None,
    ):
        # value_field
        self.value_field = value_field
        # value_index
        self.value_index = value_index
        # type
        self.type = type
        # n
        self.n = n
        # compare
        self.compare = compare
        # compare_percent
        self.compare_percent = compare_percent
        # threshold
        self.threshold = threshold
        # threshold_copy
        self.threshold_copy = threshold_copy
        # value_is_percent
        self.value_is_percent = value_is_percent

    def validate(self):
        self.validate_required(self.value_field, 'value_field')
        self.validate_required(self.value_index, 'value_index')
        self.validate_required(self.type, 'type')
        self.validate_required(self.n, 'n')
        self.validate_required(self.compare, 'compare')
        self.validate_required(self.compare_percent, 'compare_percent')
        self.validate_required(self.threshold, 'threshold')
        if self.threshold:
            self.threshold.validate()
        self.validate_required(self.threshold_copy, 'threshold_copy')
        if self.threshold_copy:
            self.threshold_copy.validate()
        self.validate_required(self.value_is_percent, 'value_is_percent')

    def to_map(self):
        result = dict()
        if self.value_field is not None:
            result['value_field'] = self.value_field
        if self.value_index is not None:
            result['value_index'] = self.value_index
        if self.type is not None:
            result['type'] = self.type
        if self.n is not None:
            result['n'] = self.n
        if self.compare is not None:
            result['compare'] = self.compare
        if self.compare_percent is not None:
            result['compare_percent'] = self.compare_percent
        if self.threshold is not None:
            result['threshold'] = self.threshold.to_map()
        if self.threshold_copy is not None:
            result['threshold_copy'] = self.threshold_copy.to_map()
        if self.value_is_percent is not None:
            result['value_is_percent'] = self.value_is_percent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value_field') is not None:
            self.value_field = m.get('value_field')
        if m.get('value_index') is not None:
            self.value_index = m.get('value_index')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('n') is not None:
            self.n = m.get('n')
        if m.get('compare') is not None:
            self.compare = m.get('compare')
        if m.get('compare_percent') is not None:
            self.compare_percent = m.get('compare_percent')
        if m.get('threshold') is not None:
            temp_model = Threshold()
            self.threshold = temp_model.from_map(m['threshold'])
        if m.get('threshold_copy') is not None:
            temp_model = Threshold()
            self.threshold_copy = temp_model.from_map(m['threshold_copy'])
        if m.get('value_is_percent') is not None:
            self.value_is_percent = m.get('value_is_percent')
        return self


class TimeFilter(TeaModel):
    def __init__(
        self,
        from_: str = None,
        to: str = None,
        weeks: List[int] = None,
    ):
        # from
        self.from_ = from_
        # to
        self.to = to
        # weeks
        self.weeks = weeks

    def validate(self):
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')
        self.validate_required(self.weeks, 'weeks')

    def to_map(self):
        result = dict()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        if self.weeks is not None:
            result['weeks'] = self.weeks
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('weeks') is not None:
            self.weeks = m.get('weeks')
        return self


class BizDomain(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        tenant_id: int = None,
        config: str = None,
        outside_domain_id: str = None,
        entity_list: str = None,
    ):
        # id
        self.id = id
        # name
        self.name = name
        # tenant_id
        # 
        self.tenant_id = tenant_id
        # config
        self.config = config
        # outside_domain_id
        self.outside_domain_id = outside_domain_id
        # entity_list
        self.entity_list = entity_list

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.config, 'config')
        self.validate_required(self.outside_domain_id, 'outside_domain_id')
        self.validate_required(self.entity_list, 'entity_list')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.config is not None:
            result['config'] = self.config
        if self.outside_domain_id is not None:
            result['outside_domain_id'] = self.outside_domain_id
        if self.entity_list is not None:
            result['entity_list'] = self.entity_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('outside_domain_id') is not None:
            self.outside_domain_id = m.get('outside_domain_id')
        if m.get('entity_list') is not None:
            self.entity_list = m.get('entity_list')
        return self


class XExpression(TeaModel):
    def __init__(
        self,
        name: str = None,
        description: str = None,
        match_expression: XMatchExpression = None,
        translate_expression: XTranslate = None,
        type: str = None,
        unit: str = None,
        downsample_func: str = None,
        aggregation_func: str = None,
        expression_tags: List[XMetricInfo] = None,
        enabled: bool = None,
        values: List[str] = None,
        display_name: str = None,
        path_parameters: List[XStringKeyValue] = None,
        calculation_expression: XCalculationExpression = None,
        source_name: str = None,
    ):
        # name
        self.name = name
        # 
        self.description = description
        # 
        self.match_expression = match_expression
        # 
        self.translate_expression = translate_expression
        # metric type
        self.type = type
        # 
        self.unit = unit
        # 
        self.downsample_func = downsample_func
        # 
        self.aggregation_func = aggregation_func
        # prometheus tags
        self.expression_tags = expression_tags
        # prometheus metric-tags 是否采集
        self.enabled = enabled
        # line filter
        self.values = values
        # 
        self.display_name = display_name
        # 
        self.path_parameters = path_parameters
        # x
        self.calculation_expression = calculation_expression
        # 计算数据源使用的原始指标名称
        self.source_name = source_name

    def validate(self):
        if self.match_expression:
            self.match_expression.validate()
        if self.translate_expression:
            self.translate_expression.validate()
        if self.expression_tags:
            for k in self.expression_tags:
                if k:
                    k.validate()
        if self.path_parameters:
            for k in self.path_parameters:
                if k:
                    k.validate()
        if self.calculation_expression:
            self.calculation_expression.validate()

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.description is not None:
            result['description'] = self.description
        if self.match_expression is not None:
            result['match_expression'] = self.match_expression.to_map()
        if self.translate_expression is not None:
            result['translate_expression'] = self.translate_expression.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.unit is not None:
            result['unit'] = self.unit
        if self.downsample_func is not None:
            result['downsample_func'] = self.downsample_func
        if self.aggregation_func is not None:
            result['aggregation_func'] = self.aggregation_func
        result['expression_tags'] = []
        if self.expression_tags is not None:
            for k in self.expression_tags:
                result['expression_tags'].append(k.to_map() if k else None)
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.values is not None:
            result['values'] = self.values
        if self.display_name is not None:
            result['display_name'] = self.display_name
        result['path_parameters'] = []
        if self.path_parameters is not None:
            for k in self.path_parameters:
                result['path_parameters'].append(k.to_map() if k else None)
        if self.calculation_expression is not None:
            result['calculation_expression'] = self.calculation_expression.to_map()
        if self.source_name is not None:
            result['source_name'] = self.source_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('match_expression') is not None:
            temp_model = XMatchExpression()
            self.match_expression = temp_model.from_map(m['match_expression'])
        if m.get('translate_expression') is not None:
            temp_model = XTranslate()
            self.translate_expression = temp_model.from_map(m['translate_expression'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('unit') is not None:
            self.unit = m.get('unit')
        if m.get('downsample_func') is not None:
            self.downsample_func = m.get('downsample_func')
        if m.get('aggregation_func') is not None:
            self.aggregation_func = m.get('aggregation_func')
        self.expression_tags = []
        if m.get('expression_tags') is not None:
            for k in m.get('expression_tags'):
                temp_model = XMetricInfo()
                self.expression_tags.append(temp_model.from_map(k))
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('values') is not None:
            self.values = m.get('values')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        self.path_parameters = []
        if m.get('path_parameters') is not None:
            for k in m.get('path_parameters'):
                temp_model = XStringKeyValue()
                self.path_parameters.append(temp_model.from_map(k))
        if m.get('calculation_expression') is not None:
            temp_model = XCalculationExpression()
            self.calculation_expression = temp_model.from_map(m['calculation_expression'])
        if m.get('source_name') is not None:
            self.source_name = m.get('source_name')
        return self


class ControlPlan(TeaModel):
    def __init__(
        self,
        action_id: int = None,
        name: str = None,
        plugin_type: str = None,
        plugin_id: str = None,
        file_id: int = None,
        ds_name: str = None,
    ):
        # action_id
        self.action_id = action_id
        # name
        self.name = name
        # plugin_type
        self.plugin_type = plugin_type
        # plugin_id
        self.plugin_id = plugin_id
        # file_id
        self.file_id = file_id
        # ds_name
        self.ds_name = ds_name

    def validate(self):
        self.validate_required(self.action_id, 'action_id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.plugin_type, 'plugin_type')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.ds_name, 'ds_name')

    def to_map(self):
        result = dict()
        if self.action_id is not None:
            result['action_id'] = self.action_id
        if self.name is not None:
            result['name'] = self.name
        if self.plugin_type is not None:
            result['plugin_type'] = self.plugin_type
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.ds_name is not None:
            result['ds_name'] = self.ds_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_id') is not None:
            self.action_id = m.get('action_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('plugin_type') is not None:
            self.plugin_type = m.get('plugin_type')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('ds_name') is not None:
            self.ds_name = m.get('ds_name')
        return self


class NavWorkspace(TeaModel):
    def __init__(
        self,
        workspace: WorkspaceDTO = None,
    ):
        # workspace
        self.workspace = workspace

    def validate(self):
        self.validate_required(self.workspace, 'workspace')
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            temp_model = WorkspaceDTO()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class Tenant(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        display_name: str = None,
        outside_tenant_id: str = None,
        status: str = None,
        config: str = None,
        stack_view: bool = None,
    ):
        # ID
        self.id = id
        # 租户名称
        self.name = name
        # 展示名称
        self.display_name = display_name
        # outsideTenantId
        self.outside_tenant_id = outside_tenant_id
        # status
        self.status = status
        # config
        self.config = config
        # stack_view
        self.stack_view = stack_view

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.outside_tenant_id, 'outside_tenant_id')
        self.validate_required(self.status, 'status')
        self.validate_required(self.config, 'config')
        self.validate_required(self.stack_view, 'stack_view')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_tenant_id is not None:
            result['outside_tenant_id'] = self.outside_tenant_id
        if self.status is not None:
            result['status'] = self.status
        if self.config is not None:
            result['config'] = self.config
        if self.stack_view is not None:
            result['stack_view'] = self.stack_view
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_tenant_id') is not None:
            self.outside_tenant_id = m.get('outside_tenant_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('stack_view') is not None:
            self.stack_view = m.get('stack_view')
        return self


class TranslateMapping(TeaModel):
    def __init__(
        self,
        from_: str = None,
        to: str = None,
        mode: str = None,
    ):
        # 原始列值
        self.from_ = from_
        # 翻译后列值
        self.to = to
        # 正则类型 (完整正则或简单正则)
        self.mode = mode

    def validate(self):
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')
        self.validate_required(self.mode, 'mode')

    def to_map(self):
        result = dict()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        if self.mode is not None:
            result['mode'] = self.mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        return self


class XLogSubRule(TeaModel):
    def __init__(
        self,
        path: str = None,
        metrics: List[XExpression] = None,
        rule_tags: List[XExpression] = None,
        include_lines: List[XExpression] = None,
        exclude_lines: List[XExpression] = None,
        paths: List[str] = None,
        path_link_prefix: str = None,
        path_expression: XExpression = None,
    ):
        # log path
        self.path = path
        # 
        self.metrics = metrics
        # 
        self.rule_tags = rule_tags
        # 白名单
        self.include_lines = include_lines
        # 
        self.exclude_lines = exclude_lines
        # x
        self.paths = paths
        # x
        self.path_link_prefix = path_link_prefix
        # 
        self.path_expression = path_expression

    def validate(self):
        self.validate_required(self.metrics, 'metrics')
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        if self.rule_tags:
            for k in self.rule_tags:
                if k:
                    k.validate()
        if self.include_lines:
            for k in self.include_lines:
                if k:
                    k.validate()
        if self.exclude_lines:
            for k in self.exclude_lines:
                if k:
                    k.validate()
        if self.path_expression:
            self.path_expression.validate()

    def to_map(self):
        result = dict()
        if self.path is not None:
            result['path'] = self.path
        result['metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['metrics'].append(k.to_map() if k else None)
        result['rule_tags'] = []
        if self.rule_tags is not None:
            for k in self.rule_tags:
                result['rule_tags'].append(k.to_map() if k else None)
        result['include_lines'] = []
        if self.include_lines is not None:
            for k in self.include_lines:
                result['include_lines'].append(k.to_map() if k else None)
        result['exclude_lines'] = []
        if self.exclude_lines is not None:
            for k in self.exclude_lines:
                result['exclude_lines'].append(k.to_map() if k else None)
        if self.paths is not None:
            result['paths'] = self.paths
        if self.path_link_prefix is not None:
            result['path_link_prefix'] = self.path_link_prefix
        if self.path_expression is not None:
            result['path_expression'] = self.path_expression.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('path') is not None:
            self.path = m.get('path')
        self.metrics = []
        if m.get('metrics') is not None:
            for k in m.get('metrics'):
                temp_model = XExpression()
                self.metrics.append(temp_model.from_map(k))
        self.rule_tags = []
        if m.get('rule_tags') is not None:
            for k in m.get('rule_tags'):
                temp_model = XExpression()
                self.rule_tags.append(temp_model.from_map(k))
        self.include_lines = []
        if m.get('include_lines') is not None:
            for k in m.get('include_lines'):
                temp_model = XExpression()
                self.include_lines.append(temp_model.from_map(k))
        self.exclude_lines = []
        if m.get('exclude_lines') is not None:
            for k in m.get('exclude_lines'):
                temp_model = XExpression()
                self.exclude_lines.append(temp_model.from_map(k))
        if m.get('paths') is not None:
            self.paths = m.get('paths')
        if m.get('path_link_prefix') is not None:
            self.path_link_prefix = m.get('path_link_prefix')
        if m.get('path_expression') is not None:
            temp_model = XExpression()
            self.path_expression = temp_model.from_map(m['path_expression'])
        return self


class NavBizDomain(TeaModel):
    def __init__(
        self,
        biz_domain: BizDomain = None,
    ):
        # biz_domain
        self.biz_domain = biz_domain

    def validate(self):
        self.validate_required(self.biz_domain, 'biz_domain')
        if self.biz_domain:
            self.biz_domain.validate()

    def to_map(self):
        result = dict()
        if self.biz_domain is not None:
            result['biz_domain'] = self.biz_domain.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_domain') is not None:
            temp_model = BizDomain()
            self.biz_domain = temp_model.from_map(m['biz_domain'])
        return self


class Rule(TeaModel):
    def __init__(
        self,
        ai_alarm_params: AiAlarmParams = None,
        name: str = None,
        run_type: str = None,
        cal_time_range: TimeRange = None,
        exclude_data_time_range: TimeRange = None,
        dim_filters: List[DimFilter] = None,
        time_filter: TimeFilter = None,
        triggers: List[Trigger] = None,
        andor: str = None,
        control_plan_auto: bool = None,
        control_plans: List[ControlPlan] = None,
        function_id: int = None,
        from_tmp_rule: int = None,
        rule_type: str = None,
        ports: List[str] = None,
        group_by: List[str] = None,
    ):
        # ai_alarm_params
        self.ai_alarm_params = ai_alarm_params
        # name
        self.name = name
        # run_type
        self.run_type = run_type
        # cal_time_range
        self.cal_time_range = cal_time_range
        # exclude_data_time_range
        self.exclude_data_time_range = exclude_data_time_range
        # dim_filters
        self.dim_filters = dim_filters
        # time_filter
        self.time_filter = time_filter
        # triggers
        self.triggers = triggers
        # andor
        self.andor = andor
        # control_plan_auto
        self.control_plan_auto = control_plan_auto
        # control_plans
        self.control_plans = control_plans
        # function_id
        self.function_id = function_id
        # from_tmp_rule
        self.from_tmp_rule = from_tmp_rule
        # rule_type
        self.rule_type = rule_type
        # ports
        self.ports = ports
        # group_by
        self.group_by = group_by

    def validate(self):
        self.validate_required(self.ai_alarm_params, 'ai_alarm_params')
        if self.ai_alarm_params:
            self.ai_alarm_params.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.run_type, 'run_type')
        self.validate_required(self.cal_time_range, 'cal_time_range')
        if self.cal_time_range:
            self.cal_time_range.validate()
        self.validate_required(self.exclude_data_time_range, 'exclude_data_time_range')
        if self.exclude_data_time_range:
            self.exclude_data_time_range.validate()
        self.validate_required(self.dim_filters, 'dim_filters')
        if self.dim_filters:
            for k in self.dim_filters:
                if k:
                    k.validate()
        self.validate_required(self.time_filter, 'time_filter')
        if self.time_filter:
            self.time_filter.validate()
        self.validate_required(self.triggers, 'triggers')
        if self.triggers:
            for k in self.triggers:
                if k:
                    k.validate()
        self.validate_required(self.andor, 'andor')
        self.validate_required(self.control_plan_auto, 'control_plan_auto')
        self.validate_required(self.control_plans, 'control_plans')
        if self.control_plans:
            for k in self.control_plans:
                if k:
                    k.validate()
        self.validate_required(self.function_id, 'function_id')
        self.validate_required(self.from_tmp_rule, 'from_tmp_rule')
        self.validate_required(self.rule_type, 'rule_type')
        self.validate_required(self.ports, 'ports')
        self.validate_required(self.group_by, 'group_by')

    def to_map(self):
        result = dict()
        if self.ai_alarm_params is not None:
            result['ai_alarm_params'] = self.ai_alarm_params.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.run_type is not None:
            result['run_type'] = self.run_type
        if self.cal_time_range is not None:
            result['cal_time_range'] = self.cal_time_range.to_map()
        if self.exclude_data_time_range is not None:
            result['exclude_data_time_range'] = self.exclude_data_time_range.to_map()
        result['dim_filters'] = []
        if self.dim_filters is not None:
            for k in self.dim_filters:
                result['dim_filters'].append(k.to_map() if k else None)
        if self.time_filter is not None:
            result['time_filter'] = self.time_filter.to_map()
        result['triggers'] = []
        if self.triggers is not None:
            for k in self.triggers:
                result['triggers'].append(k.to_map() if k else None)
        if self.andor is not None:
            result['andor'] = self.andor
        if self.control_plan_auto is not None:
            result['control_plan_auto'] = self.control_plan_auto
        result['control_plans'] = []
        if self.control_plans is not None:
            for k in self.control_plans:
                result['control_plans'].append(k.to_map() if k else None)
        if self.function_id is not None:
            result['function_id'] = self.function_id
        if self.from_tmp_rule is not None:
            result['from_tmp_rule'] = self.from_tmp_rule
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.ports is not None:
            result['ports'] = self.ports
        if self.group_by is not None:
            result['group_by'] = self.group_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ai_alarm_params') is not None:
            temp_model = AiAlarmParams()
            self.ai_alarm_params = temp_model.from_map(m['ai_alarm_params'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('run_type') is not None:
            self.run_type = m.get('run_type')
        if m.get('cal_time_range') is not None:
            temp_model = TimeRange()
            self.cal_time_range = temp_model.from_map(m['cal_time_range'])
        if m.get('exclude_data_time_range') is not None:
            temp_model = TimeRange()
            self.exclude_data_time_range = temp_model.from_map(m['exclude_data_time_range'])
        self.dim_filters = []
        if m.get('dim_filters') is not None:
            for k in m.get('dim_filters'):
                temp_model = DimFilter()
                self.dim_filters.append(temp_model.from_map(k))
        if m.get('time_filter') is not None:
            temp_model = TimeFilter()
            self.time_filter = temp_model.from_map(m['time_filter'])
        self.triggers = []
        if m.get('triggers') is not None:
            for k in m.get('triggers'):
                temp_model = Trigger()
                self.triggers.append(temp_model.from_map(k))
        if m.get('andor') is not None:
            self.andor = m.get('andor')
        if m.get('control_plan_auto') is not None:
            self.control_plan_auto = m.get('control_plan_auto')
        self.control_plans = []
        if m.get('control_plans') is not None:
            for k in m.get('control_plans'):
                temp_model = ControlPlan()
                self.control_plans.append(temp_model.from_map(k))
        if m.get('function_id') is not None:
            self.function_id = m.get('function_id')
        if m.get('from_tmp_rule') is not None:
            self.from_tmp_rule = m.get('from_tmp_rule')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('ports') is not None:
            self.ports = m.get('ports')
        if m.get('group_by') is not None:
            self.group_by = m.get('group_by')
        return self


class NavTenant(TeaModel):
    def __init__(
        self,
        tenant: Tenant = None,
        view_power: bool = None,
        nav_workspaces: List[NavWorkspace] = None,
        nav_biz_domains: List[NavBizDomain] = None,
    ):
        # tenant
        self.tenant = tenant
        # view_power
        self.view_power = view_power
        # nav_workspaces
        self.nav_workspaces = nav_workspaces
        # nav_biz_domains
        self.nav_biz_domains = nav_biz_domains

    def validate(self):
        self.validate_required(self.tenant, 'tenant')
        if self.tenant:
            self.tenant.validate()
        self.validate_required(self.view_power, 'view_power')
        self.validate_required(self.nav_workspaces, 'nav_workspaces')
        if self.nav_workspaces:
            for k in self.nav_workspaces:
                if k:
                    k.validate()
        self.validate_required(self.nav_biz_domains, 'nav_biz_domains')
        if self.nav_biz_domains:
            for k in self.nav_biz_domains:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.tenant is not None:
            result['tenant'] = self.tenant.to_map()
        if self.view_power is not None:
            result['view_power'] = self.view_power
        result['nav_workspaces'] = []
        if self.nav_workspaces is not None:
            for k in self.nav_workspaces:
                result['nav_workspaces'].append(k.to_map() if k else None)
        result['nav_biz_domains'] = []
        if self.nav_biz_domains is not None:
            for k in self.nav_biz_domains:
                result['nav_biz_domains'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenant') is not None:
            temp_model = Tenant()
            self.tenant = temp_model.from_map(m['tenant'])
        if m.get('view_power') is not None:
            self.view_power = m.get('view_power')
        self.nav_workspaces = []
        if m.get('nav_workspaces') is not None:
            for k in m.get('nav_workspaces'):
                temp_model = NavWorkspace()
                self.nav_workspaces.append(temp_model.from_map(k))
        self.nav_biz_domains = []
        if m.get('nav_biz_domains') is not None:
            for k in m.get('nav_biz_domains'):
                temp_model = NavBizDomain()
                self.nav_biz_domains.append(temp_model.from_map(k))
        return self


class XRule(TeaModel):
    def __init__(
        self,
        type: str = None,
        interval: int = None,
        timeout: int = None,
        external_tags: List[XExpression] = None,
        rules: List[XLogSubRule] = None,
        metrics: List[XExpression] = None,
        port: int = None,
        path: str = None,
        scheme: str = None,
        method: str = None,
        ports: List[int] = None,
        tags: List[XExpression] = None,
        expression: str = None,
        target: XMatchExpression = None,
        local_host: bool = None,
        ca_file: str = None,
        cert_file: str = None,
        key_file: str = None,
        bearer_token_file: str = None,
        insecure_skip_verify: bool = None,
    ):
        # rule type
        self.type = type
        # 
        self.interval = interval
        # rule timeout
        self.timeout = timeout
        # 
        self.external_tags = external_tags
        # log rules
        self.rules = rules
        # metrics
        self.metrics = metrics
        # prometheus port
        self.port = port
        # prometheus path
        self.path = path
        # 
        self.scheme = scheme
        # 
        self.method = method
        # tcp ports
        self.ports = ports
        # 
        self.tags = tags
        # 
        self.expression = expression
        # 
        self.target = target
        # 
        self.local_host = local_host
        # 
        self.ca_file = ca_file
        # 
        self.cert_file = cert_file
        # 
        self.key_file = key_file
        # 
        self.bearer_token_file = bearer_token_file
        # 
        self.insecure_skip_verify = insecure_skip_verify

    def validate(self):
        self.validate_required(self.type, 'type')
        self.validate_required(self.interval, 'interval')
        if self.external_tags:
            for k in self.external_tags:
                if k:
                    k.validate()
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.target:
            self.target.validate()

    def to_map(self):
        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.interval is not None:
            result['interval'] = self.interval
        if self.timeout is not None:
            result['timeout'] = self.timeout
        result['external_tags'] = []
        if self.external_tags is not None:
            for k in self.external_tags:
                result['external_tags'].append(k.to_map() if k else None)
        result['rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['rules'].append(k.to_map() if k else None)
        result['metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['metrics'].append(k.to_map() if k else None)
        if self.port is not None:
            result['port'] = self.port
        if self.path is not None:
            result['path'] = self.path
        if self.scheme is not None:
            result['scheme'] = self.scheme
        if self.method is not None:
            result['method'] = self.method
        if self.ports is not None:
            result['ports'] = self.ports
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.expression is not None:
            result['expression'] = self.expression
        if self.target is not None:
            result['target'] = self.target.to_map()
        if self.local_host is not None:
            result['local_host'] = self.local_host
        if self.ca_file is not None:
            result['ca_file'] = self.ca_file
        if self.cert_file is not None:
            result['cert_file'] = self.cert_file
        if self.key_file is not None:
            result['key_file'] = self.key_file
        if self.bearer_token_file is not None:
            result['bearer_token_file'] = self.bearer_token_file
        if self.insecure_skip_verify is not None:
            result['insecure_skip_verify'] = self.insecure_skip_verify
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('interval') is not None:
            self.interval = m.get('interval')
        if m.get('timeout') is not None:
            self.timeout = m.get('timeout')
        self.external_tags = []
        if m.get('external_tags') is not None:
            for k in m.get('external_tags'):
                temp_model = XExpression()
                self.external_tags.append(temp_model.from_map(k))
        self.rules = []
        if m.get('rules') is not None:
            for k in m.get('rules'):
                temp_model = XLogSubRule()
                self.rules.append(temp_model.from_map(k))
        self.metrics = []
        if m.get('metrics') is not None:
            for k in m.get('metrics'):
                temp_model = XExpression()
                self.metrics.append(temp_model.from_map(k))
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('scheme') is not None:
            self.scheme = m.get('scheme')
        if m.get('method') is not None:
            self.method = m.get('method')
        if m.get('ports') is not None:
            self.ports = m.get('ports')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = XExpression()
                self.tags.append(temp_model.from_map(k))
        if m.get('expression') is not None:
            self.expression = m.get('expression')
        if m.get('target') is not None:
            temp_model = XMatchExpression()
            self.target = temp_model.from_map(m['target'])
        if m.get('local_host') is not None:
            self.local_host = m.get('local_host')
        if m.get('ca_file') is not None:
            self.ca_file = m.get('ca_file')
        if m.get('cert_file') is not None:
            self.cert_file = m.get('cert_file')
        if m.get('key_file') is not None:
            self.key_file = m.get('key_file')
        if m.get('bearer_token_file') is not None:
            self.bearer_token_file = m.get('bearer_token_file')
        if m.get('insecure_skip_verify') is not None:
            self.insecure_skip_verify = m.get('insecure_skip_verify')
        return self


class Model(TeaModel):
    def __init__(
        self,
        rules: List[Rule] = None,
        batch_rule_id: str = None,
    ):
        # rules
        self.rules = rules
        # batch_rule_id
        self.batch_rule_id = batch_rule_id

    def validate(self):
        self.validate_required(self.rules, 'rules')
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()
        self.validate_required(self.batch_rule_id, 'batch_rule_id')

    def to_map(self):
        result = dict()
        result['rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['rules'].append(k.to_map() if k else None)
        if self.batch_rule_id is not None:
            result['batch_rule_id'] = self.batch_rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.rules = []
        if m.get('rules') is not None:
            for k in m.get('rules'):
                temp_model = Rule()
                self.rules.append(temp_model.from_map(k))
        if m.get('batch_rule_id') is not None:
            self.batch_rule_id = m.get('batch_rule_id')
        return self


class Site(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        display_name: str = None,
        local: str = None,
        domain: str = None,
        token: str = None,
        config: str = None,
        url_preffix: str = None,
        readonly: str = None,
    ):
        # id
        self.id = id
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # local
        self.local = local
        # domain
        self.domain = domain
        # token
        self.token = token
        # config
        self.config = config
        # url_preffix
        self.url_preffix = url_preffix
        # readonly
        self.readonly = readonly

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.local, 'local')
        self.validate_required(self.domain, 'domain')
        self.validate_required(self.token, 'token')
        self.validate_required(self.config, 'config')
        self.validate_required(self.url_preffix, 'url_preffix')
        self.validate_required(self.readonly, 'readonly')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.local is not None:
            result['local'] = self.local
        if self.domain is not None:
            result['domain'] = self.domain
        if self.token is not None:
            result['token'] = self.token
        if self.config is not None:
            result['config'] = self.config
        if self.url_preffix is not None:
            result['url_preffix'] = self.url_preffix
        if self.readonly is not None:
            result['readonly'] = self.readonly
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('local') is not None:
            self.local = m.get('local')
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        if m.get('token') is not None:
            self.token = m.get('token')
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('url_preffix') is not None:
            self.url_preffix = m.get('url_preffix')
        if m.get('readonly') is not None:
            self.readonly = m.get('readonly')
        return self


class Translate(TeaModel):
    def __init__(
        self,
        default_value: str = None,
        mappings: List[TranslateMapping] = None,
    ):
        # 列值翻译的默认值
        self.default_value = default_value
        # 列值翻译映射关系
        self.mappings = mappings

    def validate(self):
        if self.mappings:
            for k in self.mappings:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.default_value is not None:
            result['default_value'] = self.default_value
        result['mappings'] = []
        if self.mappings is not None:
            for k in self.mappings:
                result['mappings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('default_value') is not None:
            self.default_value = m.get('default_value')
        self.mappings = []
        if m.get('mappings') is not None:
            for k in m.get('mappings'):
                temp_model = TranslateMapping()
                self.mappings.append(temp_model.from_map(k))
        return self


class XTarget(TeaModel):
    def __init__(
        self,
        type: str = None,
        metadata_kind: str = None,
        metadata_name: str = None,
        conditions: List[XCondition] = None,
        front_type: str = None,
        from_datasource_uuid: str = None,
        from_datasource_name: str = None,
        from_datasource_md_5: str = None,
        from_datasource_metric_name: str = None,
    ):
        # target type
        self.type = type
        # resource kind
        self.metadata_kind = metadata_kind
        # resource name
        self.metadata_name = metadata_name
        # where 条件
        self.conditions = conditions
        # 
        self.front_type = front_type
        # 
        self.from_datasource_uuid = from_datasource_uuid
        # 
        self.from_datasource_name = from_datasource_name
        # 
        self.from_datasource_md_5 = from_datasource_md_5
        # 
        self.from_datasource_metric_name = from_datasource_metric_name

    def validate(self):
        self.validate_required(self.type, 'type')
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.metadata_kind is not None:
            result['metadata_kind'] = self.metadata_kind
        if self.metadata_name is not None:
            result['metadata_name'] = self.metadata_name
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.front_type is not None:
            result['front_type'] = self.front_type
        if self.from_datasource_uuid is not None:
            result['from_datasource_uuid'] = self.from_datasource_uuid
        if self.from_datasource_name is not None:
            result['from_datasource_name'] = self.from_datasource_name
        if self.from_datasource_md_5 is not None:
            result['from_datasource_md5'] = self.from_datasource_md_5
        if self.from_datasource_metric_name is not None:
            result['from_datasource_metric_name'] = self.from_datasource_metric_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('metadata_kind') is not None:
            self.metadata_kind = m.get('metadata_kind')
        if m.get('metadata_name') is not None:
            self.metadata_name = m.get('metadata_name')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = XCondition()
                self.conditions.append(temp_model.from_map(k))
        if m.get('front_type') is not None:
            self.front_type = m.get('front_type')
        if m.get('from_datasource_uuid') is not None:
            self.from_datasource_uuid = m.get('from_datasource_uuid')
        if m.get('from_datasource_name') is not None:
            self.from_datasource_name = m.get('from_datasource_name')
        if m.get('from_datasource_md5') is not None:
            self.from_datasource_md_5 = m.get('from_datasource_md5')
        if m.get('from_datasource_metric_name') is not None:
            self.from_datasource_metric_name = m.get('from_datasource_metric_name')
        return self


class OpsFilter(TeaModel):
    def __init__(
        self,
        black: bool = None,
        names: List[str] = None,
    ):
        # black
        self.black = black
        # names
        self.names = names

    def validate(self):
        self.validate_required(self.black, 'black')
        self.validate_required(self.names, 'names')

    def to_map(self):
        result = dict()
        if self.black is not None:
            result['black'] = self.black
        if self.names is not None:
            result['names'] = self.names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('black') is not None:
            self.black = m.get('black')
        if m.get('names') is not None:
            self.names = m.get('names')
        return self


class MetricValue(TeaModel):
    def __init__(
        self,
        timestamp: int = None,
        value: str = None,
    ):
        # 时间戳
        self.timestamp = timestamp
        # double类型值
        self.value = value

    def validate(self):
        self.validate_required(self.timestamp, 'timestamp')
        self.validate_required(self.value, 'value')

    def to_map(self):
        result = dict()
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class XSpec(TeaModel):
    def __init__(
        self,
        target: XTarget = None,
        rule: XRule = None,
    ):
        # 
        self.target = target
        # 
        self.rule = rule

    def validate(self):
        self.validate_required(self.target, 'target')
        if self.target:
            self.target.validate()
        self.validate_required(self.rule, 'rule')
        if self.rule:
            self.rule.validate()

    def to_map(self):
        result = dict()
        if self.target is not None:
            result['target'] = self.target.to_map()
        if self.rule is not None:
            result['rule'] = self.rule.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('target') is not None:
            temp_model = XTarget()
            self.target = temp_model.from_map(m['target'])
        if m.get('rule') is not None:
            temp_model = XRule()
            self.rule = temp_model.from_map(m['rule'])
        return self


class NavSite(TeaModel):
    def __init__(
        self,
        site: Site = None,
        nav_tenants: List[NavTenant] = None,
    ):
        # site
        self.site = site
        # nav_tenants
        self.nav_tenants = nav_tenants

    def validate(self):
        self.validate_required(self.site, 'site')
        if self.site:
            self.site.validate()
        self.validate_required(self.nav_tenants, 'nav_tenants')
        if self.nav_tenants:
            for k in self.nav_tenants:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.site is not None:
            result['site'] = self.site.to_map()
        result['nav_tenants'] = []
        if self.nav_tenants is not None:
            for k in self.nav_tenants:
                result['nav_tenants'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('site') is not None:
            temp_model = Site()
            self.site = temp_model.from_map(m['site'])
        self.nav_tenants = []
        if m.get('nav_tenants') is not None:
            for k in m.get('nav_tenants'):
                temp_model = NavTenant()
                self.nav_tenants.append(temp_model.from_map(k))
        return self


class AlarmHistoryStatsDTO(TeaModel):
    def __init__(
        self,
        alarm_time: int = None,
        alarm_level: int = None,
        count: int = None,
    ):
        # alarm_time
        self.alarm_time = alarm_time
        # alarm_level
        self.alarm_level = alarm_level
        # count
        self.count = count

    def validate(self):
        self.validate_required(self.alarm_time, 'alarm_time')
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.count, 'count')

    def to_map(self):
        result = dict()
        if self.alarm_time is not None:
            result['alarm_time'] = self.alarm_time
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.count is not None:
            result['count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alarm_time') is not None:
            self.alarm_time = m.get('alarm_time')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('count') is not None:
            self.count = m.get('count')
        return self


class TimeSeriesMetricsField(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # Field key
        self.key = key
        # Field value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class XTimeStringValue(TeaModel):
    def __init__(
        self,
        timestamp: int = None,
        value: str = None,
    ):
        # unix timestamp (s)
        self.timestamp = timestamp
        # double string
        self.value = value

    def validate(self):
        self.validate_required(self.timestamp, 'timestamp')
        self.validate_required(self.value, 'value')

    def to_map(self):
        result = dict()
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class UniqueDim(TeaModel):
    def __init__(
        self,
        name: str = None,
        left_index: int = None,
        left: str = None,
        right: str = None,
        translate: Translate = None,
    ):
        # 列名称
        self.name = name
        # 左起第几个
        self.left_index = left_index
        # 左起字符串
        self.left = left
        # 右至字符串
        self.right = right
        # 列值翻译
        self.translate = translate

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.left_index, 'left_index')
        if self.translate:
            self.translate.validate()

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.left_index is not None:
            result['left_index'] = self.left_index
        if self.left is not None:
            result['left'] = self.left
        if self.right is not None:
            result['right'] = self.right
        if self.translate is not None:
            result['translate'] = self.translate.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('left_index') is not None:
            self.left_index = m.get('left_index')
        if m.get('left') is not None:
            self.left = m.get('left')
        if m.get('right') is not None:
            self.right = m.get('right')
        if m.get('translate') is not None:
            temp_model = Translate()
            self.translate = temp_model.from_map(m['translate'])
        return self


class XResource(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        description: str = None,
        parent_uuid: str = None,
        scope: str = None,
        enabled: bool = None,
        open: bool = None,
        version: int = None,
        tenant_id: int = None,
        workspace_id: int = None,
        created_by: str = None,
        created_at: int = None,
        updated_by: str = None,
        updated_at: int = None,
        type: str = None,
        md_5: str = None,
        priority: str = None,
        time_to_live: str = None,
    ):
        # 全球唯一标识符（32位）。
        # Update操作，必填
        # Create操作，非必填，默认不传，后端会自动生成。特殊情况可以传入，比如一些领域需要固定该UUID。
        self.uuid = uuid
        # 名称。命名规则：^[a-zA-Z\u4E00-\u9FA5][a-zA-Z0-9_-\u4E00-\u9FA5]*$$
        self.name = name
        # 描述。
        # 
        self.description = description
        # 父目录UUID。全球唯一标识符（32位）。
        # 00000000000000000000000000000000特指根目录UUID
        self.parent_uuid = parent_uuid
        # 作用范围
        self.scope = scope
        # 是否生效。默认true
        self.enabled = enabled
        # 是否开放。默认为false
        self.open = open
        # 资源版本
        self.version = version
        # inner tenant id
        self.tenant_id = tenant_id
        # inner workspace id
        self.workspace_id = workspace_id
        # 创建者
        self.created_by = created_by
        # unix time 秒
        self.created_at = created_at
        # 更新者
        self.updated_by = updated_by
        # 更新时间
        self.updated_at = updated_at
        # 资源类型
        self.type = type
        # 
        self.md_5 = md_5
        # 
        self.priority = priority
        # 
        self.time_to_live = time_to_live

    def validate(self):
        if self.uuid is not None:
            self.validate_max_length(self.uuid, 'uuid', 32)
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 64)
        self.validate_required(self.description, 'description')
        if self.description is not None:
            self.validate_max_length(self.description, 'description', 512)
        self.validate_required(self.parent_uuid, 'parent_uuid')
        if self.parent_uuid is not None:
            self.validate_max_length(self.parent_uuid, 'parent_uuid', 32)
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.type, 'type')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.description is not None:
            result['description'] = self.description
        if self.parent_uuid is not None:
            result['parent_uuid'] = self.parent_uuid
        if self.scope is not None:
            result['scope'] = self.scope
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.open is not None:
            result['open'] = self.open
        if self.version is not None:
            result['version'] = self.version
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.created_by is not None:
            result['created_by'] = self.created_by
        if self.created_at is not None:
            result['created_at'] = self.created_at
        if self.updated_by is not None:
            result['updated_by'] = self.updated_by
        if self.updated_at is not None:
            result['updated_at'] = self.updated_at
        if self.type is not None:
            result['type'] = self.type
        if self.md_5 is not None:
            result['md5'] = self.md_5
        if self.priority is not None:
            result['priority'] = self.priority
        if self.time_to_live is not None:
            result['time_to_live'] = self.time_to_live
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('parent_uuid') is not None:
            self.parent_uuid = m.get('parent_uuid')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('open') is not None:
            self.open = m.get('open')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('created_by') is not None:
            self.created_by = m.get('created_by')
        if m.get('created_at') is not None:
            self.created_at = m.get('created_at')
        if m.get('updated_by') is not None:
            self.updated_by = m.get('updated_by')
        if m.get('updated_at') is not None:
            self.updated_at = m.get('updated_at')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('md5') is not None:
            self.md_5 = m.get('md5')
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('time_to_live') is not None:
            self.time_to_live = m.get('time_to_live')
        return self


class ContainVals(TeaModel):
    def __init__(
        self,
        vals: List[str] = None,
    ):
        # 包含值列表
        self.vals = vals

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.vals is not None:
            result['vals'] = self.vals
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('vals') is not None:
            self.vals = m.get('vals')
        return self


class StackState(TeaModel):
    def __init__(
        self,
        state: str = None,
        values: List[str] = None,
        is_black: bool = None,
    ):
        # state
        self.state = state
        # values
        self.values = values
        # is_black
        self.is_black = is_black

    def validate(self):
        self.validate_required(self.state, 'state')
        self.validate_required(self.values, 'values')
        self.validate_required(self.is_black, 'is_black')

    def to_map(self):
        result = dict()
        if self.state is not None:
            result['state'] = self.state
        if self.values is not None:
            result['values'] = self.values
        if self.is_black is not None:
            result['is_black'] = self.is_black
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('values') is not None:
            self.values = m.get('values')
        if m.get('is_black') is not None:
            self.is_black = m.get('is_black')
        return self


class KeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class UserGroupRelation(TeaModel):
    def __init__(
        self,
        id: int = None,
        user_group_id: int = None,
        dingtalk_webhook: str = None,
        user_login_name: str = None,
        user_display_name: str = None,
        ding_ding_robot: str = None,
    ):
        # ID
        self.id = id
        # 用户组 ID
        self.user_group_id = user_group_id
        # 钉钉机器人webhook
        self.dingtalk_webhook = dingtalk_webhook
        # 联系人登录名
        self.user_login_name = user_login_name
        # 用户展示名
        self.user_display_name = user_display_name
        # 钉钉机器人
        self.ding_ding_robot = ding_ding_robot

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.user_group_id, 'user_group_id')
        self.validate_required(self.dingtalk_webhook, 'dingtalk_webhook')
        self.validate_required(self.user_login_name, 'user_login_name')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.user_group_id is not None:
            result['user_group_id'] = self.user_group_id
        if self.dingtalk_webhook is not None:
            result['dingtalk_webhook'] = self.dingtalk_webhook
        if self.user_login_name is not None:
            result['user_login_name'] = self.user_login_name
        if self.user_display_name is not None:
            result['user_display_name'] = self.user_display_name
        if self.ding_ding_robot is not None:
            result['ding_ding_robot'] = self.ding_ding_robot
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('user_group_id') is not None:
            self.user_group_id = m.get('user_group_id')
        if m.get('dingtalk_webhook') is not None:
            self.dingtalk_webhook = m.get('dingtalk_webhook')
        if m.get('user_login_name') is not None:
            self.user_login_name = m.get('user_login_name')
        if m.get('user_display_name') is not None:
            self.user_display_name = m.get('user_display_name')
        if m.get('ding_ding_robot') is not None:
            self.ding_ding_robot = m.get('ding_ding_robot')
        return self


class TopAlarmDO(TeaModel):
    def __init__(
        self,
        error: str = None,
        error_count: int = None,
        warn: str = None,
        warn_count: int = None,
        alarm_level: int = None,
        max_alarm_count: int = None,
        emergency_copy: str = None,
        emergency_url: str = None,
    ):
        # error
        self.error = error
        # error_count
        self.error_count = error_count
        # warn
        self.warn = warn
        # warn_count
        self.warn_count = warn_count
        # alarm_level
        self.alarm_level = alarm_level
        # max_alarm_count
        self.max_alarm_count = max_alarm_count
        # emergency_copy
        self.emergency_copy = emergency_copy
        # emergency_url
        self.emergency_url = emergency_url

    def validate(self):
        self.validate_required(self.error, 'error')
        self.validate_required(self.error_count, 'error_count')
        self.validate_required(self.warn, 'warn')
        self.validate_required(self.warn_count, 'warn_count')
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.max_alarm_count, 'max_alarm_count')
        self.validate_required(self.emergency_copy, 'emergency_copy')
        self.validate_required(self.emergency_url, 'emergency_url')

    def to_map(self):
        result = dict()
        if self.error is not None:
            result['error'] = self.error
        if self.error_count is not None:
            result['error_count'] = self.error_count
        if self.warn is not None:
            result['warn'] = self.warn
        if self.warn_count is not None:
            result['warn_count'] = self.warn_count
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.max_alarm_count is not None:
            result['max_alarm_count'] = self.max_alarm_count
        if self.emergency_copy is not None:
            result['emergency_copy'] = self.emergency_copy
        if self.emergency_url is not None:
            result['emergency_url'] = self.emergency_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('error') is not None:
            self.error = m.get('error')
        if m.get('error_count') is not None:
            self.error_count = m.get('error_count')
        if m.get('warn') is not None:
            self.warn = m.get('warn')
        if m.get('warn_count') is not None:
            self.warn_count = m.get('warn_count')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('max_alarm_count') is not None:
            self.max_alarm_count = m.get('max_alarm_count')
        if m.get('emergency_copy') is not None:
            self.emergency_copy = m.get('emergency_copy')
        if m.get('emergency_url') is not None:
            self.emergency_url = m.get('emergency_url')
        return self


class AlarmDO(TeaModel):
    def __init__(
        self,
        model: Model = None,
        level: str = None,
        frequency: int = None,
        silent_minute: str = None,
        emergency_copy: str = None,
        emergency_url: str = None,
        time_zone: str = None,
        time_zone_custom: bool = None,
    ):
        # model
        self.model = model
        # level
        self.level = level
        # frequency
        self.frequency = frequency
        # silent_minute
        self.silent_minute = silent_minute
        # emergency_copy
        self.emergency_copy = emergency_copy
        # emergency_url
        self.emergency_url = emergency_url
        # time_zone
        self.time_zone = time_zone
        # time_zone_custom
        self.time_zone_custom = time_zone_custom

    def validate(self):
        self.validate_required(self.model, 'model')
        if self.model:
            self.model.validate()
        self.validate_required(self.level, 'level')
        self.validate_required(self.frequency, 'frequency')
        self.validate_required(self.silent_minute, 'silent_minute')
        self.validate_required(self.emergency_copy, 'emergency_copy')
        self.validate_required(self.emergency_url, 'emergency_url')
        self.validate_required(self.time_zone, 'time_zone')
        self.validate_required(self.time_zone_custom, 'time_zone_custom')

    def to_map(self):
        result = dict()
        if self.model is not None:
            result['model'] = self.model.to_map()
        if self.level is not None:
            result['level'] = self.level
        if self.frequency is not None:
            result['frequency'] = self.frequency
        if self.silent_minute is not None:
            result['silent_minute'] = self.silent_minute
        if self.emergency_copy is not None:
            result['emergency_copy'] = self.emergency_copy
        if self.emergency_url is not None:
            result['emergency_url'] = self.emergency_url
        if self.time_zone is not None:
            result['time_zone'] = self.time_zone
        if self.time_zone_custom is not None:
            result['time_zone_custom'] = self.time_zone_custom
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('model') is not None:
            temp_model = Model()
            self.model = temp_model.from_map(m['model'])
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('frequency') is not None:
            self.frequency = m.get('frequency')
        if m.get('silent_minute') is not None:
            self.silent_minute = m.get('silent_minute')
        if m.get('emergency_copy') is not None:
            self.emergency_copy = m.get('emergency_copy')
        if m.get('emergency_url') is not None:
            self.emergency_url = m.get('emergency_url')
        if m.get('time_zone') is not None:
            self.time_zone = m.get('time_zone')
        if m.get('time_zone_custom') is not None:
            self.time_zone_custom = m.get('time_zone_custom')
        return self


class AlarmHistory(TeaModel):
    def __init__(
        self,
        alarm_level: int = None,
        alarm_pkg_id: int = None,
        alarm_rule_name: str = None,
        alarm_source_type: str = None,
        alarm_time: int = None,
        biz_domain_id: int = None,
        context: str = None,
        custom_plugin_id: int = None,
        id: int = None,
        meta_group_id: int = None,
        msg: str = None,
        stack_entity_id: int = None,
        stack_id: int = None,
        stack_monitor_item_name: str = None,
        stack_universal_table_id: str = None,
        tag_value_id: int = None,
        tenant_id: int = None,
        workspace_id: int = None,
    ):
        # alarm_level
        self.alarm_level = alarm_level
        # alarmPkgId
        self.alarm_pkg_id = alarm_pkg_id
        # alarm_rule_name
        self.alarm_rule_name = alarm_rule_name
        # alarmSourceType
        self.alarm_source_type = alarm_source_type
        # alarm_time
        self.alarm_time = alarm_time
        # biz_domain_id
        self.biz_domain_id = biz_domain_id
        # context
        self.context = context
        # custom_plugin_id
        self.custom_plugin_id = custom_plugin_id
        # id
        self.id = id
        # meta_group_id
        self.meta_group_id = meta_group_id
        # msg
        self.msg = msg
        # stack_entity_id
        self.stack_entity_id = stack_entity_id
        # stack_id
        self.stack_id = stack_id
        # stack_monitor_item_name
        self.stack_monitor_item_name = stack_monitor_item_name
        # stack_universal_table_id
        self.stack_universal_table_id = stack_universal_table_id
        # tag_value_id
        self.tag_value_id = tag_value_id
        # tenant_id
        self.tenant_id = tenant_id
        # workspace_id
        self.workspace_id = workspace_id

    def validate(self):
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.alarm_pkg_id, 'alarm_pkg_id')
        self.validate_required(self.alarm_rule_name, 'alarm_rule_name')
        self.validate_required(self.alarm_source_type, 'alarm_source_type')
        self.validate_required(self.alarm_time, 'alarm_time')
        self.validate_required(self.biz_domain_id, 'biz_domain_id')
        self.validate_required(self.context, 'context')
        self.validate_required(self.custom_plugin_id, 'custom_plugin_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.meta_group_id, 'meta_group_id')
        self.validate_required(self.msg, 'msg')
        self.validate_required(self.stack_entity_id, 'stack_entity_id')
        self.validate_required(self.stack_id, 'stack_id')
        self.validate_required(self.stack_monitor_item_name, 'stack_monitor_item_name')
        self.validate_required(self.stack_universal_table_id, 'stack_universal_table_id')
        self.validate_required(self.tag_value_id, 'tag_value_id')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')

    def to_map(self):
        result = dict()
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.alarm_pkg_id is not None:
            result['alarm_pkg_id'] = self.alarm_pkg_id
        if self.alarm_rule_name is not None:
            result['alarm_rule_name'] = self.alarm_rule_name
        if self.alarm_source_type is not None:
            result['alarm_source_type'] = self.alarm_source_type
        if self.alarm_time is not None:
            result['alarm_time'] = self.alarm_time
        if self.biz_domain_id is not None:
            result['biz_domain_id'] = self.biz_domain_id
        if self.context is not None:
            result['context'] = self.context
        if self.custom_plugin_id is not None:
            result['custom_plugin_id'] = self.custom_plugin_id
        if self.id is not None:
            result['id'] = self.id
        if self.meta_group_id is not None:
            result['meta_group_id'] = self.meta_group_id
        if self.msg is not None:
            result['msg'] = self.msg
        if self.stack_entity_id is not None:
            result['stack_entity_id'] = self.stack_entity_id
        if self.stack_id is not None:
            result['stack_id'] = self.stack_id
        if self.stack_monitor_item_name is not None:
            result['stack_monitor_item_name'] = self.stack_monitor_item_name
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        if self.tag_value_id is not None:
            result['tag_value_id'] = self.tag_value_id
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('alarm_pkg_id') is not None:
            self.alarm_pkg_id = m.get('alarm_pkg_id')
        if m.get('alarm_rule_name') is not None:
            self.alarm_rule_name = m.get('alarm_rule_name')
        if m.get('alarm_source_type') is not None:
            self.alarm_source_type = m.get('alarm_source_type')
        if m.get('alarm_time') is not None:
            self.alarm_time = m.get('alarm_time')
        if m.get('biz_domain_id') is not None:
            self.biz_domain_id = m.get('biz_domain_id')
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('custom_plugin_id') is not None:
            self.custom_plugin_id = m.get('custom_plugin_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('meta_group_id') is not None:
            self.meta_group_id = m.get('meta_group_id')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        if m.get('stack_entity_id') is not None:
            self.stack_entity_id = m.get('stack_entity_id')
        if m.get('stack_id') is not None:
            self.stack_id = m.get('stack_id')
        if m.get('stack_monitor_item_name') is not None:
            self.stack_monitor_item_name = m.get('stack_monitor_item_name')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        if m.get('tag_value_id') is not None:
            self.tag_value_id = m.get('tag_value_id')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        return self


class XTimeMetricsValue(TeaModel):
    def __init__(
        self,
        values: List[XStringKeyValue] = None,
        timestamp: int = None,
    ):
        # 
        self.values = values
        # 
        self.timestamp = timestamp

    def validate(self):
        self.validate_required(self.values, 'values')
        if self.values:
            for k in self.values:
                if k:
                    k.validate()
        self.validate_required(self.timestamp, 'timestamp')

    def to_map(self):
        result = dict()
        result['values'] = []
        if self.values is not None:
            for k in self.values:
                result['values'].append(k.to_map() if k else None)
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.values = []
        if m.get('values') is not None:
            for k in m.get('values'):
                temp_model = XStringKeyValue()
                self.values.append(temp_model.from_map(k))
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        return self


class NavContent(TeaModel):
    def __init__(
        self,
        hasw: bool = None,
        hast: bool = None,
        hasbiz: bool = None,
        nav_sites: List[NavSite] = None,
    ):
        # hasw
        self.hasw = hasw
        # hast
        self.hast = hast
        # hasbiz
        self.hasbiz = hasbiz
        # nav_sites
        self.nav_sites = nav_sites

    def validate(self):
        self.validate_required(self.hasw, 'hasw')
        self.validate_required(self.hast, 'hast')
        self.validate_required(self.hasbiz, 'hasbiz')
        self.validate_required(self.nav_sites, 'nav_sites')
        if self.nav_sites:
            for k in self.nav_sites:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.hasw is not None:
            result['hasw'] = self.hasw
        if self.hast is not None:
            result['hast'] = self.hast
        if self.hasbiz is not None:
            result['hasbiz'] = self.hasbiz
        result['nav_sites'] = []
        if self.nav_sites is not None:
            for k in self.nav_sites:
                result['nav_sites'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hasw') is not None:
            self.hasw = m.get('hasw')
        if m.get('hast') is not None:
            self.hast = m.get('hast')
        if m.get('hasbiz') is not None:
            self.hasbiz = m.get('hasbiz')
        self.nav_sites = []
        if m.get('nav_sites') is not None:
            for k in m.get('nav_sites'):
                temp_model = NavSite()
                self.nav_sites.append(temp_model.from_map(k))
        return self


class MetricData(TeaModel):
    def __init__(
        self,
        tags: List[KeySet] = None,
        values: List[MetricValue] = None,
    ):
        # 维度信息
        self.tags = tags
        # 时序数据
        self.values = values

    def validate(self):
        self.validate_required(self.tags, 'tags')
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        self.validate_required(self.values, 'values')
        if self.values:
            for k in self.values:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        result['values'] = []
        if self.values is not None:
            for k in self.values:
                result['values'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeySet()
                self.tags.append(temp_model.from_map(k))
        self.values = []
        if m.get('values') is not None:
            for k in m.get('values'):
                temp_model = MetricValue()
                self.values.append(temp_model.from_map(k))
        return self


class Filter(TeaModel):
    def __init__(
        self,
        dim: UniqueDim = None,
        values: List[str] = None,
    ):
        # 过滤列
        self.dim = dim
        # 过滤目标值列表
        self.values = values

    def validate(self):
        self.validate_required(self.dim, 'dim')
        if self.dim:
            self.dim.validate()
        self.validate_required(self.values, 'values')

    def to_map(self):
        result = dict()
        if self.dim is not None:
            result['dim'] = self.dim.to_map()
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dim') is not None:
            temp_model = UniqueDim()
            self.dim = temp_model.from_map(m['dim'])
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class XMetricData(TeaModel):
    def __init__(
        self,
        metric: List[XStringKeyValue] = None,
        value: XTimeStringValue = None,
        values: List[XTimeStringValue] = None,
    ):
        # key value
        self.metric = metric
        # time value
        self.value = value
        # 
        self.values = values

    def validate(self):
        self.validate_required(self.metric, 'metric')
        if self.metric:
            for k in self.metric:
                if k:
                    k.validate()
        if self.value:
            self.value.validate()
        if self.values:
            for k in self.values:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        result['metric'] = []
        if self.metric is not None:
            for k in self.metric:
                result['metric'].append(k.to_map() if k else None)
        if self.value is not None:
            result['value'] = self.value.to_map()
        result['values'] = []
        if self.values is not None:
            for k in self.values:
                result['values'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.metric = []
        if m.get('metric') is not None:
            for k in m.get('metric'):
                temp_model = XStringKeyValue()
                self.metric.append(temp_model.from_map(k))
        if m.get('value') is not None:
            temp_model = XTimeStringValue()
            self.value = temp_model.from_map(m['value'])
        self.values = []
        if m.get('values') is not None:
            for k in m.get('values'):
                temp_model = XTimeStringValue()
                self.values.append(temp_model.from_map(k))
        return self


class Condition(TeaModel):
    def __init__(
        self,
        plugin: str = None,
        content_type: str = None,
        tag: str = None,
        ds_id: str = None,
        new_cp_id: str = None,
        start: int = None,
        end: int = None,
        tick_interval: int = None,
        use_new: bool = None,
        groupby: List[str] = None,
        values: List[KeySet] = None,
        tenant_id: int = None,
        workspace_id: int = None,
        am_old_data_struct: bool = None,
        am_is_spm: bool = None,
        old_ds_id: str = None,
    ):
        # plugin
        self.plugin = plugin
        # content_type
        self.content_type = content_type
        # tag
        self.tag = tag
        # ds_id
        self.ds_id = ds_id
        # new_cp_id
        self.new_cp_id = new_cp_id
        # start
        self.start = start
        # end
        self.end = end
        # tick_interval
        self.tick_interval = tick_interval
        # use_new
        self.use_new = use_new
        # groupby
        self.groupby = groupby
        # values
        self.values = values
        # tenant_id
        self.tenant_id = tenant_id
        # workspace_id
        self.workspace_id = workspace_id
        # am_old_data_struct
        self.am_old_data_struct = am_old_data_struct
        # am_is_spm
        self.am_is_spm = am_is_spm
        # old_ds_id
        self.old_ds_id = old_ds_id

    def validate(self):
        self.validate_required(self.plugin, 'plugin')
        self.validate_required(self.content_type, 'content_type')
        self.validate_required(self.tag, 'tag')
        self.validate_required(self.ds_id, 'ds_id')
        self.validate_required(self.new_cp_id, 'new_cp_id')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        self.validate_required(self.tick_interval, 'tick_interval')
        self.validate_required(self.use_new, 'use_new')
        self.validate_required(self.groupby, 'groupby')
        self.validate_required(self.values, 'values')
        if self.values:
            for k in self.values:
                if k:
                    k.validate()
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.am_old_data_struct, 'am_old_data_struct')
        self.validate_required(self.am_is_spm, 'am_is_spm')
        self.validate_required(self.old_ds_id, 'old_ds_id')

    def to_map(self):
        result = dict()
        if self.plugin is not None:
            result['plugin'] = self.plugin
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.tag is not None:
            result['tag'] = self.tag
        if self.ds_id is not None:
            result['ds_id'] = self.ds_id
        if self.new_cp_id is not None:
            result['new_cp_id'] = self.new_cp_id
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.tick_interval is not None:
            result['tick_interval'] = self.tick_interval
        if self.use_new is not None:
            result['use_new'] = self.use_new
        if self.groupby is not None:
            result['groupby'] = self.groupby
        result['values'] = []
        if self.values is not None:
            for k in self.values:
                result['values'].append(k.to_map() if k else None)
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.am_old_data_struct is not None:
            result['am_old_data_struct'] = self.am_old_data_struct
        if self.am_is_spm is not None:
            result['am_is_spm'] = self.am_is_spm
        if self.old_ds_id is not None:
            result['old_ds_id'] = self.old_ds_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('plugin') is not None:
            self.plugin = m.get('plugin')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('tag') is not None:
            self.tag = m.get('tag')
        if m.get('ds_id') is not None:
            self.ds_id = m.get('ds_id')
        if m.get('new_cp_id') is not None:
            self.new_cp_id = m.get('new_cp_id')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('tick_interval') is not None:
            self.tick_interval = m.get('tick_interval')
        if m.get('use_new') is not None:
            self.use_new = m.get('use_new')
        if m.get('groupby') is not None:
            self.groupby = m.get('groupby')
        self.values = []
        if m.get('values') is not None:
            for k in m.get('values'):
                temp_model = KeySet()
                self.values.append(temp_model.from_map(k))
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('am_old_data_struct') is not None:
            self.am_old_data_struct = m.get('am_old_data_struct')
        if m.get('am_is_spm') is not None:
            self.am_is_spm = m.get('am_is_spm')
        if m.get('old_ds_id') is not None:
            self.old_ds_id = m.get('old_ds_id')
        return self


class NodeTopItem(TeaModel):
    def __init__(
        self,
        node: str = None,
        value: str = None,
    ):
        # 主机名称
        self.node = node
        # 应用TopN统计值，有可能有小数，使用前转换为数值
        self.value = value

    def validate(self):
        self.validate_required(self.node, 'node')
        self.validate_required(self.value, 'value')

    def to_map(self):
        result = dict()
        if self.node is not None:
            result['node'] = self.node
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('node') is not None:
            self.node = m.get('node')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class TraasAppGroupDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        parent_uuid: str = None,
        layer: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        outside_id: str = None,
        outside_parent_id: str = None,
        source_from: str = None,
        extension: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # parent_uuid
        self.parent_uuid = parent_uuid
        # layer
        self.layer = layer
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # outside_id
        self.outside_id = outside_id
        # outside_parent_id
        self.outside_parent_id = outside_parent_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.parent_uuid is not None:
            result['parent_uuid'] = self.parent_uuid
        if self.layer is not None:
            result['layer'] = self.layer
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.outside_parent_id is not None:
            result['outside_parent_id'] = self.outside_parent_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('parent_uuid') is not None:
            self.parent_uuid = m.get('parent_uuid')
        if m.get('layer') is not None:
            self.layer = m.get('layer')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('outside_parent_id') is not None:
            self.outside_parent_id = m.get('outside_parent_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class AlarmHistoryStatsDTOsKeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: List[AlarmHistoryStatsDTO] = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        result['value'] = []
        if self.value is not None:
            for k in self.value:
                result['value'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        self.value = []
        if m.get('value') is not None:
            for k in m.get('value'):
                temp_model = AlarmHistoryStatsDTO()
                self.value.append(temp_model.from_map(k))
        return self


class AlarmHistoryListKeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: List[AlarmHistory] = None,
    ):
        # key
        self.key = key
        # AlarmHistoryListKeySet
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        result['value'] = []
        if self.value is not None:
            for k in self.value:
                result['value'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        self.value = []
        if m.get('value') is not None:
            for k in m.get('value'):
                temp_model = AlarmHistory()
                self.value.append(temp_model.from_map(k))
        return self


class PontusTrendRequest(TeaModel):
    def __init__(
        self,
        token: str = None,
        metric_table: str = None,
        site_env: str = None,
        view_id: str = None,
        period_type: str = None,
        extra_dim_names: List[str] = None,
        metric_filter: str = None,
        start: int = None,
        end: int = None,
        dim_conditions_list: List[KeySet] = None,
        dim_expression: KeySet = None,
        dim_expression_list: List[KeySet] = None,
    ):
        # token
        self.token = token
        # metric_table
        self.metric_table = metric_table
        # site_env
        self.site_env = site_env
        # view_id
        self.view_id = view_id
        # period_type
        self.period_type = period_type
        # extraDimNames
        self.extra_dim_names = extra_dim_names
        # metric_filter
        self.metric_filter = metric_filter
        # start
        self.start = start
        # end
        self.end = end
        # dim_conditions_list
        self.dim_conditions_list = dim_conditions_list
        # dim_expression
        self.dim_expression = dim_expression
        # dim_expression_list
        self.dim_expression_list = dim_expression_list

    def validate(self):
        self.validate_required(self.token, 'token')
        self.validate_required(self.metric_table, 'metric_table')
        self.validate_required(self.site_env, 'site_env')
        self.validate_required(self.view_id, 'view_id')
        self.validate_required(self.period_type, 'period_type')
        self.validate_required(self.extra_dim_names, 'extra_dim_names')
        self.validate_required(self.metric_filter, 'metric_filter')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        self.validate_required(self.dim_conditions_list, 'dim_conditions_list')
        if self.dim_conditions_list:
            for k in self.dim_conditions_list:
                if k:
                    k.validate()
        self.validate_required(self.dim_expression, 'dim_expression')
        if self.dim_expression:
            self.dim_expression.validate()
        self.validate_required(self.dim_expression_list, 'dim_expression_list')
        if self.dim_expression_list:
            for k in self.dim_expression_list:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.token is not None:
            result['token'] = self.token
        if self.metric_table is not None:
            result['metric_table'] = self.metric_table
        if self.site_env is not None:
            result['site_env'] = self.site_env
        if self.view_id is not None:
            result['view_id'] = self.view_id
        if self.period_type is not None:
            result['period_type'] = self.period_type
        if self.extra_dim_names is not None:
            result['extra_dim_names'] = self.extra_dim_names
        if self.metric_filter is not None:
            result['metric_filter'] = self.metric_filter
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        result['dim_conditions_list'] = []
        if self.dim_conditions_list is not None:
            for k in self.dim_conditions_list:
                result['dim_conditions_list'].append(k.to_map() if k else None)
        if self.dim_expression is not None:
            result['dim_expression'] = self.dim_expression.to_map()
        result['dim_expression_list'] = []
        if self.dim_expression_list is not None:
            for k in self.dim_expression_list:
                result['dim_expression_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('token') is not None:
            self.token = m.get('token')
        if m.get('metric_table') is not None:
            self.metric_table = m.get('metric_table')
        if m.get('site_env') is not None:
            self.site_env = m.get('site_env')
        if m.get('view_id') is not None:
            self.view_id = m.get('view_id')
        if m.get('period_type') is not None:
            self.period_type = m.get('period_type')
        if m.get('extra_dim_names') is not None:
            self.extra_dim_names = m.get('extra_dim_names')
        if m.get('metric_filter') is not None:
            self.metric_filter = m.get('metric_filter')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        self.dim_conditions_list = []
        if m.get('dim_conditions_list') is not None:
            for k in m.get('dim_conditions_list'):
                temp_model = KeySet()
                self.dim_conditions_list.append(temp_model.from_map(k))
        if m.get('dim_expression') is not None:
            temp_model = KeySet()
            self.dim_expression = temp_model.from_map(m['dim_expression'])
        self.dim_expression_list = []
        if m.get('dim_expression_list') is not None:
            for k in m.get('dim_expression_list'):
                temp_model = KeySet()
                self.dim_expression_list.append(temp_model.from_map(k))
        return self


class MonitorUser(TeaModel):
    def __init__(
        self,
        identity_type: str = None,
        super_viewer: bool = None,
        super_admin: bool = None,
        nick_name: str = None,
        emp_id: str = None,
        id: int = None,
        login_name: str = None,
        display_name: str = None,
        user_display_name: str = None,
        real_name: str = None,
        phone_num: str = None,
        email: str = None,
        enterprise_id: str = None,
        token: str = None,
        is_from_aliyun: bool = None,
    ):
        # 用户来源
        self.identity_type = identity_type
        # 用户上的权限
        self.super_viewer = super_viewer
        # 是否为超级管理员
        self.super_admin = super_admin
        # 显示名，花名
        self.nick_name = nick_name
        # emp_id
        self.emp_id = emp_id
        # id
        self.id = id
        # 登录名，等于_id, _id实在太难辨别了，域帐号  yerui.yr
        self.login_name = login_name
        # 展示名称
        self.display_name = display_name
        # 兼容UniversalRead里返回的userDisplayName
        self.user_display_name = user_display_name
        # 真名
        self.real_name = real_name
        # phone_num
        self.phone_num = phone_num
        # email
        self.email = email
        # enterprise_id（金融云专属）
        self.enterprise_id = enterprise_id
        # token
        self.token = token
        # 一方化标记位
        self.is_from_aliyun = is_from_aliyun

    def validate(self):
        self.validate_required(self.identity_type, 'identity_type')
        self.validate_required(self.super_viewer, 'super_viewer')
        self.validate_required(self.super_admin, 'super_admin')
        self.validate_required(self.nick_name, 'nick_name')
        self.validate_required(self.emp_id, 'emp_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.login_name, 'login_name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.user_display_name, 'user_display_name')
        self.validate_required(self.real_name, 'real_name')
        self.validate_required(self.phone_num, 'phone_num')
        self.validate_required(self.email, 'email')
        self.validate_required(self.enterprise_id, 'enterprise_id')
        self.validate_required(self.token, 'token')
        self.validate_required(self.is_from_aliyun, 'is_from_aliyun')

    def to_map(self):
        result = dict()
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        if self.super_viewer is not None:
            result['super_viewer'] = self.super_viewer
        if self.super_admin is not None:
            result['super_admin'] = self.super_admin
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.emp_id is not None:
            result['emp_id'] = self.emp_id
        if self.id is not None:
            result['id'] = self.id
        if self.login_name is not None:
            result['login_name'] = self.login_name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.user_display_name is not None:
            result['user_display_name'] = self.user_display_name
        if self.real_name is not None:
            result['real_name'] = self.real_name
        if self.phone_num is not None:
            result['phone_num'] = self.phone_num
        if self.email is not None:
            result['email'] = self.email
        if self.enterprise_id is not None:
            result['enterprise_id'] = self.enterprise_id
        if self.token is not None:
            result['token'] = self.token
        if self.is_from_aliyun is not None:
            result['is_from_aliyun'] = self.is_from_aliyun
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        if m.get('super_viewer') is not None:
            self.super_viewer = m.get('super_viewer')
        if m.get('super_admin') is not None:
            self.super_admin = m.get('super_admin')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('emp_id') is not None:
            self.emp_id = m.get('emp_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('login_name') is not None:
            self.login_name = m.get('login_name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('user_display_name') is not None:
            self.user_display_name = m.get('user_display_name')
        if m.get('real_name') is not None:
            self.real_name = m.get('real_name')
        if m.get('phone_num') is not None:
            self.phone_num = m.get('phone_num')
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('enterprise_id') is not None:
            self.enterprise_id = m.get('enterprise_id')
        if m.get('token') is not None:
            self.token = m.get('token')
        if m.get('is_from_aliyun') is not None:
            self.is_from_aliyun = m.get('is_from_aliyun')
        return self


class XPrometheusQuery(TeaModel):
    def __init__(
        self,
        port: int = None,
        ip: str = None,
        path: str = None,
        target: XTarget = None,
    ):
        # 
        self.port = port
        # 
        self.ip = ip
        # 
        self.path = path
        # 
        self.target = target

    def validate(self):
        self.validate_required(self.port, 'port')
        self.validate_required(self.path, 'path')
        if self.target:
            self.target.validate()

    def to_map(self):
        result = dict()
        if self.port is not None:
            result['port'] = self.port
        if self.ip is not None:
            result['ip'] = self.ip
        if self.path is not None:
            result['path'] = self.path
        if self.target is not None:
            result['target'] = self.target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('target') is not None:
            temp_model = XTarget()
            self.target = temp_model.from_map(m['target'])
        return self


class Cal(TeaModel):
    def __init__(
        self,
        fun: str = None,
        val: UniqueDim = None,
        val_bak: UniqueDim = None,
        topn: int = None,
        contain_vals: ContainVals = None,
    ):
        # 统计功能
        self.fun = fun
        # 值对象
        self.val = val
        # 值对象备份
        self.val_bak = val_bak
        # topn
        self.topn = topn
        # 所包含的值
        self.contain_vals = contain_vals

    def validate(self):
        self.validate_required(self.fun, 'fun')
        if self.val:
            self.val.validate()
        if self.val_bak:
            self.val_bak.validate()
        if self.contain_vals:
            self.contain_vals.validate()

    def to_map(self):
        result = dict()
        if self.fun is not None:
            result['fun'] = self.fun
        if self.val is not None:
            result['val'] = self.val.to_map()
        if self.val_bak is not None:
            result['val_bak'] = self.val_bak.to_map()
        if self.topn is not None:
            result['topn'] = self.topn
        if self.contain_vals is not None:
            result['contain_vals'] = self.contain_vals.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fun') is not None:
            self.fun = m.get('fun')
        if m.get('val') is not None:
            temp_model = UniqueDim()
            self.val = temp_model.from_map(m['val'])
        if m.get('val_bak') is not None:
            temp_model = UniqueDim()
            self.val_bak = temp_model.from_map(m['val_bak'])
        if m.get('topn') is not None:
            self.topn = m.get('topn')
        if m.get('contain_vals') is not None:
            temp_model = ContainVals()
            self.contain_vals = temp_model.from_map(m['contain_vals'])
        return self


class OpsmetaSchema(TeaModel):
    def __init__(
        self,
        envs: List[str] = None,
        idc: OpsFilter = None,
        ldc: OpsFilter = None,
        server: OpsFilter = None,
    ):
        # envs
        self.envs = envs
        # idc
        self.idc = idc
        # ldc
        self.ldc = ldc
        # server
        self.server = server

    def validate(self):
        self.validate_required(self.envs, 'envs')
        self.validate_required(self.idc, 'idc')
        if self.idc:
            self.idc.validate()
        self.validate_required(self.ldc, 'ldc')
        if self.ldc:
            self.ldc.validate()
        self.validate_required(self.server, 'server')
        if self.server:
            self.server.validate()

    def to_map(self):
        result = dict()
        if self.envs is not None:
            result['envs'] = self.envs
        if self.idc is not None:
            result['idc'] = self.idc.to_map()
        if self.ldc is not None:
            result['ldc'] = self.ldc.to_map()
        if self.server is not None:
            result['server'] = self.server.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('envs') is not None:
            self.envs = m.get('envs')
        if m.get('idc') is not None:
            temp_model = OpsFilter()
            self.idc = temp_model.from_map(m['idc'])
        if m.get('ldc') is not None:
            temp_model = OpsFilter()
            self.ldc = temp_model.from_map(m['ldc'])
        if m.get('server') is not None:
            temp_model = OpsFilter()
            self.server = temp_model.from_map(m['server'])
        return self


class XDashboardQuery(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        parent_uuid: str = None,
        name: str = None,
    ):
        # 
        self.uuid = uuid
        # 
        self.parent_uuid = parent_uuid
        # 
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.parent_uuid is not None:
            result['parent_uuid'] = self.parent_uuid
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('parent_uuid') is not None:
            self.parent_uuid = m.get('parent_uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class FolderPath(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        type: str = None,
    ):
        # id
        self.id = id
        # name
        self.name = name
        # v
        self.type = type

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class KeyValuePair(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class OneConsoleWorkspace(TeaModel):
    def __init__(
        self,
        id: str = None,
        identity: str = None,
        name: str = None,
    ):
        # ws id
        self.id = id
        # identity
        self.identity = identity
        # name
        self.name = name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.name, 'name')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.identity is not None:
            result['identity'] = self.identity
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class XDatasourceCRULResponseCURequest(TeaModel):
    def __init__(
        self,
        api_version: str = None,
        metadata: XResource = None,
        spec: XSpec = None,
    ):
        # 
        self.api_version = api_version
        # 
        self.metadata = metadata
        # 
        self.spec = spec

    def validate(self):
        self.validate_required(self.metadata, 'metadata')
        if self.metadata:
            self.metadata.validate()
        self.validate_required(self.spec, 'spec')
        if self.spec:
            self.spec.validate()

    def to_map(self):
        result = dict()
        if self.api_version is not None:
            result['api_version'] = self.api_version
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        if self.spec is not None:
            result['spec'] = self.spec.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('api_version') is not None:
            self.api_version = m.get('api_version')
        if m.get('metadata') is not None:
            temp_model = XResource()
            self.metadata = temp_model.from_map(m['metadata'])
        if m.get('spec') is not None:
            temp_model = XSpec()
            self.spec = temp_model.from_map(m['spec'])
        return self


class UnifiedAlarmHistoryVO(TeaModel):
    def __init__(
        self,
        id: int = None,
        event_id: str = None,
        alarm_rule_id: int = None,
        unique_identity: str = None,
        alarm_rule_name: str = None,
        alarm_level: int = None,
        alarm_time: int = None,
        alarm_content: str = None,
        alarm_target: str = None,
        status: int = None,
        tenant_id: int = None,
        workspace_id: int = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        alarm_target_type: str = None,
        alarm_detail: str = None,
        data_source_name: str = None,
        alarm_url: str = None,
        alarm_type: str = None,
        alarm_target_deleted: bool = None,
    ):
        # 主键
        self.id = id
        # 事件id
        self.event_id = event_id
        # 告警规则id
        self.alarm_rule_id = alarm_rule_id
        # 告警规则唯一标识
        self.unique_identity = unique_identity
        # 告警规则名字
        self.alarm_rule_name = alarm_rule_name
        # 告警等级
        self.alarm_level = alarm_level
        # 告警时间
        self.alarm_time = alarm_time
        # 告警内容
        self.alarm_content = alarm_content
        # 告警对象
        self.alarm_target = alarm_target
        # 触发状态
        self.status = status
        # 租户id
        self.tenant_id = tenant_id
        # 工作区id
        self.workspace_id = workspace_id
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # type
        self.alarm_target_type = alarm_target_type
        # 告警详情
        self.alarm_detail = alarm_detail
        # 数据源名称
        self.data_source_name = data_source_name
        # 数据源跳转url
        self.alarm_url = alarm_url
        # 告警类型
        self.alarm_type = alarm_type
        # 目标对象是否已经删除
        self.alarm_target_deleted = alarm_target_deleted

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.event_id, 'event_id')
        self.validate_required(self.alarm_rule_id, 'alarm_rule_id')
        self.validate_required(self.unique_identity, 'unique_identity')
        self.validate_required(self.alarm_rule_name, 'alarm_rule_name')
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.alarm_time, 'alarm_time')
        self.validate_required(self.alarm_content, 'alarm_content')
        self.validate_required(self.alarm_target, 'alarm_target')
        self.validate_required(self.status, 'status')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.alarm_detail, 'alarm_detail')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.event_id is not None:
            result['event_id'] = self.event_id
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.unique_identity is not None:
            result['unique_identity'] = self.unique_identity
        if self.alarm_rule_name is not None:
            result['alarm_rule_name'] = self.alarm_rule_name
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.alarm_time is not None:
            result['alarm_time'] = self.alarm_time
        if self.alarm_content is not None:
            result['alarm_content'] = self.alarm_content
        if self.alarm_target is not None:
            result['alarm_target'] = self.alarm_target
        if self.status is not None:
            result['status'] = self.status
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.alarm_detail is not None:
            result['alarm_detail'] = self.alarm_detail
        if self.data_source_name is not None:
            result['data_source_name'] = self.data_source_name
        if self.alarm_url is not None:
            result['alarm_url'] = self.alarm_url
        if self.alarm_type is not None:
            result['alarm_type'] = self.alarm_type
        if self.alarm_target_deleted is not None:
            result['alarm_target_deleted'] = self.alarm_target_deleted
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('event_id') is not None:
            self.event_id = m.get('event_id')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('unique_identity') is not None:
            self.unique_identity = m.get('unique_identity')
        if m.get('alarm_rule_name') is not None:
            self.alarm_rule_name = m.get('alarm_rule_name')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('alarm_time') is not None:
            self.alarm_time = m.get('alarm_time')
        if m.get('alarm_content') is not None:
            self.alarm_content = m.get('alarm_content')
        if m.get('alarm_target') is not None:
            self.alarm_target = m.get('alarm_target')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('alarm_detail') is not None:
            self.alarm_detail = m.get('alarm_detail')
        if m.get('data_source_name') is not None:
            self.data_source_name = m.get('data_source_name')
        if m.get('alarm_url') is not None:
            self.alarm_url = m.get('alarm_url')
        if m.get('alarm_type') is not None:
            self.alarm_type = m.get('alarm_type')
        if m.get('alarm_target_deleted') is not None:
            self.alarm_target_deleted = m.get('alarm_target_deleted')
        return self


class AppTopItem(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        value: str = None,
    ):
        # 应用名
        self.app_name = app_name
        # 应用TopN统计值，有可能有小数，使用前转换为数值
        self.value = value

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.value, 'value')

    def to_map(self):
        result = dict()
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class XSiteExportStats(TeaModel):
    def __init__(
        self,
        alert: int = None,
        alert_datasource: int = None,
        dashboard: int = None,
        dashboard_datasource: int = None,
        datasource: int = None,
        alarm_subscriber_count: int = None,
    ):
        # 
        self.alert = alert
        # 
        self.alert_datasource = alert_datasource
        # 
        self.dashboard = dashboard
        # 
        self.dashboard_datasource = dashboard_datasource
        # 
        self.datasource = datasource
        # 通知对象的数量
        self.alarm_subscriber_count = alarm_subscriber_count

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.alert is not None:
            result['alert'] = self.alert
        if self.alert_datasource is not None:
            result['alert_datasource'] = self.alert_datasource
        if self.dashboard is not None:
            result['dashboard'] = self.dashboard
        if self.dashboard_datasource is not None:
            result['dashboard_datasource'] = self.dashboard_datasource
        if self.datasource is not None:
            result['datasource'] = self.datasource
        if self.alarm_subscriber_count is not None:
            result['alarm_subscriber_count'] = self.alarm_subscriber_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alert') is not None:
            self.alert = m.get('alert')
        if m.get('alert_datasource') is not None:
            self.alert_datasource = m.get('alert_datasource')
        if m.get('dashboard') is not None:
            self.dashboard = m.get('dashboard')
        if m.get('dashboard_datasource') is not None:
            self.dashboard_datasource = m.get('dashboard_datasource')
        if m.get('datasource') is not None:
            self.datasource = m.get('datasource')
        if m.get('alarm_subscriber_count') is not None:
            self.alarm_subscriber_count = m.get('alarm_subscriber_count')
        return self


class TraceSpan(TeaModel):
    def __init__(
        self,
        component: str = None,
        duration: int = None,
        info: str = None,
        kind: str = None,
        local_ip: str = None,
        local_service_name: str = None,
        local_idc_name: str = None,
        local_cell_name: str = None,
        name: str = None,
        parent_id: str = None,
        remote_ip: str = None,
        remote_service_name: str = None,
        remote_idc_name: str = None,
        remote_cell_name: str = None,
        span_id: str = None,
        start_time: int = None,
        status: str = None,
        tags: List[KeySet] = None,
        trace_id: str = None,
    ):
        # 组件类型
        self.component = component
        # 毫秒耗时
        self.duration = duration
        # 服务描述信息
        self.info = info
        # span kind, CLIENT SERVER PRODUCER CONSUMER
        self.kind = kind
        # local endpoint ip
        self.local_ip = local_ip
        # local endpoint service name
        self.local_service_name = local_service_name
        # local idc name
        self.local_idc_name = local_idc_name
        # local cell name
        self.local_cell_name = local_cell_name
        # name
        self.name = name
        # parent_id
        self.parent_id = parent_id
        # remote endpoint ip
        self.remote_ip = remote_ip
        # remote endpoint service name
        self.remote_service_name = remote_service_name
        # remote idc name
        self.remote_idc_name = remote_idc_name
        # remote cell name
        self.remote_cell_name = remote_cell_name
        # span_id
        self.span_id = span_id
        # 开始时间, 毫秒时间戳
        self.start_time = start_time
        # 状态码
        self.status = status
        # span tags, 是关于span的键值对
        self.tags = tags
        # trace id
        self.trace_id = trace_id

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.component is not None:
            result['component'] = self.component
        if self.duration is not None:
            result['duration'] = self.duration
        if self.info is not None:
            result['info'] = self.info
        if self.kind is not None:
            result['kind'] = self.kind
        if self.local_ip is not None:
            result['local_ip'] = self.local_ip
        if self.local_service_name is not None:
            result['local_service_name'] = self.local_service_name
        if self.local_idc_name is not None:
            result['local_idc_name'] = self.local_idc_name
        if self.local_cell_name is not None:
            result['local_cell_name'] = self.local_cell_name
        if self.name is not None:
            result['name'] = self.name
        if self.parent_id is not None:
            result['parent_id'] = self.parent_id
        if self.remote_ip is not None:
            result['remote_ip'] = self.remote_ip
        if self.remote_service_name is not None:
            result['remote_service_name'] = self.remote_service_name
        if self.remote_idc_name is not None:
            result['remote_idc_name'] = self.remote_idc_name
        if self.remote_cell_name is not None:
            result['remote_cell_name'] = self.remote_cell_name
        if self.span_id is not None:
            result['span_id'] = self.span_id
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('component') is not None:
            self.component = m.get('component')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('info') is not None:
            self.info = m.get('info')
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('local_ip') is not None:
            self.local_ip = m.get('local_ip')
        if m.get('local_service_name') is not None:
            self.local_service_name = m.get('local_service_name')
        if m.get('local_idc_name') is not None:
            self.local_idc_name = m.get('local_idc_name')
        if m.get('local_cell_name') is not None:
            self.local_cell_name = m.get('local_cell_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_id') is not None:
            self.parent_id = m.get('parent_id')
        if m.get('remote_ip') is not None:
            self.remote_ip = m.get('remote_ip')
        if m.get('remote_service_name') is not None:
            self.remote_service_name = m.get('remote_service_name')
        if m.get('remote_idc_name') is not None:
            self.remote_idc_name = m.get('remote_idc_name')
        if m.get('remote_cell_name') is not None:
            self.remote_cell_name = m.get('remote_cell_name')
        if m.get('span_id') is not None:
            self.span_id = m.get('span_id')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeySet()
                self.tags.append(temp_model.from_map(k))
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        return self


class Spm(TeaModel):
    def __init__(
        self,
        result_dim: UniqueDim = None,
        cost_dim: UniqueDim = None,
        count_dim: UniqueDim = None,
    ):
        # resultDim
        self.result_dim = result_dim
        # costDim
        self.cost_dim = cost_dim
        # countDim
        self.count_dim = count_dim

    def validate(self):
        if self.result_dim:
            self.result_dim.validate()
        if self.cost_dim:
            self.cost_dim.validate()
        if self.count_dim:
            self.count_dim.validate()

    def to_map(self):
        result = dict()
        if self.result_dim is not None:
            result['result_dim'] = self.result_dim.to_map()
        if self.cost_dim is not None:
            result['cost_dim'] = self.cost_dim.to_map()
        if self.count_dim is not None:
            result['count_dim'] = self.count_dim.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result_dim') is not None:
            temp_model = UniqueDim()
            self.result_dim = temp_model.from_map(m['result_dim'])
        if m.get('cost_dim') is not None:
            temp_model = UniqueDim()
            self.cost_dim = temp_model.from_map(m['cost_dim'])
        if m.get('count_dim') is not None:
            temp_model = UniqueDim()
            self.count_dim = temp_model.from_map(m['count_dim'])
        return self


class StackExpression(TeaModel):
    def __init__(
        self,
        states: List[StackState] = None,
        andor: bool = None,
    ):
        # states
        self.states = states
        # andor
        self.andor = andor

    def validate(self):
        self.validate_required(self.states, 'states')
        if self.states:
            for k in self.states:
                if k:
                    k.validate()
        self.validate_required(self.andor, 'andor')

    def to_map(self):
        result = dict()
        result['states'] = []
        if self.states is not None:
            for k in self.states:
                result['states'].append(k.to_map() if k else None)
        if self.andor is not None:
            result['andor'] = self.andor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.states = []
        if m.get('states') is not None:
            for k in m.get('states'):
                temp_model = StackState()
                self.states.append(temp_model.from_map(k))
        if m.get('andor') is not None:
            self.andor = m.get('andor')
        return self


class TimeSeriesMetricsPoint(TeaModel):
    def __init__(
        self,
        timestamp: int = None,
        value: List[TimeSeriesMetricsField] = None,
    ):
        # 时间戳 (毫秒)
        self.timestamp = timestamp
        # Metrics 某时间点的具体值
        self.value = value

    def validate(self):
        if self.value:
            for k in self.value:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.timestamp is not None:
            result['timestamp'] = self.timestamp
        result['value'] = []
        if self.value is not None:
            for k in self.value:
                result['value'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('timestamp') is not None:
            self.timestamp = m.get('timestamp')
        self.value = []
        if m.get('value') is not None:
            for k in m.get('value'):
                temp_model = TimeSeriesMetricsField()
                self.value.append(temp_model.from_map(k))
        return self


class StatusDO(TeaModel):
    def __init__(
        self,
        creater: str = None,
        create_time: int = None,
        operator: str = None,
        update_time: int = None,
        status_desc: str = None,
        compute_close: bool = None,
        degrade_reason: str = None,
        degrade_operator: str = None,
        degrade_time: str = None,
        degrade_time_v2: int = None,
    ):
        # creater
        self.creater = creater
        # create_time
        self.create_time = create_time
        # operator
        self.operator = operator
        # update_time
        self.update_time = update_time
        # status_desc
        self.status_desc = status_desc
        # compute_close
        self.compute_close = compute_close
        # degrade_reason
        self.degrade_reason = degrade_reason
        # degrade_operator
        self.degrade_operator = degrade_operator
        # degrade_time
        self.degrade_time = degrade_time
        # degrade_time_v2
        self.degrade_time_v2 = degrade_time_v2

    def validate(self):
        self.validate_required(self.creater, 'creater')
        self.validate_required(self.create_time, 'create_time')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.update_time, 'update_time')
        self.validate_required(self.status_desc, 'status_desc')
        self.validate_required(self.compute_close, 'compute_close')
        self.validate_required(self.degrade_reason, 'degrade_reason')
        self.validate_required(self.degrade_operator, 'degrade_operator')
        self.validate_required(self.degrade_time, 'degrade_time')
        self.validate_required(self.degrade_time_v2, 'degrade_time_v2')

    def to_map(self):
        result = dict()
        if self.creater is not None:
            result['creater'] = self.creater
        if self.create_time is not None:
            result['create_time'] = self.create_time
        if self.operator is not None:
            result['operator'] = self.operator
        if self.update_time is not None:
            result['update_time'] = self.update_time
        if self.status_desc is not None:
            result['status_desc'] = self.status_desc
        if self.compute_close is not None:
            result['compute_close'] = self.compute_close
        if self.degrade_reason is not None:
            result['degrade_reason'] = self.degrade_reason
        if self.degrade_operator is not None:
            result['degrade_operator'] = self.degrade_operator
        if self.degrade_time is not None:
            result['degrade_time'] = self.degrade_time
        if self.degrade_time_v2 is not None:
            result['degrade_time_v2'] = self.degrade_time_v2
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creater') is not None:
            self.creater = m.get('creater')
        if m.get('create_time') is not None:
            self.create_time = m.get('create_time')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('update_time') is not None:
            self.update_time = m.get('update_time')
        if m.get('status_desc') is not None:
            self.status_desc = m.get('status_desc')
        if m.get('compute_close') is not None:
            self.compute_close = m.get('compute_close')
        if m.get('degrade_reason') is not None:
            self.degrade_reason = m.get('degrade_reason')
        if m.get('degrade_operator') is not None:
            self.degrade_operator = m.get('degrade_operator')
        if m.get('degrade_time') is not None:
            self.degrade_time = m.get('degrade_time')
        if m.get('degrade_time_v2') is not None:
            self.degrade_time_v2 = m.get('degrade_time_v2')
        return self


class AlarmNotifyStats(TeaModel):
    def __init__(
        self,
        alarm_time: int = None,
        count: int = None,
        notify_channel: str = None,
    ):
        # alarm_time
        self.alarm_time = alarm_time
        # count
        self.count = count
        # notify_channel
        self.notify_channel = notify_channel

    def validate(self):
        self.validate_required(self.alarm_time, 'alarm_time')
        self.validate_required(self.count, 'count')
        self.validate_required(self.notify_channel, 'notify_channel')

    def to_map(self):
        result = dict()
        if self.alarm_time is not None:
            result['alarm_time'] = self.alarm_time
        if self.count is not None:
            result['count'] = self.count
        if self.notify_channel is not None:
            result['notify_channel'] = self.notify_channel
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alarm_time') is not None:
            self.alarm_time = m.get('alarm_time')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('notify_channel') is not None:
            self.notify_channel = m.get('notify_channel')
        return self


class LongListKeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: List[str] = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class XDatasourceQuery(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        parent_uuid: str = None,
        name: str = None,
        enabled: bool = None,
        target_resource_kind: str = None,
        target_resource_name: str = None,
        rule_type: str = None,
        created_by: str = None,
    ):
        # 
        self.uuid = uuid
        # 
        self.parent_uuid = parent_uuid
        # 
        self.name = name
        # 
        self.enabled = enabled
        # 
        self.target_resource_kind = target_resource_kind
        # 
        self.target_resource_name = target_resource_name
        # 
        self.rule_type = rule_type
        # 
        self.created_by = created_by

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.parent_uuid is not None:
            result['parent_uuid'] = self.parent_uuid
        if self.name is not None:
            result['name'] = self.name
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.target_resource_kind is not None:
            result['target_resource_kind'] = self.target_resource_kind
        if self.target_resource_name is not None:
            result['target_resource_name'] = self.target_resource_name
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.created_by is not None:
            result['created_by'] = self.created_by
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('parent_uuid') is not None:
            self.parent_uuid = m.get('parent_uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('target_resource_kind') is not None:
            self.target_resource_kind = m.get('target_resource_kind')
        if m.get('target_resource_name') is not None:
            self.target_resource_name = m.get('target_resource_name')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('created_by') is not None:
            self.created_by = m.get('created_by')
        return self


class Menu(TeaModel):
    def __init__(
        self,
        id: str = None,
    ):
        # id
        self.id = id

    def validate(self):
        self.validate_required(self.id, 'id')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class AlarmPkgDO(TeaModel):
    def __init__(
        self,
        biz_groupby_name: str = None,
        id: int = None,
        name: str = None,
        stack_metric_group_metric_table: str = None,
        tag_value: str = None,
        uuid: str = None,
        alarm: AlarmDO = None,
        top_alarm: TopAlarmDO = None,
    ):
        # biz_groupby_name
        self.biz_groupby_name = biz_groupby_name
        # id
        self.id = id
        # name
        self.name = name
        # stack_metric_group_metric_table
        self.stack_metric_group_metric_table = stack_metric_group_metric_table
        # tag_value
        self.tag_value = tag_value
        # uuid
        self.uuid = uuid
        # alarm
        self.alarm = alarm
        # top_alarm
        self.top_alarm = top_alarm

    def validate(self):
        self.validate_required(self.biz_groupby_name, 'biz_groupby_name')
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.stack_metric_group_metric_table, 'stack_metric_group_metric_table')
        self.validate_required(self.tag_value, 'tag_value')
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.alarm, 'alarm')
        if self.alarm:
            self.alarm.validate()
        self.validate_required(self.top_alarm, 'top_alarm')
        if self.top_alarm:
            self.top_alarm.validate()

    def to_map(self):
        result = dict()
        if self.biz_groupby_name is not None:
            result['biz_groupby_name'] = self.biz_groupby_name
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.stack_metric_group_metric_table is not None:
            result['stack_metric_group_metric_table'] = self.stack_metric_group_metric_table
        if self.tag_value is not None:
            result['tag_value'] = self.tag_value
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.alarm is not None:
            result['alarm'] = self.alarm.to_map()
        if self.top_alarm is not None:
            result['top_alarm'] = self.top_alarm.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_groupby_name') is not None:
            self.biz_groupby_name = m.get('biz_groupby_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('stack_metric_group_metric_table') is not None:
            self.stack_metric_group_metric_table = m.get('stack_metric_group_metric_table')
        if m.get('tag_value') is not None:
            self.tag_value = m.get('tag_value')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('alarm') is not None:
            temp_model = AlarmDO()
            self.alarm = temp_model.from_map(m['alarm'])
        if m.get('top_alarm') is not None:
            temp_model = TopAlarmDO()
            self.top_alarm = temp_model.from_map(m['top_alarm'])
        return self


class AlarmTypeStatsVO(TeaModel):
    def __init__(
        self,
        custom_plugin: int = None,
        meta_group: int = None,
        stack_universal_table: int = None,
    ):
        # custom_plugin
        self.custom_plugin = custom_plugin
        # meta_group
        self.meta_group = meta_group
        # stack_universal_table
        self.stack_universal_table = stack_universal_table

    def validate(self):
        self.validate_required(self.custom_plugin, 'custom_plugin')
        self.validate_required(self.meta_group, 'meta_group')
        self.validate_required(self.stack_universal_table, 'stack_universal_table')

    def to_map(self):
        result = dict()
        if self.custom_plugin is not None:
            result['custom_plugin'] = self.custom_plugin
        if self.meta_group is not None:
            result['meta_group'] = self.meta_group
        if self.stack_universal_table is not None:
            result['stack_universal_table'] = self.stack_universal_table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('custom_plugin') is not None:
            self.custom_plugin = m.get('custom_plugin')
        if m.get('meta_group') is not None:
            self.meta_group = m.get('meta_group')
        if m.get('stack_universal_table') is not None:
            self.stack_universal_table = m.get('stack_universal_table')
        return self


class SaveSchema(TeaModel):
    def __init__(
        self,
        capacity: int = None,
        reserved: str = None,
        max_key_size: int = None,
    ):
        # capacity
        self.capacity = capacity
        # reserved
        self.reserved = reserved
        # max_key_size
        self.max_key_size = max_key_size

    def validate(self):
        self.validate_required(self.capacity, 'capacity')
        self.validate_required(self.reserved, 'reserved')
        self.validate_required(self.max_key_size, 'max_key_size')

    def to_map(self):
        result = dict()
        if self.capacity is not None:
            result['capacity'] = self.capacity
        if self.reserved is not None:
            result['reserved'] = self.reserved
        if self.max_key_size is not None:
            result['max_key_size'] = self.max_key_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('capacity') is not None:
            self.capacity = m.get('capacity')
        if m.get('reserved') is not None:
            self.reserved = m.get('reserved')
        if m.get('max_key_size') is not None:
            self.max_key_size = m.get('max_key_size')
        return self


class AlarmHistoryDTO(TeaModel):
    def __init__(
        self,
        id: int = None,
        alarm_rule_name: str = None,
        msg: str = None,
        alarm_pkg_id: int = None,
        custom_plugin_id: int = None,
        meta_group_id: int = None,
        stack_universal_table_id: str = None,
        tag_value_id: int = None,
        tenant_id: int = None,
        workspace_id: int = None,
        biz_domain_id: int = None,
        alarm_time: int = None,
        alarm_level: int = None,
        stack_id: int = None,
        stack_entity_id: int = None,
        stack_monitor_item_name: str = None,
        alarm_source_type: str = None,
        biz_id: int = None,
        biz_groupby_name: str = None,
        multi_alarm_id: int = None,
        context: List[KeySet] = None,
    ):
        # id
        self.id = id
        # alarm_rule_name
        self.alarm_rule_name = alarm_rule_name
        # msg
        self.msg = msg
        # alarm_pkg_id
        self.alarm_pkg_id = alarm_pkg_id
        # custom_plugin_id
        self.custom_plugin_id = custom_plugin_id
        # meta_group_id
        self.meta_group_id = meta_group_id
        # stack_universal_tableId
        self.stack_universal_table_id = stack_universal_table_id
        # tag_value_id
        self.tag_value_id = tag_value_id
        # tenant_id
        self.tenant_id = tenant_id
        # workspace_id
        self.workspace_id = workspace_id
        # biz_domain_id
        self.biz_domain_id = biz_domain_id
        # alarm_time
        self.alarm_time = alarm_time
        # alarm_level
        self.alarm_level = alarm_level
        # stack_id
        self.stack_id = stack_id
        # stack_entity_id
        self.stack_entity_id = stack_entity_id
        # stack_monitor_item_name
        self.stack_monitor_item_name = stack_monitor_item_name
        # alarm_source_type
        self.alarm_source_type = alarm_source_type
        # biz_id
        self.biz_id = biz_id
        # biz_groupby_name
        self.biz_groupby_name = biz_groupby_name
        # multi_alarm_id
        self.multi_alarm_id = multi_alarm_id
        # context
        self.context = context

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.alarm_rule_name, 'alarm_rule_name')
        self.validate_required(self.msg, 'msg')
        self.validate_required(self.alarm_pkg_id, 'alarm_pkg_id')
        self.validate_required(self.custom_plugin_id, 'custom_plugin_id')
        self.validate_required(self.meta_group_id, 'meta_group_id')
        self.validate_required(self.stack_universal_table_id, 'stack_universal_table_id')
        self.validate_required(self.tag_value_id, 'tag_value_id')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.biz_domain_id, 'biz_domain_id')
        self.validate_required(self.alarm_time, 'alarm_time')
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.stack_id, 'stack_id')
        self.validate_required(self.stack_entity_id, 'stack_entity_id')
        self.validate_required(self.stack_monitor_item_name, 'stack_monitor_item_name')
        self.validate_required(self.alarm_source_type, 'alarm_source_type')
        self.validate_required(self.biz_id, 'biz_id')
        self.validate_required(self.biz_groupby_name, 'biz_groupby_name')
        self.validate_required(self.multi_alarm_id, 'multi_alarm_id')
        self.validate_required(self.context, 'context')
        if self.context:
            for k in self.context:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.alarm_rule_name is not None:
            result['alarm_rule_name'] = self.alarm_rule_name
        if self.msg is not None:
            result['msg'] = self.msg
        if self.alarm_pkg_id is not None:
            result['alarm_pkg_id'] = self.alarm_pkg_id
        if self.custom_plugin_id is not None:
            result['custom_plugin_id'] = self.custom_plugin_id
        if self.meta_group_id is not None:
            result['meta_group_id'] = self.meta_group_id
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        if self.tag_value_id is not None:
            result['tag_value_id'] = self.tag_value_id
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.biz_domain_id is not None:
            result['biz_domain_id'] = self.biz_domain_id
        if self.alarm_time is not None:
            result['alarm_time'] = self.alarm_time
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.stack_id is not None:
            result['stack_id'] = self.stack_id
        if self.stack_entity_id is not None:
            result['stack_entity_id'] = self.stack_entity_id
        if self.stack_monitor_item_name is not None:
            result['stack_monitor_item_name'] = self.stack_monitor_item_name
        if self.alarm_source_type is not None:
            result['alarm_source_type'] = self.alarm_source_type
        if self.biz_id is not None:
            result['biz_id'] = self.biz_id
        if self.biz_groupby_name is not None:
            result['biz_groupby_name'] = self.biz_groupby_name
        if self.multi_alarm_id is not None:
            result['multi_alarm_id'] = self.multi_alarm_id
        result['context'] = []
        if self.context is not None:
            for k in self.context:
                result['context'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('alarm_rule_name') is not None:
            self.alarm_rule_name = m.get('alarm_rule_name')
        if m.get('msg') is not None:
            self.msg = m.get('msg')
        if m.get('alarm_pkg_id') is not None:
            self.alarm_pkg_id = m.get('alarm_pkg_id')
        if m.get('custom_plugin_id') is not None:
            self.custom_plugin_id = m.get('custom_plugin_id')
        if m.get('meta_group_id') is not None:
            self.meta_group_id = m.get('meta_group_id')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        if m.get('tag_value_id') is not None:
            self.tag_value_id = m.get('tag_value_id')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('biz_domain_id') is not None:
            self.biz_domain_id = m.get('biz_domain_id')
        if m.get('alarm_time') is not None:
            self.alarm_time = m.get('alarm_time')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('stack_id') is not None:
            self.stack_id = m.get('stack_id')
        if m.get('stack_entity_id') is not None:
            self.stack_entity_id = m.get('stack_entity_id')
        if m.get('stack_monitor_item_name') is not None:
            self.stack_monitor_item_name = m.get('stack_monitor_item_name')
        if m.get('alarm_source_type') is not None:
            self.alarm_source_type = m.get('alarm_source_type')
        if m.get('biz_id') is not None:
            self.biz_id = m.get('biz_id')
        if m.get('biz_groupby_name') is not None:
            self.biz_groupby_name = m.get('biz_groupby_name')
        if m.get('multi_alarm_id') is not None:
            self.multi_alarm_id = m.get('multi_alarm_id')
        self.context = []
        if m.get('context') is not None:
            for k in m.get('context'):
                temp_model = KeySet()
                self.context.append(temp_model.from_map(k))
        return self


class XDashboardCRULResponseCURequest(TeaModel):
    def __init__(
        self,
        api_version: str = None,
        metadata: XResource = None,
        config: str = None,
    ):
        # API版本
        self.api_version = api_version
        # Dashboard元数据信息
        self.metadata = metadata
        # Dashboard配置JSON字符串。
        # Dashboard目录不需要填写
        self.config = config

    def validate(self):
        self.validate_required(self.metadata, 'metadata')
        if self.metadata:
            self.metadata.validate()

    def to_map(self):
        result = dict()
        if self.api_version is not None:
            result['api_version'] = self.api_version
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        if self.config is not None:
            result['config'] = self.config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('api_version') is not None:
            self.api_version = m.get('api_version')
        if m.get('metadata') is not None:
            temp_model = XResource()
            self.metadata = temp_model.from_map(m['metadata'])
        if m.get('config') is not None:
            self.config = m.get('config')
        return self


class OpsGroupBy(TeaModel):
    def __init__(
        self,
        env: bool = None,
        deploy_unit: bool = None,
        app: bool = None,
        idc: bool = None,
        ldc: bool = None,
        server: bool = None,
        extra: str = None,
    ):
        # 是否按环境分组
        self.env = env
        # 是否按部署单元分组
        self.deploy_unit = deploy_unit
        # 是否按应用分组
        self.app = app
        # 是否按idc分组
        self.idc = idc
        # 是否按ldc分组
        self.ldc = ldc
        # 是否按server分组
        self.server = server
        # 附加信息
        self.extra = extra

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.env is not None:
            result['env'] = self.env
        if self.deploy_unit is not None:
            result['deploy_unit'] = self.deploy_unit
        if self.app is not None:
            result['app'] = self.app
        if self.idc is not None:
            result['idc'] = self.idc
        if self.ldc is not None:
            result['ldc'] = self.ldc
        if self.server is not None:
            result['server'] = self.server
        if self.extra is not None:
            result['extra'] = self.extra
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('env') is not None:
            self.env = m.get('env')
        if m.get('deploy_unit') is not None:
            self.deploy_unit = m.get('deploy_unit')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('idc') is not None:
            self.idc = m.get('idc')
        if m.get('ldc') is not None:
            self.ldc = m.get('ldc')
        if m.get('server') is not None:
            self.server = m.get('server')
        if m.get('extra') is not None:
            self.extra = m.get('extra')
        return self


class AlarmCountInfo(TeaModel):
    def __init__(
        self,
        custom_plugin_count: int = None,
        app_group_count: int = None,
        app_count: int = None,
    ):
        # 自定义监控告警数量
        self.custom_plugin_count = custom_plugin_count
        # 应用组告警数量
        self.app_group_count = app_group_count
        # 应用监控告警数量
        self.app_count = app_count

    def validate(self):
        self.validate_required(self.custom_plugin_count, 'custom_plugin_count')
        self.validate_required(self.app_group_count, 'app_group_count')
        self.validate_required(self.app_count, 'app_count')

    def to_map(self):
        result = dict()
        if self.custom_plugin_count is not None:
            result['custom_plugin_count'] = self.custom_plugin_count
        if self.app_group_count is not None:
            result['app_group_count'] = self.app_group_count
        if self.app_count is not None:
            result['app_count'] = self.app_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('custom_plugin_count') is not None:
            self.custom_plugin_count = m.get('custom_plugin_count')
        if m.get('app_group_count') is not None:
            self.app_group_count = m.get('app_group_count')
        if m.get('app_count') is not None:
            self.app_count = m.get('app_count')
        return self


class Log(TeaModel):
    def __init__(
        self,
        apps: List[str] = None,
        path: str = None,
        charset: str = None,
        agent_limit_kb: int = None,
        symlink_path: str = None,
    ):
        # 应用名列表
        self.apps = apps
        # 采集日志文件
        self.path = path
        # 日志编码
        self.charset = charset
        # 日志限制流量，单位KB/min
        self.agent_limit_kb = agent_limit_kb
        # 日志路径软连接描述
        self.symlink_path = symlink_path

    def validate(self):
        self.validate_required(self.apps, 'apps')
        self.validate_required(self.path, 'path')

    def to_map(self):
        result = dict()
        if self.apps is not None:
            result['apps'] = self.apps
        if self.path is not None:
            result['path'] = self.path
        if self.charset is not None:
            result['charset'] = self.charset
        if self.agent_limit_kb is not None:
            result['agent_limit_k_b'] = self.agent_limit_kb
        if self.symlink_path is not None:
            result['symlink_path'] = self.symlink_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('apps') is not None:
            self.apps = m.get('apps')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('charset') is not None:
            self.charset = m.get('charset')
        if m.get('agent_limit_k_b') is not None:
            self.agent_limit_kb = m.get('agent_limit_k_b')
        if m.get('symlink_path') is not None:
            self.symlink_path = m.get('symlink_path')
        return self


class TraasEntityTopoNode(TeaModel):
    def __init__(
        self,
        name: str = None,
        field: str = None,
    ):
        # name
        self.name = name
        # field
        self.field = field

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.field, 'field')

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.field is not None:
            result['field'] = self.field
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('field') is not None:
            self.field = m.get('field')
        return self


class AlarmLevelStatsVO(TeaModel):
    def __init__(
        self,
        l_0: int = None,
        l_1: int = None,
        l_2: int = None,
    ):
        # l0
        self.l_0 = l_0
        # l1
        self.l_1 = l_1
        # l2
        self.l_2 = l_2

    def validate(self):
        self.validate_required(self.l_0, 'l_0')
        self.validate_required(self.l_1, 'l_1')
        self.validate_required(self.l_2, 'l_2')

    def to_map(self):
        result = dict()
        if self.l_0 is not None:
            result['l0'] = self.l_0
        if self.l_1 is not None:
            result['l1'] = self.l_1
        if self.l_2 is not None:
            result['l2'] = self.l_2
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('l0') is not None:
            self.l_0 = m.get('l0')
        if m.get('l1') is not None:
            self.l_1 = m.get('l1')
        if m.get('l2') is not None:
            self.l_2 = m.get('l2')
        return self


class UserGroup(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        modifier: str = None,
        gmt_modified: int = None,
        relations: List[UserGroupRelation] = None,
        scope_global: bool = None,
        valid_scope: int = None,
        subscribe_count: int = None,
    ):
        # ID
        self.id = id
        # 通知组名称
        self.name = name
        # 最后修改人
        self.modifier = modifier
        # 最后修改时间
        self.gmt_modified = gmt_modified
        # 用户组关联关系
        self.relations = relations
        # 全局订阅
        self.scope_global = scope_global
        # 0、当前workspace有效；
        # 1、租户有效；
        self.valid_scope = valid_scope
        # 当前用户组的告警规则定阅数量
        self.subscribe_count = subscribe_count

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.modifier, 'modifier')
        self.validate_required(self.gmt_modified, 'gmt_modified')
        self.validate_required(self.relations, 'relations')
        if self.relations:
            for k in self.relations:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        result['relations'] = []
        if self.relations is not None:
            for k in self.relations:
                result['relations'].append(k.to_map() if k else None)
        if self.scope_global is not None:
            result['scope_global'] = self.scope_global
        if self.valid_scope is not None:
            result['valid_scope'] = self.valid_scope
        if self.subscribe_count is not None:
            result['subscribe_count'] = self.subscribe_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        self.relations = []
        if m.get('relations') is not None:
            for k in m.get('relations'):
                temp_model = UserGroupRelation()
                self.relations.append(temp_model.from_map(k))
        if m.get('scope_global') is not None:
            self.scope_global = m.get('scope_global')
        if m.get('valid_scope') is not None:
            self.valid_scope = m.get('valid_scope')
        if m.get('subscribe_count') is not None:
            self.subscribe_count = m.get('subscribe_count')
        return self


class PageQuery(TeaModel):
    def __init__(
        self,
        page_size: int = None,
        page_index: int = None,
        cur_index: int = None,
    ):
        # page_size
        self.page_size = page_size
        # page_index
        self.page_index = page_index
        # cur_index
        self.cur_index = cur_index

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.page_index, 'page_index')
        self.validate_required(self.cur_index, 'cur_index')

    def to_map(self):
        result = dict()
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.page_index is not None:
            result['page_index'] = self.page_index
        if self.cur_index is not None:
            result['cur_index'] = self.cur_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('page_index') is not None:
            self.page_index = m.get('page_index')
        if m.get('cur_index') is not None:
            self.cur_index = m.get('cur_index')
        return self


class XTableData(TeaModel):
    def __init__(
        self,
        tags: List[XStringKeyValue] = None,
        metric_values: List[XTimeMetricsValue] = None,
    ):
        # 
        self.tags = tags
        # 
        self.metric_values = metric_values

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.metric_values:
            for k in self.metric_values:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        result['metric_values'] = []
        if self.metric_values is not None:
            for k in self.metric_values:
                result['metric_values'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = XStringKeyValue()
                self.tags.append(temp_model.from_map(k))
        self.metric_values = []
        if m.get('metric_values') is not None:
            for k in m.get('metric_values'):
                temp_model = XTimeMetricsValue()
                self.metric_values.append(temp_model.from_map(k))
        return self


class UnifiedAlarmRuleVO(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        category: str = None,
        rule_config: str = None,
        level: int = None,
        step: int = None,
        pending_hit: int = None,
        recovered_hit: int = None,
        silence_time: int = None,
        time_zone: str = None,
        emergency: str = None,
        emergency_url: str = None,
        alarm_empty: int = None,
        notify_firing: int = None,
        notify_recovered: int = None,
        notify_empty: int = None,
        channels: str = None,
        notify_tpl_id: int = None,
        notify_time_filter: str = None,
        suspended_start_time: int = None,
        suspended_end_time: int = None,
        suspended_reason: str = None,
        unique_identity: str = None,
        source_id: str = None,
        status: int = None,
        deleted: int = None,
        tenant_id: int = None,
        workspace_id: int = None,
        creator: str = None,
        modifier: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        alarm_status: int = None,
        conditions_des: List[str] = None,
        alarm_type: str = None,
        alarm_url: str = None,
        data_source_name: str = None,
        alarm_target_deleted: bool = None,
    ):
        # 主键
        self.id = id
        # 告警规则名称
        self.name = name
        # 分类 用于区分pql规则和自定义规则
        self.category = category
        # 规则配置
        self.rule_config = rule_config
        # 告警等级
        self.level = level
        # 检测频率
        self.step = step
        # 触发周期
        self.pending_hit = pending_hit
        # 恢复周期
        self.recovered_hit = recovered_hit
        # 静默时间
        self.silence_time = silence_time
        # 时区
        self.time_zone = time_zone
        # 应急处理人
        self.emergency = emergency
        # 应急处理链接
        self.emergency_url = emergency_url
        # 指标无数据触发告警 是个开关 1:打开 0:关闭
        self.alarm_empty = alarm_empty
        # 告警触发时通知 1:勾选 0:不勾选
        self.notify_firing = notify_firing
        # 告警恢复时通知 1:勾选 0:不勾选
        self.notify_recovered = notify_recovered
        # 告警无数据时通知 1:勾选 0:不勾选
        self.notify_empty = notify_empty
        # 通知渠道
        self.channels = channels
        # 通知模板id
        self.notify_tpl_id = notify_tpl_id
        # 通知时间
        self.notify_time_filter = notify_time_filter
        # 暂停开始时间
        self.suspended_start_time = suspended_start_time
        # 暂停结束时间
        self.suspended_end_time = suspended_end_time
        # 暂停的原因
        self.suspended_reason = suspended_reason
        # 唯一 ID，保证迁移前后不变
        self.unique_identity = unique_identity
        # 标识告警规则迁移之前的 ID
        self.source_id = source_id
        # 启停状态 开关
        self.status = status
        # 软删除
        self.deleted = deleted
        # 租户id
        self.tenant_id = tenant_id
        # 工作空间id
        self.workspace_id = workspace_id
        # 创建人
        self.creator = creator
        # 修改人
        self.modifier = modifier
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # 告警状态
        self.alarm_status = alarm_status
        # 告警条件简介
        self.conditions_des = conditions_des
        # 告警类型
        self.alarm_type = alarm_type
        # 告警数据源跳转url
        self.alarm_url = alarm_url
        # 数据源名称
        self.data_source_name = data_source_name
        # 目标对象是否删除
        self.alarm_target_deleted = alarm_target_deleted

    def validate(self):
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.category is not None:
            result['category'] = self.category
        if self.rule_config is not None:
            result['rule_config'] = self.rule_config
        if self.level is not None:
            result['level'] = self.level
        if self.step is not None:
            result['step'] = self.step
        if self.pending_hit is not None:
            result['pending_hit'] = self.pending_hit
        if self.recovered_hit is not None:
            result['recovered_hit'] = self.recovered_hit
        if self.silence_time is not None:
            result['silence_time'] = self.silence_time
        if self.time_zone is not None:
            result['time_zone'] = self.time_zone
        if self.emergency is not None:
            result['emergency'] = self.emergency
        if self.emergency_url is not None:
            result['emergency_url'] = self.emergency_url
        if self.alarm_empty is not None:
            result['alarm_empty'] = self.alarm_empty
        if self.notify_firing is not None:
            result['notify_firing'] = self.notify_firing
        if self.notify_recovered is not None:
            result['notify_recovered'] = self.notify_recovered
        if self.notify_empty is not None:
            result['notify_empty'] = self.notify_empty
        if self.channels is not None:
            result['channels'] = self.channels
        if self.notify_tpl_id is not None:
            result['notify_tpl_id'] = self.notify_tpl_id
        if self.notify_time_filter is not None:
            result['notify_time_filter'] = self.notify_time_filter
        if self.suspended_start_time is not None:
            result['suspended_start_time'] = self.suspended_start_time
        if self.suspended_end_time is not None:
            result['suspended_end_time'] = self.suspended_end_time
        if self.suspended_reason is not None:
            result['suspended_reason'] = self.suspended_reason
        if self.unique_identity is not None:
            result['unique_identity'] = self.unique_identity
        if self.source_id is not None:
            result['source_id'] = self.source_id
        if self.status is not None:
            result['status'] = self.status
        if self.deleted is not None:
            result['deleted'] = self.deleted
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.creator is not None:
            result['creator'] = self.creator
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.alarm_status is not None:
            result['alarm_status'] = self.alarm_status
        if self.conditions_des is not None:
            result['conditions_des'] = self.conditions_des
        if self.alarm_type is not None:
            result['alarm_type'] = self.alarm_type
        if self.alarm_url is not None:
            result['alarm_url'] = self.alarm_url
        if self.data_source_name is not None:
            result['data_source_name'] = self.data_source_name
        if self.alarm_target_deleted is not None:
            result['alarm_target_deleted'] = self.alarm_target_deleted
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('rule_config') is not None:
            self.rule_config = m.get('rule_config')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('step') is not None:
            self.step = m.get('step')
        if m.get('pending_hit') is not None:
            self.pending_hit = m.get('pending_hit')
        if m.get('recovered_hit') is not None:
            self.recovered_hit = m.get('recovered_hit')
        if m.get('silence_time') is not None:
            self.silence_time = m.get('silence_time')
        if m.get('time_zone') is not None:
            self.time_zone = m.get('time_zone')
        if m.get('emergency') is not None:
            self.emergency = m.get('emergency')
        if m.get('emergency_url') is not None:
            self.emergency_url = m.get('emergency_url')
        if m.get('alarm_empty') is not None:
            self.alarm_empty = m.get('alarm_empty')
        if m.get('notify_firing') is not None:
            self.notify_firing = m.get('notify_firing')
        if m.get('notify_recovered') is not None:
            self.notify_recovered = m.get('notify_recovered')
        if m.get('notify_empty') is not None:
            self.notify_empty = m.get('notify_empty')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        if m.get('notify_tpl_id') is not None:
            self.notify_tpl_id = m.get('notify_tpl_id')
        if m.get('notify_time_filter') is not None:
            self.notify_time_filter = m.get('notify_time_filter')
        if m.get('suspended_start_time') is not None:
            self.suspended_start_time = m.get('suspended_start_time')
        if m.get('suspended_end_time') is not None:
            self.suspended_end_time = m.get('suspended_end_time')
        if m.get('suspended_reason') is not None:
            self.suspended_reason = m.get('suspended_reason')
        if m.get('unique_identity') is not None:
            self.unique_identity = m.get('unique_identity')
        if m.get('source_id') is not None:
            self.source_id = m.get('source_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('deleted') is not None:
            self.deleted = m.get('deleted')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('alarm_status') is not None:
            self.alarm_status = m.get('alarm_status')
        if m.get('conditions_des') is not None:
            self.conditions_des = m.get('conditions_des')
        if m.get('alarm_type') is not None:
            self.alarm_type = m.get('alarm_type')
        if m.get('alarm_url') is not None:
            self.alarm_url = m.get('alarm_url')
        if m.get('data_source_name') is not None:
            self.data_source_name = m.get('data_source_name')
        if m.get('alarm_target_deleted') is not None:
            self.alarm_target_deleted = m.get('alarm_target_deleted')
        return self


class MonitorUserDO(TeaModel):
    def __init__(
        self,
        login_name: str = None,
        nick_name: str = None,
        phone_num: str = None,
        real_name: str = None,
        from_aliyun: bool = None,
        super_admin: bool = None,
        super_viewer: bool = None,
        is_super: bool = None,
        id: int = None,
        identity_type: str = None,
    ):
        # 登录名
        self.login_name = login_name
        # 昵称(花名或显示名)
        self.nick_name = nick_name
        # 手机号码
        self.phone_num = phone_num
        # 真名
        self.real_name = real_name
        # 一方化标记位
        self.from_aliyun = from_aliyun
        # 是否未超级管理员
        self.super_admin = super_admin
        # 用户上的权限
        self.super_viewer = super_viewer
        # super_admin或者super_viewer
        self.is_super = is_super
        # 用户 ID
        self.id = id
        # 用户来源
        self.identity_type = identity_type

    def validate(self):
        self.validate_required(self.login_name, 'login_name')
        self.validate_required(self.nick_name, 'nick_name')
        self.validate_required(self.phone_num, 'phone_num')
        self.validate_required(self.real_name, 'real_name')
        self.validate_required(self.from_aliyun, 'from_aliyun')
        self.validate_required(self.super_admin, 'super_admin')
        self.validate_required(self.super_viewer, 'super_viewer')
        self.validate_required(self.is_super, 'is_super')
        self.validate_required(self.id, 'id')
        self.validate_required(self.identity_type, 'identity_type')

    def to_map(self):
        result = dict()
        if self.login_name is not None:
            result['login_name'] = self.login_name
        if self.nick_name is not None:
            result['nick_name'] = self.nick_name
        if self.phone_num is not None:
            result['phone_num'] = self.phone_num
        if self.real_name is not None:
            result['real_name'] = self.real_name
        if self.from_aliyun is not None:
            result['from_aliyun'] = self.from_aliyun
        if self.super_admin is not None:
            result['super_admin'] = self.super_admin
        if self.super_viewer is not None:
            result['super_viewer'] = self.super_viewer
        if self.is_super is not None:
            result['is_super'] = self.is_super
        if self.id is not None:
            result['id'] = self.id
        if self.identity_type is not None:
            result['identity_type'] = self.identity_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('login_name') is not None:
            self.login_name = m.get('login_name')
        if m.get('nick_name') is not None:
            self.nick_name = m.get('nick_name')
        if m.get('phone_num') is not None:
            self.phone_num = m.get('phone_num')
        if m.get('real_name') is not None:
            self.real_name = m.get('real_name')
        if m.get('from_aliyun') is not None:
            self.from_aliyun = m.get('from_aliyun')
        if m.get('super_admin') is not None:
            self.super_admin = m.get('super_admin')
        if m.get('super_viewer') is not None:
            self.super_viewer = m.get('super_viewer')
        if m.get('is_super') is not None:
            self.is_super = m.get('is_super')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identity_type') is not None:
            self.identity_type = m.get('identity_type')
        return self


class Workspace(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        display_name: str = None,
        tenant_id: int = None,
        outside_ws_id: str = None,
        outside_tenant_id: str = None,
    ):
        # ID
        self.id = id
        # 名称
        self.name = name
        # 展示名称
        self.display_name = display_name
        # 租户ID
        self.tenant_id = tenant_id
        # outsideWsId
        self.outside_ws_id = outside_ws_id
        # outsideTenantId
        self.outside_tenant_id = outside_tenant_id

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.outside_ws_id, 'outside_ws_id')
        self.validate_required(self.outside_tenant_id, 'outside_tenant_id')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.outside_ws_id is not None:
            result['outside_ws_id'] = self.outside_ws_id
        if self.outside_tenant_id is not None:
            result['outside_tenant_id'] = self.outside_tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('outside_ws_id') is not None:
            self.outside_ws_id = m.get('outside_ws_id')
        if m.get('outside_tenant_id') is not None:
            self.outside_tenant_id = m.get('outside_tenant_id')
        return self


class UserAuthRsp(TeaModel):
    def __init__(
        self,
        powers: List[LongListKeySet] = None,
        bd_powers: List[LongListKeySet] = None,
        w_powers: List[LongListKeySet] = None,
        t_powers: List[LongListKeySet] = None,
        super_admin: bool = None,
        super_view: bool = None,
        biz_domains: List[BizDomain] = None,
        auth_url: str = None,
    ):
        # powers
        self.powers = powers
        # bd_powers
        self.bd_powers = bd_powers
        # w_powers
        self.w_powers = w_powers
        # t_powers
        self.t_powers = t_powers
        # super_admin
        self.super_admin = super_admin
        # super_view
        self.super_view = super_view
        # biz_domains
        self.biz_domains = biz_domains
        # auth_url
        self.auth_url = auth_url

    def validate(self):
        self.validate_required(self.powers, 'powers')
        if self.powers:
            for k in self.powers:
                if k:
                    k.validate()
        self.validate_required(self.bd_powers, 'bd_powers')
        if self.bd_powers:
            for k in self.bd_powers:
                if k:
                    k.validate()
        self.validate_required(self.w_powers, 'w_powers')
        if self.w_powers:
            for k in self.w_powers:
                if k:
                    k.validate()
        self.validate_required(self.t_powers, 't_powers')
        if self.t_powers:
            for k in self.t_powers:
                if k:
                    k.validate()
        self.validate_required(self.super_admin, 'super_admin')
        self.validate_required(self.super_view, 'super_view')
        self.validate_required(self.biz_domains, 'biz_domains')
        if self.biz_domains:
            for k in self.biz_domains:
                if k:
                    k.validate()
        self.validate_required(self.auth_url, 'auth_url')

    def to_map(self):
        result = dict()
        result['powers'] = []
        if self.powers is not None:
            for k in self.powers:
                result['powers'].append(k.to_map() if k else None)
        result['bd_powers'] = []
        if self.bd_powers is not None:
            for k in self.bd_powers:
                result['bd_powers'].append(k.to_map() if k else None)
        result['w_powers'] = []
        if self.w_powers is not None:
            for k in self.w_powers:
                result['w_powers'].append(k.to_map() if k else None)
        result['t_powers'] = []
        if self.t_powers is not None:
            for k in self.t_powers:
                result['t_powers'].append(k.to_map() if k else None)
        if self.super_admin is not None:
            result['super_admin'] = self.super_admin
        if self.super_view is not None:
            result['super_view'] = self.super_view
        result['biz_domains'] = []
        if self.biz_domains is not None:
            for k in self.biz_domains:
                result['biz_domains'].append(k.to_map() if k else None)
        if self.auth_url is not None:
            result['auth_url'] = self.auth_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.powers = []
        if m.get('powers') is not None:
            for k in m.get('powers'):
                temp_model = LongListKeySet()
                self.powers.append(temp_model.from_map(k))
        self.bd_powers = []
        if m.get('bd_powers') is not None:
            for k in m.get('bd_powers'):
                temp_model = LongListKeySet()
                self.bd_powers.append(temp_model.from_map(k))
        self.w_powers = []
        if m.get('w_powers') is not None:
            for k in m.get('w_powers'):
                temp_model = LongListKeySet()
                self.w_powers.append(temp_model.from_map(k))
        self.t_powers = []
        if m.get('t_powers') is not None:
            for k in m.get('t_powers'):
                temp_model = LongListKeySet()
                self.t_powers.append(temp_model.from_map(k))
        if m.get('super_admin') is not None:
            self.super_admin = m.get('super_admin')
        if m.get('super_view') is not None:
            self.super_view = m.get('super_view')
        self.biz_domains = []
        if m.get('biz_domains') is not None:
            for k in m.get('biz_domains'):
                temp_model = BizDomain()
                self.biz_domains.append(temp_model.from_map(k))
        if m.get('auth_url') is not None:
            self.auth_url = m.get('auth_url')
        return self


class ModelTreeNode(TeaModel):
    def __init__(
        self,
        name: str = None,
        id: int = None,
        plugin_name: str = None,
        type: str = None,
    ):
        # name
        self.name = name
        # id
        self.id = id
        # plugin_name
        self.plugin_name = plugin_name
        # type
        self.type = type

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.id, 'id')
        self.validate_required(self.plugin_name, 'plugin_name')
        self.validate_required(self.type, 'type')

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.id is not None:
            result['id'] = self.id
        if self.plugin_name is not None:
            result['plugin_name'] = self.plugin_name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('plugin_name') is not None:
            self.plugin_name = m.get('plugin_name')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class FolderDO(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        parent_folder_id: str = None,
        sort_index: str = None,
        tenant_id: int = None,
        workspace_id: str = None,
        creater: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        modifier: str = None,
        alarmed: bool = None,
        top: bool = None,
    ):
        # 文件夹ID
        self.id = id
        # 文件夹名称
        self.name = name
        # 父目录 ID
        self.parent_folder_id = parent_folder_id
        # 排序号
        self.sort_index = sort_index
        # 监控租户 ID
        self.tenant_id = tenant_id
        # 监控工作空间 ID
        self.workspace_id = workspace_id
        # 创建者
        self.creater = creater
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # 修改者
        self.modifier = modifier
        # 是否告警
        self.alarmed = alarmed
        # 是否置顶
        self.top = top

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.parent_folder_id, 'parent_folder_id')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.creater, 'creater')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.gmt_modified, 'gmt_modified')
        self.validate_required(self.modifier, 'modifier')
        self.validate_required(self.alarmed, 'alarmed')
        self.validate_required(self.top, 'top')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.parent_folder_id is not None:
            result['parent_folder_id'] = self.parent_folder_id
        if self.sort_index is not None:
            result['sort_index'] = self.sort_index
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.creater is not None:
            result['creater'] = self.creater
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.alarmed is not None:
            result['alarmed'] = self.alarmed
        if self.top is not None:
            result['top'] = self.top
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_folder_id') is not None:
            self.parent_folder_id = m.get('parent_folder_id')
        if m.get('sort_index') is not None:
            self.sort_index = m.get('sort_index')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('creater') is not None:
            self.creater = m.get('creater')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('alarmed') is not None:
            self.alarmed = m.get('alarmed')
        if m.get('top') is not None:
            self.top = m.get('top')
        return self


class UnifiedAlarmSubVO(TeaModel):
    def __init__(
        self,
        id: int = None,
        alarm_rule_id: int = None,
        alarm_tpl_id: int = None,
        subscriber_type: str = None,
        subscriber: str = None,
        subscriber_name: str = None,
        tenant_id: int = None,
        workspace_id: int = None,
        creator: str = None,
        modifier: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        silence_time: int = None,
        channel: str = None,
        subscriber_source: str = None,
    ):
        # 主键
        self.id = id
        # 告警规则id
        self.alarm_rule_id = alarm_rule_id
        # 告警模板id
        self.alarm_tpl_id = alarm_tpl_id
        # 订阅者的类型
        self.subscriber_type = subscriber_type
        # 订阅者
        self.subscriber = subscriber
        # 订阅者名称
        self.subscriber_name = subscriber_name
        # 租户id
        self.tenant_id = tenant_id
        # 工作空间id
        self.workspace_id = workspace_id
        # 创建人,可以理解为当前登录用户
        self.creator = creator
        # 修改人,同creator
        self.modifier = modifier
        # 创建日期
        self.gmt_create = gmt_create
        # 修改日期
        self.gmt_modified = gmt_modified
        # 静默时间
        self.silence_time = silence_time
        # 通知渠道
        self.channel = channel
        # 订阅者来源
        self.subscriber_source = subscriber_source

    def validate(self):
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.alarm_tpl_id is not None:
            result['alarm_tpl_id'] = self.alarm_tpl_id
        if self.subscriber_type is not None:
            result['subscriber_type'] = self.subscriber_type
        if self.subscriber is not None:
            result['subscriber'] = self.subscriber
        if self.subscriber_name is not None:
            result['subscriber_name'] = self.subscriber_name
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.creator is not None:
            result['creator'] = self.creator
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.silence_time is not None:
            result['silence_time'] = self.silence_time
        if self.channel is not None:
            result['channel'] = self.channel
        if self.subscriber_source is not None:
            result['subscriber_source'] = self.subscriber_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('alarm_tpl_id') is not None:
            self.alarm_tpl_id = m.get('alarm_tpl_id')
        if m.get('subscriber_type') is not None:
            self.subscriber_type = m.get('subscriber_type')
        if m.get('subscriber') is not None:
            self.subscriber = m.get('subscriber')
        if m.get('subscriber_name') is not None:
            self.subscriber_name = m.get('subscriber_name')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('silence_time') is not None:
            self.silence_time = m.get('silence_time')
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('subscriber_source') is not None:
            self.subscriber_source = m.get('subscriber_source')
        return self


class IpFileOs(TeaModel):
    def __init__(
        self,
        error_msg: str = None,
        ip: str = None,
        next_file_id: str = None,
        next_offset: int = None,
        uuid: str = None,
    ):
        # error_msg
        self.error_msg = error_msg
        # ip
        self.ip = ip
        # next_file_id
        self.next_file_id = next_file_id
        # next_offset
        self.next_offset = next_offset
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.error_msg, 'error_msg')
        self.validate_required(self.ip, 'ip')
        self.validate_required(self.next_file_id, 'next_file_id')
        self.validate_required(self.next_offset, 'next_offset')
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.error_msg is not None:
            result['error_msg'] = self.error_msg
        if self.ip is not None:
            result['ip'] = self.ip
        if self.next_file_id is not None:
            result['next_file_id'] = self.next_file_id
        if self.next_offset is not None:
            result['next_offset'] = self.next_offset
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('error_msg') is not None:
            self.error_msg = m.get('error_msg')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('next_file_id') is not None:
            self.next_file_id = m.get('next_file_id')
        if m.get('next_offset') is not None:
            self.next_offset = m.get('next_offset')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class CustomPluginDO(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        plugin_id: int = None,
        plugin_type: str = None,
        parent_folder_id: int = None,
        creater: str = None,
        modifier: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        alarmed: bool = None,
        log: Log = None,
        save_schema: SaveSchema = None,
        opsmeta_schema: OpsmetaSchema = None,
        spm: Spm = None,
        alarm_pkgs: List[AlarmPkgDO] = None,
        black_filters: List[Filter] = None,
        white_filters: List[Filter] = None,
        ops_group_by: OpsGroupBy = None,
        cal: Cal = None,
        status: StatusDO = None,
        top_alarm: TopAlarmDO = None,
        group_by: List[Filter] = None,
        status_desc: str = None,
        dk_need: bool = None,
        dks: str = None,
        baseline_need: bool = None,
        flush_basin: bool = None,
        xflush_apps: str = None,
        script_new: str = None,
        is_open: bool = None,
        plugin_type_alias: str = None,
    ):
        # ID
        self.id = id
        # 自定义监控名称
        self.name = name
        # 监控类型id
        self.plugin_id = plugin_id
        # 监控类型
        self.plugin_type = plugin_type
        # 父级文件夹 ID
        self.parent_folder_id = parent_folder_id
        # 创建者
        self.creater = creater
        # 最后修改者
        self.modifier = modifier
        # 创建时间 - 时间戳
        self.gmt_create = gmt_create
        # 最后修改时间 - 时间戳
        self.gmt_modified = gmt_modified
        # 是否有报警
        self.alarmed = alarmed
        # 日志
        self.log = log
        # 存储信息
        self.save_schema = save_schema
        # 采集元数据过滤项
        self.opsmeta_schema = opsmeta_schema
        # 属性扩展包
        self.spm = spm
        # 告警套餐列表
        self.alarm_pkgs = alarm_pkgs
        # 日志筛选黑名单
        self.black_filters = black_filters
        # 日志筛选白名单
        self.white_filters = white_filters
        # OPS分组方式
        self.ops_group_by = ops_group_by
        # 统计方式
        self.cal = cal
        # 配置状态
        self.status = status
        # top预警
        self.top_alarm = top_alarm
        # 分组规则
        self.group_by = group_by
        # 状态描述信息
        self.status_desc = status_desc
        # 是否需要动态key
        self.dk_need = dk_need
        # 推荐的动态key列表, 分号间隔
        self.dks = dks
        # 是否需要大盘显示基线
        self.baseline_need = baseline_need
        # 是否需要快速刷入实时缓存
        self.flush_basin = flush_basin
        # 所属应用
        self.xflush_apps = xflush_apps
        # script (JSON String格式)
        self.script_new = script_new
        # 是否开启
        self.is_open = is_open
        # 插件类型别名
        self.plugin_type_alias = plugin_type_alias

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.plugin_type, 'plugin_type')
        self.validate_required(self.parent_folder_id, 'parent_folder_id')
        if self.log:
            self.log.validate()
        if self.save_schema:
            self.save_schema.validate()
        if self.opsmeta_schema:
            self.opsmeta_schema.validate()
        if self.spm:
            self.spm.validate()
        if self.alarm_pkgs:
            for k in self.alarm_pkgs:
                if k:
                    k.validate()
        if self.black_filters:
            for k in self.black_filters:
                if k:
                    k.validate()
        if self.white_filters:
            for k in self.white_filters:
                if k:
                    k.validate()
        if self.ops_group_by:
            self.ops_group_by.validate()
        if self.cal:
            self.cal.validate()
        if self.status:
            self.status.validate()
        if self.top_alarm:
            self.top_alarm.validate()
        if self.group_by:
            for k in self.group_by:
                if k:
                    k.validate()
        self.validate_required(self.plugin_type_alias, 'plugin_type_alias')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.plugin_type is not None:
            result['plugin_type'] = self.plugin_type
        if self.parent_folder_id is not None:
            result['parent_folder_id'] = self.parent_folder_id
        if self.creater is not None:
            result['creater'] = self.creater
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.alarmed is not None:
            result['alarmed'] = self.alarmed
        if self.log is not None:
            result['log'] = self.log.to_map()
        if self.save_schema is not None:
            result['save_schema'] = self.save_schema.to_map()
        if self.opsmeta_schema is not None:
            result['opsmeta_schema'] = self.opsmeta_schema.to_map()
        if self.spm is not None:
            result['spm'] = self.spm.to_map()
        result['alarm_pkgs'] = []
        if self.alarm_pkgs is not None:
            for k in self.alarm_pkgs:
                result['alarm_pkgs'].append(k.to_map() if k else None)
        result['black_filters'] = []
        if self.black_filters is not None:
            for k in self.black_filters:
                result['black_filters'].append(k.to_map() if k else None)
        result['white_filters'] = []
        if self.white_filters is not None:
            for k in self.white_filters:
                result['white_filters'].append(k.to_map() if k else None)
        if self.ops_group_by is not None:
            result['ops_group_by'] = self.ops_group_by.to_map()
        if self.cal is not None:
            result['cal'] = self.cal.to_map()
        if self.status is not None:
            result['status'] = self.status.to_map()
        if self.top_alarm is not None:
            result['top_alarm'] = self.top_alarm.to_map()
        result['group_by'] = []
        if self.group_by is not None:
            for k in self.group_by:
                result['group_by'].append(k.to_map() if k else None)
        if self.status_desc is not None:
            result['status_desc'] = self.status_desc
        if self.dk_need is not None:
            result['dk_need'] = self.dk_need
        if self.dks is not None:
            result['dks'] = self.dks
        if self.baseline_need is not None:
            result['baseline_need'] = self.baseline_need
        if self.flush_basin is not None:
            result['flush_basin'] = self.flush_basin
        if self.xflush_apps is not None:
            result['xflush_apps'] = self.xflush_apps
        if self.script_new is not None:
            result['script_new'] = self.script_new
        if self.is_open is not None:
            result['is_open'] = self.is_open
        if self.plugin_type_alias is not None:
            result['plugin_type_alias'] = self.plugin_type_alias
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('plugin_type') is not None:
            self.plugin_type = m.get('plugin_type')
        if m.get('parent_folder_id') is not None:
            self.parent_folder_id = m.get('parent_folder_id')
        if m.get('creater') is not None:
            self.creater = m.get('creater')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('alarmed') is not None:
            self.alarmed = m.get('alarmed')
        if m.get('log') is not None:
            temp_model = Log()
            self.log = temp_model.from_map(m['log'])
        if m.get('save_schema') is not None:
            temp_model = SaveSchema()
            self.save_schema = temp_model.from_map(m['save_schema'])
        if m.get('opsmeta_schema') is not None:
            temp_model = OpsmetaSchema()
            self.opsmeta_schema = temp_model.from_map(m['opsmeta_schema'])
        if m.get('spm') is not None:
            temp_model = Spm()
            self.spm = temp_model.from_map(m['spm'])
        self.alarm_pkgs = []
        if m.get('alarm_pkgs') is not None:
            for k in m.get('alarm_pkgs'):
                temp_model = AlarmPkgDO()
                self.alarm_pkgs.append(temp_model.from_map(k))
        self.black_filters = []
        if m.get('black_filters') is not None:
            for k in m.get('black_filters'):
                temp_model = Filter()
                self.black_filters.append(temp_model.from_map(k))
        self.white_filters = []
        if m.get('white_filters') is not None:
            for k in m.get('white_filters'):
                temp_model = Filter()
                self.white_filters.append(temp_model.from_map(k))
        if m.get('ops_group_by') is not None:
            temp_model = OpsGroupBy()
            self.ops_group_by = temp_model.from_map(m['ops_group_by'])
        if m.get('cal') is not None:
            temp_model = Cal()
            self.cal = temp_model.from_map(m['cal'])
        if m.get('status') is not None:
            temp_model = StatusDO()
            self.status = temp_model.from_map(m['status'])
        if m.get('top_alarm') is not None:
            temp_model = TopAlarmDO()
            self.top_alarm = temp_model.from_map(m['top_alarm'])
        self.group_by = []
        if m.get('group_by') is not None:
            for k in m.get('group_by'):
                temp_model = Filter()
                self.group_by.append(temp_model.from_map(k))
        if m.get('status_desc') is not None:
            self.status_desc = m.get('status_desc')
        if m.get('dk_need') is not None:
            self.dk_need = m.get('dk_need')
        if m.get('dks') is not None:
            self.dks = m.get('dks')
        if m.get('baseline_need') is not None:
            self.baseline_need = m.get('baseline_need')
        if m.get('flush_basin') is not None:
            self.flush_basin = m.get('flush_basin')
        if m.get('xflush_apps') is not None:
            self.xflush_apps = m.get('xflush_apps')
        if m.get('script_new') is not None:
            self.script_new = m.get('script_new')
        if m.get('is_open') is not None:
            self.is_open = m.get('is_open')
        if m.get('plugin_type_alias') is not None:
            self.plugin_type_alias = m.get('plugin_type_alias')
        return self


class UnifiedAlarmNotifyHistoryVO(TeaModel):
    def __init__(
        self,
        id: int = None,
        alarm_history_id: int = None,
        alarm_event_id: str = None,
        alarm_rule_id: int = None,
        alarm_level: int = None,
        alarm_silence_time: int = None,
        alarm_time: int = None,
        channel: str = None,
        subscriber_type: str = None,
        subscriber: str = None,
        agg_count: int = None,
        status: int = None,
        tenant_id: int = None,
        workspace_id: int = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        notify_content: str = None,
        alarm_rule_name: str = None,
        subscriber_name: str = None,
        subscriber_source: str = None,
        alarm_status: int = None,
        alarm_type: str = None,
        alarm_url: str = None,
        data_source_name: str = None,
        alarm_target_deleted: bool = None,
        error_message: str = None,
        trace_id: str = None,
    ):
        # 主键
        self.id = id
        # 告警历史id
        self.alarm_history_id = alarm_history_id
        # 告警事件id
        self.alarm_event_id = alarm_event_id
        # 告警规则id
        self.alarm_rule_id = alarm_rule_id
        # 告警等级
        self.alarm_level = alarm_level
        # 告警静默期
        self.alarm_silence_time = alarm_silence_time
        # 告警时间
        self.alarm_time = alarm_time
        # 通知渠道
        self.channel = channel
        # 订阅人的类型
        self.subscriber_type = subscriber_type
        # 订阅人
        self.subscriber = subscriber
        # 聚合条数
        self.agg_count = agg_count
        # 通知状态
        self.status = status
        # 租户id
        self.tenant_id = tenant_id
        # 工作空间id
        self.workspace_id = workspace_id
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # 消息内容
        self.notify_content = notify_content
        # 告警规则名
        self.alarm_rule_name = alarm_rule_name
        # 订阅人
        self.subscriber_name = subscriber_name
        # 订阅者来源
        self.subscriber_source = subscriber_source
        # 告警消息的状态
        self.alarm_status = alarm_status
        # 告警类型
        self.alarm_type = alarm_type
        # 告警数据源跳转url
        self.alarm_url = alarm_url
        # 数据源名称
        self.data_source_name = data_source_name
        # 目标对象是否删除
        self.alarm_target_deleted = alarm_target_deleted
        # 描述消息发送错误原因
        self.error_message = error_message
        # 告警消息的日志跟踪字段
        self.trace_id = trace_id

    def validate(self):
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.alarm_history_id is not None:
            result['alarm_history_id'] = self.alarm_history_id
        if self.alarm_event_id is not None:
            result['alarm_event_id'] = self.alarm_event_id
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.alarm_silence_time is not None:
            result['alarm_silence_time'] = self.alarm_silence_time
        if self.alarm_time is not None:
            result['alarm_time'] = self.alarm_time
        if self.channel is not None:
            result['channel'] = self.channel
        if self.subscriber_type is not None:
            result['subscriber_type'] = self.subscriber_type
        if self.subscriber is not None:
            result['subscriber'] = self.subscriber
        if self.agg_count is not None:
            result['agg_count'] = self.agg_count
        if self.status is not None:
            result['status'] = self.status
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.notify_content is not None:
            result['notify_content'] = self.notify_content
        if self.alarm_rule_name is not None:
            result['alarm_rule_name'] = self.alarm_rule_name
        if self.subscriber_name is not None:
            result['subscriber_name'] = self.subscriber_name
        if self.subscriber_source is not None:
            result['subscriber_source'] = self.subscriber_source
        if self.alarm_status is not None:
            result['alarm_status'] = self.alarm_status
        if self.alarm_type is not None:
            result['alarm_type'] = self.alarm_type
        if self.alarm_url is not None:
            result['alarm_url'] = self.alarm_url
        if self.data_source_name is not None:
            result['data_source_name'] = self.data_source_name
        if self.alarm_target_deleted is not None:
            result['alarm_target_deleted'] = self.alarm_target_deleted
        if self.error_message is not None:
            result['error_message'] = self.error_message
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('alarm_history_id') is not None:
            self.alarm_history_id = m.get('alarm_history_id')
        if m.get('alarm_event_id') is not None:
            self.alarm_event_id = m.get('alarm_event_id')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('alarm_silence_time') is not None:
            self.alarm_silence_time = m.get('alarm_silence_time')
        if m.get('alarm_time') is not None:
            self.alarm_time = m.get('alarm_time')
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('subscriber_type') is not None:
            self.subscriber_type = m.get('subscriber_type')
        if m.get('subscriber') is not None:
            self.subscriber = m.get('subscriber')
        if m.get('agg_count') is not None:
            self.agg_count = m.get('agg_count')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('notify_content') is not None:
            self.notify_content = m.get('notify_content')
        if m.get('alarm_rule_name') is not None:
            self.alarm_rule_name = m.get('alarm_rule_name')
        if m.get('subscriber_name') is not None:
            self.subscriber_name = m.get('subscriber_name')
        if m.get('subscriber_source') is not None:
            self.subscriber_source = m.get('subscriber_source')
        if m.get('alarm_status') is not None:
            self.alarm_status = m.get('alarm_status')
        if m.get('alarm_type') is not None:
            self.alarm_type = m.get('alarm_type')
        if m.get('alarm_url') is not None:
            self.alarm_url = m.get('alarm_url')
        if m.get('data_source_name') is not None:
            self.data_source_name = m.get('data_source_name')
        if m.get('alarm_target_deleted') is not None:
            self.alarm_target_deleted = m.get('alarm_target_deleted')
        if m.get('error_message') is not None:
            self.error_message = m.get('error_message')
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        return self


class TraasAppDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        ancestor_app_groups: List[TraasAppGroupDto] = None,
        app_group_uuid: str = None,
        app_group_name: str = None,
        app_server_count: int = None,
    ):
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified
        # 应用所属的上层所有祖先分组
        self.ancestor_app_groups = ancestor_app_groups
        # app_group_uuid
        self.app_group_uuid = app_group_uuid
        # app_group_name
        self.app_group_name = app_group_name
        # app_server_count
        self.app_server_count = app_server_count

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.ancestor_app_groups:
            for k in self.ancestor_app_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        result['ancestor_app_groups'] = []
        if self.ancestor_app_groups is not None:
            for k in self.ancestor_app_groups:
                result['ancestor_app_groups'].append(k.to_map() if k else None)
        if self.app_group_uuid is not None:
            result['app_group_uuid'] = self.app_group_uuid
        if self.app_group_name is not None:
            result['app_group_name'] = self.app_group_name
        if self.app_server_count is not None:
            result['app_server_count'] = self.app_server_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        self.ancestor_app_groups = []
        if m.get('ancestor_app_groups') is not None:
            for k in m.get('ancestor_app_groups'):
                temp_model = TraasAppGroupDto()
                self.ancestor_app_groups.append(temp_model.from_map(k))
        if m.get('app_group_uuid') is not None:
            self.app_group_uuid = m.get('app_group_uuid')
        if m.get('app_group_name') is not None:
            self.app_group_name = m.get('app_group_name')
        if m.get('app_server_count') is not None:
            self.app_server_count = m.get('app_server_count')
        return self


class UniversalBodyCmd(TeaModel):
    def __init__(
        self,
        body: str = None,
        id: int = None,
        model_name: str = None,
        op: str = None,
        parse_long_text: bool = None,
        page_size: int = None,
        page_index: int = None,
        cur_index: int = None,
    ):
        # body
        self.body = body
        # id
        self.id = id
        # model_name
        self.model_name = model_name
        # op
        self.op = op
        # parse_long_text
        self.parse_long_text = parse_long_text
        # page_size
        self.page_size = page_size
        # page_index
        self.page_index = page_index
        # cur_index
        self.cur_index = cur_index

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.id, 'id')
        self.validate_required(self.model_name, 'model_name')
        self.validate_required(self.op, 'op')
        self.validate_required(self.parse_long_text, 'parse_long_text')
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.page_index, 'page_index')
        self.validate_required(self.cur_index, 'cur_index')

    def to_map(self):
        result = dict()
        if self.body is not None:
            result['body'] = self.body
        if self.id is not None:
            result['id'] = self.id
        if self.model_name is not None:
            result['model_name'] = self.model_name
        if self.op is not None:
            result['op'] = self.op
        if self.parse_long_text is not None:
            result['parse_long_text'] = self.parse_long_text
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.page_index is not None:
            result['page_index'] = self.page_index
        if self.cur_index is not None:
            result['cur_index'] = self.cur_index
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('model_name') is not None:
            self.model_name = m.get('model_name')
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('parse_long_text') is not None:
            self.parse_long_text = m.get('parse_long_text')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('page_index') is not None:
            self.page_index = m.get('page_index')
        if m.get('cur_index') is not None:
            self.cur_index = m.get('cur_index')
        return self


class TraceQuerySummary(TeaModel):
    def __init__(
        self,
        local_ip: List[str] = None,
        local_service_name: List[str] = None,
        remote_ip: List[str] = None,
        remote_service_name: List[str] = None,
        status: List[str] = None,
    ):
        # local endpoint ip
        self.local_ip = local_ip
        # local endpoint service name
        self.local_service_name = local_service_name
        # remote endpoint ip
        self.remote_ip = remote_ip
        # remote endpoint service name
        self.remote_service_name = remote_service_name
        # 状态
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.local_ip is not None:
            result['local_ip'] = self.local_ip
        if self.local_service_name is not None:
            result['local_service_name'] = self.local_service_name
        if self.remote_ip is not None:
            result['remote_ip'] = self.remote_ip
        if self.remote_service_name is not None:
            result['remote_service_name'] = self.remote_service_name
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('local_ip') is not None:
            self.local_ip = m.get('local_ip')
        if m.get('local_service_name') is not None:
            self.local_service_name = m.get('local_service_name')
        if m.get('remote_ip') is not None:
            self.remote_ip = m.get('remote_ip')
        if m.get('remote_service_name') is not None:
            self.remote_service_name = m.get('remote_service_name')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class FolderRequestCmd(TeaModel):
    def __init__(
        self,
        custom_plugin_id: int = None,
        folder_id: int = None,
        include_me: bool = None,
        include_plugin_name: bool = None,
    ):
        # custom_plugin_id
        self.custom_plugin_id = custom_plugin_id
        # folder_id
        self.folder_id = folder_id
        # include_me
        self.include_me = include_me
        # include_plugin_name
        self.include_plugin_name = include_plugin_name

    def validate(self):
        self.validate_required(self.custom_plugin_id, 'custom_plugin_id')
        self.validate_required(self.folder_id, 'folder_id')
        self.validate_required(self.include_me, 'include_me')
        self.validate_required(self.include_plugin_name, 'include_plugin_name')

    def to_map(self):
        result = dict()
        if self.custom_plugin_id is not None:
            result['custom_plugin_id'] = self.custom_plugin_id
        if self.folder_id is not None:
            result['folder_id'] = self.folder_id
        if self.include_me is not None:
            result['include_me'] = self.include_me
        if self.include_plugin_name is not None:
            result['include_plugin_name'] = self.include_plugin_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('custom_plugin_id') is not None:
            self.custom_plugin_id = m.get('custom_plugin_id')
        if m.get('folder_id') is not None:
            self.folder_id = m.get('folder_id')
        if m.get('include_me') is not None:
            self.include_me = m.get('include_me')
        if m.get('include_plugin_name') is not None:
            self.include_plugin_name = m.get('include_plugin_name')
        return self


class AlarmTypeStatsVOKeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: AlarmTypeStatsVO = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')
        if self.value:
            self.value.validate()

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            temp_model = AlarmTypeStatsVO()
            self.value = temp_model.from_map(m['value'])
        return self


class DingDingRobot(TeaModel):
    def __init__(
        self,
        name: str = None,
        token: str = None,
        id: int = None,
        scope_global: bool = None,
        valid_scope: int = None,
        subscribe_count: int = None,
    ):
        # 钉钉机器人名称
        self.name = name
        # 钉钉机器人token
        self.token = token
        # 钉钉机器人ID
        self.id = id
        # 是否全局有效
        self.scope_global = scope_global
        # 订阅类型：0、当前workspace有效； 1、当前租户有效
        self.valid_scope = valid_scope
        # 订阅告警规则数量
        self.subscribe_count = subscribe_count

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.token, 'token')

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.token is not None:
            result['token'] = self.token
        if self.id is not None:
            result['id'] = self.id
        if self.scope_global is not None:
            result['scope_global'] = self.scope_global
        if self.valid_scope is not None:
            result['valid_scope'] = self.valid_scope
        if self.subscribe_count is not None:
            result['subscribe_count'] = self.subscribe_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('token') is not None:
            self.token = m.get('token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('scope_global') is not None:
            self.scope_global = m.get('scope_global')
        if m.get('valid_scope') is not None:
            self.valid_scope = m.get('valid_scope')
        if m.get('subscribe_count') is not None:
            self.subscribe_count = m.get('subscribe_count')
        return self


class AgentInstance(TeaModel):
    def __init__(
        self,
        version: str = None,
        collect_id: str = None,
        app_name: str = None,
        ip: str = None,
        hostname: str = None,
        tenant_id: int = None,
        workspace_id: int = None,
        status: int = None,
        deploy_type: str = None,
        extra_info: str = None,
        gmt_modified: int = None,
        label: int = None,
    ):
        # agent版本
        self.version = version
        # agent 采集对象的唯一标识符
        self.collect_id = collect_id
        # app 名称
        self.app_name = app_name
        # IP 地址
        self.ip = ip
        # hostname 名称
        self.hostname = hostname
        # 租户 ID
        self.tenant_id = tenant_id
        # 工作空间 ID
        self.workspace_id = workspace_id
        # agent 状态
        self.status = status
        # 容器/ECS
        self.deploy_type = deploy_type
        # agent 附加信息
        self.extra_info = extra_info
        # 更新时间
        self.gmt_modified = gmt_modified
        # 是否开启告警标志
        self.label = label

    def validate(self):
        self.validate_required(self.version, 'version')
        self.validate_required(self.collect_id, 'collect_id')
        self.validate_required(self.ip, 'ip')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.status, 'status')
        self.validate_required(self.deploy_type, 'deploy_type')
        self.validate_required(self.label, 'label')

    def to_map(self):
        result = dict()
        if self.version is not None:
            result['version'] = self.version
        if self.collect_id is not None:
            result['collect_id'] = self.collect_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.ip is not None:
            result['ip'] = self.ip
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.status is not None:
            result['status'] = self.status
        if self.deploy_type is not None:
            result['deploy_type'] = self.deploy_type
        if self.extra_info is not None:
            result['extra_info'] = self.extra_info
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.label is not None:
            result['label'] = self.label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('collect_id') is not None:
            self.collect_id = m.get('collect_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('deploy_type') is not None:
            self.deploy_type = m.get('deploy_type')
        if m.get('extra_info') is not None:
            self.extra_info = m.get('extra_info')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('label') is not None:
            self.label = m.get('label')
        return self


class XMetricResponse(TeaModel):
    def __init__(
        self,
        result: List[XMetricData] = None,
        result_type: str = None,
    ):
        # timeseries
        self.result = result
        # result type
        self.result_type = result_type

    def validate(self):
        self.validate_required(self.result, 'result')
        if self.result:
            for k in self.result:
                if k:
                    k.validate()
        self.validate_required(self.result_type, 'result_type')

    def to_map(self):
        result = dict()
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.result_type is not None:
            result['result_type'] = self.result_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = XMetricData()
                self.result.append(temp_model.from_map(k))
        if m.get('result_type') is not None:
            self.result_type = m.get('result_type')
        return self


class AgentVersionStrategy(TeaModel):
    def __init__(
        self,
        url: str = None,
        version: str = None,
        type: int = None,
        status: int = None,
        content: str = None,
        scope: str = None,
        scope_identity: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
    ):
        # agent 地址
        self.url = url
        # agent 版本号
        self.version = version
        # 0 容器，1经典
        self.type = type
        # 0 生效，1失效
        self.status = status
        # agent 版本内容
        self.content = content
        # 生效范围
        self.scope = scope
        # 生效范围的唯一标识
        self.scope_identity = scope_identity
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.url, 'url')
        self.validate_required(self.version, 'version')
        self.validate_required(self.type, 'type')
        self.validate_required(self.status, 'status')
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.scope_identity, 'scope_identity')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.gmt_modified, 'gmt_modified')

    def to_map(self):
        result = dict()
        if self.url is not None:
            result['url'] = self.url
        if self.version is not None:
            result['version'] = self.version
        if self.type is not None:
            result['type'] = self.type
        if self.status is not None:
            result['status'] = self.status
        if self.content is not None:
            result['content'] = self.content
        if self.scope is not None:
            result['scope'] = self.scope
        if self.scope_identity is not None:
            result['scope_identity'] = self.scope_identity
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('scope_identity') is not None:
            self.scope_identity = m.get('scope_identity')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class AlarmCountInfoKeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: AlarmCountInfo = None,
    ):
        # 键值 (时间戳字符串)
        self.key = key
        # 某一时刻对应的告警统计信息
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')
        if self.value:
            self.value.validate()

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            temp_model = AlarmCountInfo()
            self.value = temp_model.from_map(m['value'])
        return self


class CallErrorMessage(TeaModel):
    def __init__(
        self,
        error_code: str = None,
        message: str = None,
        cause: str = None,
    ):
        # error_code
        self.error_code = error_code
        # message
        self.message = message
        # cause
        self.cause = cause

    def validate(self):
        self.validate_required(self.error_code, 'error_code')
        self.validate_required(self.message, 'message')

    def to_map(self):
        result = dict()
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.message is not None:
            result['message'] = self.message
        if self.cause is not None:
            result['cause'] = self.cause
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('cause') is not None:
            self.cause = m.get('cause')
        return self


class AppStats(TeaModel):
    def __init__(
        self,
        app_list: List[str] = None,
        page_query: PageQuery = None,
    ):
        # app_list
        self.app_list = app_list
        # page_query
        self.page_query = page_query

    def validate(self):
        self.validate_required(self.app_list, 'app_list')
        self.validate_required(self.page_query, 'page_query')
        if self.page_query:
            self.page_query.validate()

    def to_map(self):
        result = dict()
        if self.app_list is not None:
            result['app_list'] = self.app_list
        if self.page_query is not None:
            result['page_query'] = self.page_query.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_list') is not None:
            self.app_list = m.get('app_list')
        if m.get('page_query') is not None:
            temp_model = PageQuery()
            self.page_query = temp_model.from_map(m['page_query'])
        return self


class AlarmOverviewDTO(TeaModel):
    def __init__(
        self,
        level_1alarm_count: int = None,
        level_2alarm_count: int = None,
        level_3alarm_count: int = None,
        alarm_sub_count: int = None,
        alarm_pkg_count: int = None,
        recent_alarms: List[AlarmHistoryDTO] = None,
    ):
        # level1_alarm_count
        self.level_1alarm_count = level_1alarm_count
        # level2_alarm_count
        self.level_2alarm_count = level_2alarm_count
        # level3_alarm_count
        self.level_3alarm_count = level_3alarm_count
        # alarm_sub_count
        self.alarm_sub_count = alarm_sub_count
        # alarm_pkg_count
        self.alarm_pkg_count = alarm_pkg_count
        # recent_alarms
        self.recent_alarms = recent_alarms

    def validate(self):
        self.validate_required(self.level_1alarm_count, 'level_1alarm_count')
        self.validate_required(self.level_2alarm_count, 'level_2alarm_count')
        self.validate_required(self.level_3alarm_count, 'level_3alarm_count')
        self.validate_required(self.alarm_sub_count, 'alarm_sub_count')
        self.validate_required(self.alarm_pkg_count, 'alarm_pkg_count')
        self.validate_required(self.recent_alarms, 'recent_alarms')
        if self.recent_alarms:
            for k in self.recent_alarms:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.level_1alarm_count is not None:
            result['level1_alarm_count'] = self.level_1alarm_count
        if self.level_2alarm_count is not None:
            result['level2_alarm_count'] = self.level_2alarm_count
        if self.level_3alarm_count is not None:
            result['level3_alarm_count'] = self.level_3alarm_count
        if self.alarm_sub_count is not None:
            result['alarm_sub_count'] = self.alarm_sub_count
        if self.alarm_pkg_count is not None:
            result['alarm_pkg_count'] = self.alarm_pkg_count
        result['recent_alarms'] = []
        if self.recent_alarms is not None:
            for k in self.recent_alarms:
                result['recent_alarms'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('level1_alarm_count') is not None:
            self.level_1alarm_count = m.get('level1_alarm_count')
        if m.get('level2_alarm_count') is not None:
            self.level_2alarm_count = m.get('level2_alarm_count')
        if m.get('level3_alarm_count') is not None:
            self.level_3alarm_count = m.get('level3_alarm_count')
        if m.get('alarm_sub_count') is not None:
            self.alarm_sub_count = m.get('alarm_sub_count')
        if m.get('alarm_pkg_count') is not None:
            self.alarm_pkg_count = m.get('alarm_pkg_count')
        self.recent_alarms = []
        if m.get('recent_alarms') is not None:
            for k in m.get('recent_alarms'):
                temp_model = AlarmHistoryDTO()
                self.recent_alarms.append(temp_model.from_map(k))
        return self


class XPrometheusData(TeaModel):
    def __init__(
        self,
        metrics: List[XExpression] = None,
        query: XPrometheusQuery = None,
    ):
        # 
        self.metrics = metrics
        # 
        self.query = query

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        if self.query:
            self.query.validate()

    def to_map(self):
        result = dict()
        result['metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['metrics'].append(k.to_map() if k else None)
        if self.query is not None:
            result['query'] = self.query.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.metrics = []
        if m.get('metrics') is not None:
            for k in m.get('metrics'):
                temp_model = XExpression()
                self.metrics.append(temp_model.from_map(k))
        if m.get('query') is not None:
            temp_model = XPrometheusQuery()
            self.query = temp_model.from_map(m['query'])
        return self


class RequestParams(TeaModel):
    def __init__(
        self,
        req_type: str = None,
        condition: Condition = None,
        dim_condition: PontusTrendRequest = None,
        tenant: str = None,
        zones: str = None,
        from_front: bool = None,
        fuzzy: bool = None,
        valid_key_count: int = None,
        can_switch: bool = None,
    ):
        # req_type
        self.req_type = req_type
        # condition
        self.condition = condition
        # dimCondition
        self.dim_condition = dim_condition
        # tenant
        self.tenant = tenant
        # zones
        self.zones = zones
        # from_front
        self.from_front = from_front
        # fuzzy
        self.fuzzy = fuzzy
        # validKeyCount
        self.valid_key_count = valid_key_count
        # can_switch
        self.can_switch = can_switch

    def validate(self):
        self.validate_required(self.req_type, 'req_type')
        self.validate_required(self.condition, 'condition')
        if self.condition:
            self.condition.validate()
        self.validate_required(self.dim_condition, 'dim_condition')
        if self.dim_condition:
            self.dim_condition.validate()
        self.validate_required(self.tenant, 'tenant')
        self.validate_required(self.zones, 'zones')
        self.validate_required(self.from_front, 'from_front')
        self.validate_required(self.fuzzy, 'fuzzy')
        self.validate_required(self.valid_key_count, 'valid_key_count')
        self.validate_required(self.can_switch, 'can_switch')

    def to_map(self):
        result = dict()
        if self.req_type is not None:
            result['req_type'] = self.req_type
        if self.condition is not None:
            result['condition'] = self.condition.to_map()
        if self.dim_condition is not None:
            result['dim_condition'] = self.dim_condition.to_map()
        if self.tenant is not None:
            result['tenant'] = self.tenant
        if self.zones is not None:
            result['zones'] = self.zones
        if self.from_front is not None:
            result['from_front'] = self.from_front
        if self.fuzzy is not None:
            result['fuzzy'] = self.fuzzy
        if self.valid_key_count is not None:
            result['valid_key_count'] = self.valid_key_count
        if self.can_switch is not None:
            result['can_switch'] = self.can_switch
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_type') is not None:
            self.req_type = m.get('req_type')
        if m.get('condition') is not None:
            temp_model = Condition()
            self.condition = temp_model.from_map(m['condition'])
        if m.get('dim_condition') is not None:
            temp_model = PontusTrendRequest()
            self.dim_condition = temp_model.from_map(m['dim_condition'])
        if m.get('tenant') is not None:
            self.tenant = m.get('tenant')
        if m.get('zones') is not None:
            self.zones = m.get('zones')
        if m.get('from_front') is not None:
            self.from_front = m.get('from_front')
        if m.get('fuzzy') is not None:
            self.fuzzy = m.get('fuzzy')
        if m.get('valid_key_count') is not None:
            self.valid_key_count = m.get('valid_key_count')
        if m.get('can_switch') is not None:
            self.can_switch = m.get('can_switch')
        return self


class AlarmAppStats(TeaModel):
    def __init__(
        self,
        app: str = None,
        alarm_level: int = None,
        count: int = None,
        stack_universal_table_id: str = None,
    ):
        # app
        self.app = app
        # alarm_level
        self.alarm_level = alarm_level
        # count
        self.count = count
        # stack_universal_table_id
        self.stack_universal_table_id = stack_universal_table_id

    def validate(self):
        self.validate_required(self.app, 'app')
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.count, 'count')
        self.validate_required(self.stack_universal_table_id, 'stack_universal_table_id')

    def to_map(self):
        result = dict()
        if self.app is not None:
            result['app'] = self.app
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.count is not None:
            result['count'] = self.count
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        return self


class TraasEntityTopoEdge(TeaModel):
    def __init__(
        self,
        source_node: TraasEntityTopoNode = None,
        target_node: TraasEntityTopoNode = None,
        relation: str = None,
    ):
        # source_node
        self.source_node = source_node
        # target_node
        self.target_node = target_node
        # relation
        self.relation = relation

    def validate(self):
        self.validate_required(self.source_node, 'source_node')
        if self.source_node:
            self.source_node.validate()
        self.validate_required(self.target_node, 'target_node')
        if self.target_node:
            self.target_node.validate()
        self.validate_required(self.relation, 'relation')

    def to_map(self):
        result = dict()
        if self.source_node is not None:
            result['source_node'] = self.source_node.to_map()
        if self.target_node is not None:
            result['target_node'] = self.target_node.to_map()
        if self.relation is not None:
            result['relation'] = self.relation
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('source_node') is not None:
            temp_model = TraasEntityTopoNode()
            self.source_node = temp_model.from_map(m['source_node'])
        if m.get('target_node') is not None:
            temp_model = TraasEntityTopoNode()
            self.target_node = temp_model.from_map(m['target_node'])
        if m.get('relation') is not None:
            self.relation = m.get('relation')
        return self


class AlarmWebHook(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        url: str = None,
        method: str = None,
        headers: List[KeySet] = None,
        params: List[KeySet] = None,
        config: List[KeySet] = None,
        body_template: str = None,
        scope_global: bool = None,
        creator: str = None,
        modifier: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        subscribe_count: int = None,
        valid_scope: int = None,
    ):
        # 主键 ID
        self.id = id
        # 名称
        self.name = name
        # url
        self.url = url
        # method (POST, GET等)
        self.method = method
        # headers
        self.headers = headers
        # params
        self.params = params
        # config
        self.config = config
        # body_template
        self.body_template = body_template
        # 是否该 scope 内全局
        self.scope_global = scope_global
        # creator
        self.creator = creator
        # modifier
        self.modifier = modifier
        # gmtCreate
        self.gmt_create = gmt_create
        # gmtModified
        self.gmt_modified = gmt_modified
        # webhook订阅的规则数量
        self.subscribe_count = subscribe_count
        # 当前租户有效还是当前workspace有效
        self.valid_scope = valid_scope

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.url, 'url')
        self.validate_required(self.method, 'method')
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()
        if self.params:
            for k in self.params:
                if k:
                    k.validate()
        if self.config:
            for k in self.config:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        if self.method is not None:
            result['method'] = self.method
        result['headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['headers'].append(k.to_map() if k else None)
        result['params'] = []
        if self.params is not None:
            for k in self.params:
                result['params'].append(k.to_map() if k else None)
        result['config'] = []
        if self.config is not None:
            for k in self.config:
                result['config'].append(k.to_map() if k else None)
        if self.body_template is not None:
            result['body_template'] = self.body_template
        if self.scope_global is not None:
            result['scope_global'] = self.scope_global
        if self.creator is not None:
            result['creator'] = self.creator
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.subscribe_count is not None:
            result['subscribe_count'] = self.subscribe_count
        if self.valid_scope is not None:
            result['valid_scope'] = self.valid_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('method') is not None:
            self.method = m.get('method')
        self.headers = []
        if m.get('headers') is not None:
            for k in m.get('headers'):
                temp_model = KeySet()
                self.headers.append(temp_model.from_map(k))
        self.params = []
        if m.get('params') is not None:
            for k in m.get('params'):
                temp_model = KeySet()
                self.params.append(temp_model.from_map(k))
        self.config = []
        if m.get('config') is not None:
            for k in m.get('config'):
                temp_model = KeySet()
                self.config.append(temp_model.from_map(k))
        if m.get('body_template') is not None:
            self.body_template = m.get('body_template')
        if m.get('scope_global') is not None:
            self.scope_global = m.get('scope_global')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('subscribe_count') is not None:
            self.subscribe_count = m.get('subscribe_count')
        if m.get('valid_scope') is not None:
            self.valid_scope = m.get('valid_scope')
        return self


class AppOverviewDTO(TeaModel):
    def __init__(
        self,
        total_app_count: int = None,
        normal_app_count: int = None,
        alarm_app_count: int = None,
        custom_plugin_count: int = None,
        alarm_rule_count: int = None,
        alarm_tpl_count: int = None,
        log_config_count: int = None,
        mem_top_apps: List[AppTopItem] = None,
        cpu_top_apps: List[AppTopItem] = None,
        disk_top_apps: List[AppTopItem] = None,
        alarm_top_apps: List[AppTopItem] = None,
        error_top_apps: List[AppTopItem] = None,
    ):
        # 应用总数
        self.total_app_count = total_app_count
        # 正常运行应用数
        self.normal_app_count = normal_app_count
        # 告警应用数
        self.alarm_app_count = alarm_app_count
        # 自定义监控配置数
        self.custom_plugin_count = custom_plugin_count
        # 告警规则配置数
        self.alarm_rule_count = alarm_rule_count
        # 告警模板配置数
        self.alarm_tpl_count = alarm_tpl_count
        # 日志路径数
        self.log_config_count = log_config_count
        # mem top排序应用
        self.mem_top_apps = mem_top_apps
        # cpu top排序应用
        self.cpu_top_apps = cpu_top_apps
        # 磁盘 top排序应用
        self.disk_top_apps = disk_top_apps
        # 告警top排序应用
        self.alarm_top_apps = alarm_top_apps
        # error top排序应用
        self.error_top_apps = error_top_apps

    def validate(self):
        self.validate_required(self.total_app_count, 'total_app_count')
        self.validate_required(self.normal_app_count, 'normal_app_count')
        self.validate_required(self.alarm_app_count, 'alarm_app_count')
        self.validate_required(self.custom_plugin_count, 'custom_plugin_count')
        self.validate_required(self.alarm_rule_count, 'alarm_rule_count')
        self.validate_required(self.alarm_tpl_count, 'alarm_tpl_count')
        self.validate_required(self.log_config_count, 'log_config_count')
        self.validate_required(self.mem_top_apps, 'mem_top_apps')
        if self.mem_top_apps:
            for k in self.mem_top_apps:
                if k:
                    k.validate()
        self.validate_required(self.cpu_top_apps, 'cpu_top_apps')
        if self.cpu_top_apps:
            for k in self.cpu_top_apps:
                if k:
                    k.validate()
        self.validate_required(self.disk_top_apps, 'disk_top_apps')
        if self.disk_top_apps:
            for k in self.disk_top_apps:
                if k:
                    k.validate()
        if self.alarm_top_apps:
            for k in self.alarm_top_apps:
                if k:
                    k.validate()
        if self.error_top_apps:
            for k in self.error_top_apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.total_app_count is not None:
            result['total_app_count'] = self.total_app_count
        if self.normal_app_count is not None:
            result['normal_app_count'] = self.normal_app_count
        if self.alarm_app_count is not None:
            result['alarm_app_count'] = self.alarm_app_count
        if self.custom_plugin_count is not None:
            result['custom_plugin_count'] = self.custom_plugin_count
        if self.alarm_rule_count is not None:
            result['alarm_rule_count'] = self.alarm_rule_count
        if self.alarm_tpl_count is not None:
            result['alarm_tpl_count'] = self.alarm_tpl_count
        if self.log_config_count is not None:
            result['log_config_count'] = self.log_config_count
        result['mem_top_apps'] = []
        if self.mem_top_apps is not None:
            for k in self.mem_top_apps:
                result['mem_top_apps'].append(k.to_map() if k else None)
        result['cpu_top_apps'] = []
        if self.cpu_top_apps is not None:
            for k in self.cpu_top_apps:
                result['cpu_top_apps'].append(k.to_map() if k else None)
        result['disk_top_apps'] = []
        if self.disk_top_apps is not None:
            for k in self.disk_top_apps:
                result['disk_top_apps'].append(k.to_map() if k else None)
        result['alarm_top_apps'] = []
        if self.alarm_top_apps is not None:
            for k in self.alarm_top_apps:
                result['alarm_top_apps'].append(k.to_map() if k else None)
        result['error_top_apps'] = []
        if self.error_top_apps is not None:
            for k in self.error_top_apps:
                result['error_top_apps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('total_app_count') is not None:
            self.total_app_count = m.get('total_app_count')
        if m.get('normal_app_count') is not None:
            self.normal_app_count = m.get('normal_app_count')
        if m.get('alarm_app_count') is not None:
            self.alarm_app_count = m.get('alarm_app_count')
        if m.get('custom_plugin_count') is not None:
            self.custom_plugin_count = m.get('custom_plugin_count')
        if m.get('alarm_rule_count') is not None:
            self.alarm_rule_count = m.get('alarm_rule_count')
        if m.get('alarm_tpl_count') is not None:
            self.alarm_tpl_count = m.get('alarm_tpl_count')
        if m.get('log_config_count') is not None:
            self.log_config_count = m.get('log_config_count')
        self.mem_top_apps = []
        if m.get('mem_top_apps') is not None:
            for k in m.get('mem_top_apps'):
                temp_model = AppTopItem()
                self.mem_top_apps.append(temp_model.from_map(k))
        self.cpu_top_apps = []
        if m.get('cpu_top_apps') is not None:
            for k in m.get('cpu_top_apps'):
                temp_model = AppTopItem()
                self.cpu_top_apps.append(temp_model.from_map(k))
        self.disk_top_apps = []
        if m.get('disk_top_apps') is not None:
            for k in m.get('disk_top_apps'):
                temp_model = AppTopItem()
                self.disk_top_apps.append(temp_model.from_map(k))
        self.alarm_top_apps = []
        if m.get('alarm_top_apps') is not None:
            for k in m.get('alarm_top_apps'):
                temp_model = AppTopItem()
                self.alarm_top_apps.append(temp_model.from_map(k))
        self.error_top_apps = []
        if m.get('error_top_apps') is not None:
            for k in m.get('error_top_apps'):
                temp_model = AppTopItem()
                self.error_top_apps.append(temp_model.from_map(k))
        return self


class AuthDO(TeaModel):
    def __init__(
        self,
        id: int = None,
        user_login_name: str = None,
        auth: str = None,
        resource_type: str = None,
        resource_id: str = None,
    ):
        # ID
        self.id = id
        # 登录名
        self.user_login_name = user_login_name
        # 权限码
        self.auth = auth
        # 权限的资源类型
        self.resource_type = resource_type
        # 权限的资源ID (如果FOLDER或CUSTOM_PLUGIN，需要自行转成Number类型)
        self.resource_id = resource_id

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.user_login_name, 'user_login_name')
        self.validate_required(self.auth, 'auth')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_id, 'resource_id')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.user_login_name is not None:
            result['user_login_name'] = self.user_login_name
        if self.auth is not None:
            result['auth'] = self.auth
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_id is not None:
            result['resource_id'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('user_login_name') is not None:
            self.user_login_name = m.get('user_login_name')
        if m.get('auth') is not None:
            self.auth = m.get('auth')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_id') is not None:
            self.resource_id = m.get('resource_id')
        return self


class EventStat(TeaModel):
    def __init__(
        self,
        alarm_time: int = None,
        alarm_level: int = None,
        count: int = None,
    ):
        # 告警时间
        self.alarm_time = alarm_time
        # 告警等级
        self.alarm_level = alarm_level
        # 告警统计数
        self.count = count

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.alarm_time is not None:
            result['alarm_time'] = self.alarm_time
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.count is not None:
            result['count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alarm_time') is not None:
            self.alarm_time = m.get('alarm_time')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('count') is not None:
            self.count = m.get('count')
        return self


class AppSetting(TeaModel):
    def __init__(
        self,
        tenant_id: int = None,
        workspace_id: int = None,
        setting: str = None,
        app_name: str = None,
        collect_enable: bool = None,
    ):
        # 租户ID
        self.tenant_id = tenant_id
        # 工作空间ID
        self.workspace_id = workspace_id
        # 配置信息
        self.setting = setting
        # 应用名称
        self.app_name = app_name
        # 应用监控是否开启采集
        self.collect_enable = collect_enable

    def validate(self):
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.collect_enable, 'collect_enable')

    def to_map(self):
        result = dict()
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.setting is not None:
            result['setting'] = self.setting
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.collect_enable is not None:
            result['collect_enable'] = self.collect_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('setting') is not None:
            self.setting = m.get('setting')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('collect_enable') is not None:
            self.collect_enable = m.get('collect_enable')
        return self


class TraceSpanSearchTagConfig(TeaModel):
    def __init__(
        self,
        key: str = None,
        name: str = None,
        multiple: bool = None,
        values: List[str] = None,
    ):
        # 字段的key
        self.key = key
        # 中文标签
        self.name = name
        # 是否支持多选
        self.multiple = multiple
        # 如果该数组非空, 那么表明用户只能从数组给定的值中进行选择, 否则意味着用户可以随意填写.
        self.values = values

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.name is not None:
            result['name'] = self.name
        if self.multiple is not None:
            result['multiple'] = self.multiple
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('multiple') is not None:
            self.multiple = m.get('multiple')
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class XSiteExport(TeaModel):
    def __init__(
        self,
        dashboards: List[XDashboardQuery] = None,
        datasources: List[XDatasourceQuery] = None,
        alerts: List[str] = None,
    ):
        # 
        self.dashboards = dashboards
        # 
        self.datasources = datasources
        # alert uuids
        self.alerts = alerts

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.datasources:
            for k in self.datasources:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        result['datasources'] = []
        if self.datasources is not None:
            for k in self.datasources:
                result['datasources'].append(k.to_map() if k else None)
        if self.alerts is not None:
            result['alerts'] = self.alerts
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = XDashboardQuery()
                self.dashboards.append(temp_model.from_map(k))
        self.datasources = []
        if m.get('datasources') is not None:
            for k in m.get('datasources'):
                temp_model = XDatasourceQuery()
                self.datasources.append(temp_model.from_map(k))
        if m.get('alerts') is not None:
            self.alerts = m.get('alerts')
        return self


class ConfigOverviewDto(TeaModel):
    def __init__(
        self,
        custom_plugin_count: int = None,
        alarm_rule_count: int = None,
        alarm_tpl_count: int = None,
    ):
        # 自定义监控配置数
        self.custom_plugin_count = custom_plugin_count
        # 告警规则配置数
        self.alarm_rule_count = alarm_rule_count
        # 告警规则配置数
        self.alarm_tpl_count = alarm_tpl_count

    def validate(self):
        self.validate_required(self.custom_plugin_count, 'custom_plugin_count')
        self.validate_required(self.alarm_rule_count, 'alarm_rule_count')
        self.validate_required(self.alarm_tpl_count, 'alarm_tpl_count')

    def to_map(self):
        result = dict()
        if self.custom_plugin_count is not None:
            result['custom_plugin_count'] = self.custom_plugin_count
        if self.alarm_rule_count is not None:
            result['alarm_rule_count'] = self.alarm_rule_count
        if self.alarm_tpl_count is not None:
            result['alarm_tpl_count'] = self.alarm_tpl_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('custom_plugin_count') is not None:
            self.custom_plugin_count = m.get('custom_plugin_count')
        if m.get('alarm_rule_count') is not None:
            self.alarm_rule_count = m.get('alarm_rule_count')
        if m.get('alarm_tpl_count') is not None:
            self.alarm_tpl_count = m.get('alarm_tpl_count')
        return self


class MonitorApp(TeaModel):
    def __init__(
        self,
        id: int = None,
        display_name: str = None,
        source_from: str = None,
        description: str = None,
        stack_universal_table_id: str = None,
    ):
        # 应用 ID
        self.id = id
        # 应用展示名称
        self.display_name = display_name
        # 来源
        self.source_from = source_from
        # 应用描述
        self.description = description
        # 拼接好的stack_universal_table_id
        self.stack_universal_table_id = stack_universal_table_id

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.description is not None:
            result['description'] = self.description
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        return self


class AppAlarmRuleCount(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        alarm_rule_count: int = None,
    ):
        # 应用名称
        self.app_name = app_name
        # 应用告警规则总数
        self.alarm_rule_count = alarm_rule_count

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.alarm_rule_count, 'alarm_rule_count')

    def to_map(self):
        result = dict()
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.alarm_rule_count is not None:
            result['alarm_rule_count'] = self.alarm_rule_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('alarm_rule_count') is not None:
            self.alarm_rule_count = m.get('alarm_rule_count')
        return self


class MtmNc(TeaModel):
    def __init__(
        self,
        id: int = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        hostname: str = None,
        ip: str = None,
        sn: str = None,
        node_group: str = None,
        cpu_num: int = None,
        mem_mega: int = None,
        disk_mega: int = None,
        idc: str = None,
        status: str = None,
        sm_name: str = None,
        collect_ip: str = None,
        idc_name: str = None,
        cluster: str = None,
    ):
        # id
        self.id = id
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # 主机名
        self.hostname = hostname
        # ip
        self.ip = ip
        # sn
        self.sn = sn
        # 分组
        self.node_group = node_group
        # cpu_num
        self.cpu_num = cpu_num
        # 内存 M
        self.mem_mega = mem_mega
        # 磁盘 M
        self.disk_mega = disk_mega
        # 物理机房
        self.idc = idc
        # 状态
        self.status = status
        # 机型
        self.sm_name = sm_name
        # 采集ip
        self.collect_ip = collect_ip
        # idc 机房
        self.idc_name = idc_name
        # sigma 集群
        self.cluster = cluster

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.gmt_modified, 'gmt_modified')
        self.validate_required(self.hostname, 'hostname')
        self.validate_required(self.ip, 'ip')
        self.validate_required(self.sn, 'sn')
        self.validate_required(self.node_group, 'node_group')
        self.validate_required(self.cpu_num, 'cpu_num')
        self.validate_required(self.mem_mega, 'mem_mega')
        self.validate_required(self.disk_mega, 'disk_mega')
        self.validate_required(self.idc, 'idc')
        self.validate_required(self.status, 'status')
        self.validate_required(self.sm_name, 'sm_name')
        self.validate_required(self.collect_ip, 'collect_ip')
        self.validate_required(self.idc_name, 'idc_name')
        self.validate_required(self.cluster, 'cluster')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.ip is not None:
            result['ip'] = self.ip
        if self.sn is not None:
            result['sn'] = self.sn
        if self.node_group is not None:
            result['node_group'] = self.node_group
        if self.cpu_num is not None:
            result['cpu_num'] = self.cpu_num
        if self.mem_mega is not None:
            result['mem_mega'] = self.mem_mega
        if self.disk_mega is not None:
            result['disk_mega'] = self.disk_mega
        if self.idc is not None:
            result['idc'] = self.idc
        if self.status is not None:
            result['status'] = self.status
        if self.sm_name is not None:
            result['sm_name'] = self.sm_name
        if self.collect_ip is not None:
            result['collect_ip'] = self.collect_ip
        if self.idc_name is not None:
            result['idc_name'] = self.idc_name
        if self.cluster is not None:
            result['cluster'] = self.cluster
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('sn') is not None:
            self.sn = m.get('sn')
        if m.get('node_group') is not None:
            self.node_group = m.get('node_group')
        if m.get('cpu_num') is not None:
            self.cpu_num = m.get('cpu_num')
        if m.get('mem_mega') is not None:
            self.mem_mega = m.get('mem_mega')
        if m.get('disk_mega') is not None:
            self.disk_mega = m.get('disk_mega')
        if m.get('idc') is not None:
            self.idc = m.get('idc')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('sm_name') is not None:
            self.sm_name = m.get('sm_name')
        if m.get('collect_ip') is not None:
            self.collect_ip = m.get('collect_ip')
        if m.get('idc_name') is not None:
            self.idc_name = m.get('idc_name')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        return self


class XMetricQuery(TeaModel):
    def __init__(
        self,
        timeout: int = None,
        start: int = None,
        end: int = None,
        step: int = None,
        time: int = None,
        query: str = None,
        query_metadatas: List[XMetricQueryMetadata] = None,
        datasource_uuid: str = None,
        metric_name: str = None,
        table_name: str = None,
        conditions: List[XCondition] = None,
        tag: str = None,
        tenant_id: int = None,
        workspace_id: int = None,
        datasource_type: str = None,
        null_value_type: str = None,
    ):
        # 
        self.timeout = timeout
        # start timestamp
        self.start = start
        # end timestamp
        self.end = end
        # value step
        self.step = step
        # instant time
        self.time = time
        # query clause
        self.query = query
        # 
        self.query_metadatas = query_metadatas
        # 
        self.datasource_uuid = datasource_uuid
        # 
        self.metric_name = metric_name
        # 
        self.table_name = table_name
        # 
        self.conditions = conditions
        # 
        self.tag = tag
        # 
        self.tenant_id = tenant_id
        # 
        self.workspace_id = workspace_id
        # 
        self.datasource_type = datasource_type
        # 
        self.null_value_type = null_value_type

    def validate(self):
        if self.query_metadatas:
            for k in self.query_metadatas:
                if k:
                    k.validate()
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.timeout is not None:
            result['timeout'] = self.timeout
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.step is not None:
            result['step'] = self.step
        if self.time is not None:
            result['time'] = self.time
        if self.query is not None:
            result['query'] = self.query
        result['query_metadatas'] = []
        if self.query_metadatas is not None:
            for k in self.query_metadatas:
                result['query_metadatas'].append(k.to_map() if k else None)
        if self.datasource_uuid is not None:
            result['datasource_uuid'] = self.datasource_uuid
        if self.metric_name is not None:
            result['metric_name'] = self.metric_name
        if self.table_name is not None:
            result['table_name'] = self.table_name
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.tag is not None:
            result['tag'] = self.tag
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.datasource_type is not None:
            result['datasource_type'] = self.datasource_type
        if self.null_value_type is not None:
            result['null_value_type'] = self.null_value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('timeout') is not None:
            self.timeout = m.get('timeout')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('step') is not None:
            self.step = m.get('step')
        if m.get('time') is not None:
            self.time = m.get('time')
        if m.get('query') is not None:
            self.query = m.get('query')
        self.query_metadatas = []
        if m.get('query_metadatas') is not None:
            for k in m.get('query_metadatas'):
                temp_model = XMetricQueryMetadata()
                self.query_metadatas.append(temp_model.from_map(k))
        if m.get('datasource_uuid') is not None:
            self.datasource_uuid = m.get('datasource_uuid')
        if m.get('metric_name') is not None:
            self.metric_name = m.get('metric_name')
        if m.get('table_name') is not None:
            self.table_name = m.get('table_name')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = XCondition()
                self.conditions.append(temp_model.from_map(k))
        if m.get('tag') is not None:
            self.tag = m.get('tag')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('datasource_type') is not None:
            self.datasource_type = m.get('datasource_type')
        if m.get('null_value_type') is not None:
            self.null_value_type = m.get('null_value_type')
        return self


class UnifiedAlarmTplVO(TeaModel):
    def __init__(
        self,
        id: int = None,
        name: str = None,
        category: str = None,
        rule_config: str = None,
        level: int = None,
        step: int = None,
        pending_hit: int = None,
        recovered_hit: int = None,
        silence_time: int = None,
        time_zone: str = None,
        emergency: str = None,
        emergency_url: str = None,
        alarm_empty: int = None,
        notify_firing: int = None,
        notify_recovered: int = None,
        notify_empty: int = None,
        channels: str = None,
        notify_tpl_id: int = None,
        notify_time_filter: str = None,
        scope: str = None,
        scope_identity: int = None,
        alarm_sub: str = None,
        tenant_id: int = None,
        workspace_id: int = None,
        creator: str = None,
        modifier: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        status: int = None,
    ):
        # 主键
        self.id = id
        # 模板名称
        self.name = name
        # 用于区分规则模板和消息模板
        self.category = category
        # 规则配置
        self.rule_config = rule_config
        # 告警等级
        self.level = level
        # 检测频率
        self.step = step
        # 触发周期
        self.pending_hit = pending_hit
        # 恢复周期
        self.recovered_hit = recovered_hit
        # 静默时间
        self.silence_time = silence_time
        # 时区
        self.time_zone = time_zone
        # 应急处理人
        self.emergency = emergency
        # 应急处理链接
        self.emergency_url = emergency_url
        # 无数据告警 这是个开关
        self.alarm_empty = alarm_empty
        # 告警触发时通知 开关
        self.notify_firing = notify_firing
        # 告警恢复时通知 开关
        self.notify_recovered = notify_recovered
        # 告警无数据时通知 开关
        self.notify_empty = notify_empty
        # 通知渠道
        self.channels = channels
        # 通知模板id
        self.notify_tpl_id = notify_tpl_id
        # 通知时间
        self.notify_time_filter = notify_time_filter
        # 生效范围
        self.scope = scope
        # 如scope为租户 则值为tenant_id
        self.scope_identity = scope_identity
        # 订阅关系的对象
        self.alarm_sub = alarm_sub
        # 租户id
        self.tenant_id = tenant_id
        # 工作空间id
        self.workspace_id = workspace_id
        # 创建人
        self.creator = creator
        # 修改人
        self.modifier = modifier
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # 状态
        self.status = status

    def validate(self):
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.category is not None:
            result['category'] = self.category
        if self.rule_config is not None:
            result['rule_config'] = self.rule_config
        if self.level is not None:
            result['level'] = self.level
        if self.step is not None:
            result['step'] = self.step
        if self.pending_hit is not None:
            result['pending_hit'] = self.pending_hit
        if self.recovered_hit is not None:
            result['recovered_hit'] = self.recovered_hit
        if self.silence_time is not None:
            result['silence_time'] = self.silence_time
        if self.time_zone is not None:
            result['time_zone'] = self.time_zone
        if self.emergency is not None:
            result['emergency'] = self.emergency
        if self.emergency_url is not None:
            result['emergency_url'] = self.emergency_url
        if self.alarm_empty is not None:
            result['alarm_empty'] = self.alarm_empty
        if self.notify_firing is not None:
            result['notify_firing'] = self.notify_firing
        if self.notify_recovered is not None:
            result['notify_recovered'] = self.notify_recovered
        if self.notify_empty is not None:
            result['notify_empty'] = self.notify_empty
        if self.channels is not None:
            result['channels'] = self.channels
        if self.notify_tpl_id is not None:
            result['notify_tpl_id'] = self.notify_tpl_id
        if self.notify_time_filter is not None:
            result['notify_time_filter'] = self.notify_time_filter
        if self.scope is not None:
            result['scope'] = self.scope
        if self.scope_identity is not None:
            result['scope_identity'] = self.scope_identity
        if self.alarm_sub is not None:
            result['alarm_sub'] = self.alarm_sub
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.creator is not None:
            result['creator'] = self.creator
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('rule_config') is not None:
            self.rule_config = m.get('rule_config')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('step') is not None:
            self.step = m.get('step')
        if m.get('pending_hit') is not None:
            self.pending_hit = m.get('pending_hit')
        if m.get('recovered_hit') is not None:
            self.recovered_hit = m.get('recovered_hit')
        if m.get('silence_time') is not None:
            self.silence_time = m.get('silence_time')
        if m.get('time_zone') is not None:
            self.time_zone = m.get('time_zone')
        if m.get('emergency') is not None:
            self.emergency = m.get('emergency')
        if m.get('emergency_url') is not None:
            self.emergency_url = m.get('emergency_url')
        if m.get('alarm_empty') is not None:
            self.alarm_empty = m.get('alarm_empty')
        if m.get('notify_firing') is not None:
            self.notify_firing = m.get('notify_firing')
        if m.get('notify_recovered') is not None:
            self.notify_recovered = m.get('notify_recovered')
        if m.get('notify_empty') is not None:
            self.notify_empty = m.get('notify_empty')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        if m.get('notify_tpl_id') is not None:
            self.notify_tpl_id = m.get('notify_tpl_id')
        if m.get('notify_time_filter') is not None:
            self.notify_time_filter = m.get('notify_time_filter')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('scope_identity') is not None:
            self.scope_identity = m.get('scope_identity')
        if m.get('alarm_sub') is not None:
            self.alarm_sub = m.get('alarm_sub')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('creator') is not None:
            self.creator = m.get('creator')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class TraasCellDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        zone_uuid: str = None,
        zone_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # tenant_name
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # zone_uuid
        self.zone_uuid = zone_uuid
        # zone_name
        self.zone_name = zone_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.name, 'name')
        self.validate_required(self.tenant_uuid, 'tenant_uuid')
        self.validate_required(self.tenant_name, 'tenant_name')
        self.validate_required(self.workspace_uuid, 'workspace_uuid')
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.zone_uuid, 'zone_uuid')
        self.validate_required(self.zone_name, 'zone_name')
        self.validate_required(self.outside_id, 'outside_id')
        self.validate_required(self.source_from, 'source_from')
        self.validate_required(self.extension, 'extension')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class TraasAppServerDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        hostname: str = None,
        ip: str = None,
        collect_id: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        cell_uuid: str = None,
        zone_uuid: str = None,
        app_uuid: str = None,
        app_name: str = None,
        app_service_uuid: str = None,
        vm_uuid: str = None,
        pod_uuid: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        status: bool = None,
        host_ip: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # hostname
        self.hostname = hostname
        # ip
        self.ip = ip
        # collect_id
        self.collect_id = collect_id
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # cell_uuid
        self.cell_uuid = cell_uuid
        # zone_uuid
        self.zone_uuid = zone_uuid
        # app_uuid
        self.app_uuid = app_uuid
        # app_name
        self.app_name = app_name
        # app_service_uuid
        self.app_service_uuid = app_service_uuid
        # vm_uuid
        self.vm_uuid = vm_uuid
        # pod_uuid
        self.pod_uuid = pod_uuid
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # status
        self.status = status
        # host_ip
        self.host_ip = host_ip
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.hostname, 'hostname')
        self.validate_required(self.ip, 'ip')
        self.validate_required(self.collect_id, 'collect_id')
        self.validate_required(self.source_from, 'source_from')
        self.validate_required(self.status, 'status')
        self.validate_required(self.host_ip, 'host_ip')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.ip is not None:
            result['ip'] = self.ip
        if self.collect_id is not None:
            result['collect_id'] = self.collect_id
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.cell_uuid is not None:
            result['cell_uuid'] = self.cell_uuid
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.app_uuid is not None:
            result['app_uuid'] = self.app_uuid
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.app_service_uuid is not None:
            result['app_service_uuid'] = self.app_service_uuid
        if self.vm_uuid is not None:
            result['vm_uuid'] = self.vm_uuid
        if self.pod_uuid is not None:
            result['pod_uuid'] = self.pod_uuid
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.status is not None:
            result['status'] = self.status
        if self.host_ip is not None:
            result['host_ip'] = self.host_ip
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('collect_id') is not None:
            self.collect_id = m.get('collect_id')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('cell_uuid') is not None:
            self.cell_uuid = m.get('cell_uuid')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('app_uuid') is not None:
            self.app_uuid = m.get('app_uuid')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('app_service_uuid') is not None:
            self.app_service_uuid = m.get('app_service_uuid')
        if m.get('vm_uuid') is not None:
            self.vm_uuid = m.get('vm_uuid')
        if m.get('pod_uuid') is not None:
            self.pod_uuid = m.get('pod_uuid')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('host_ip') is not None:
            self.host_ip = m.get('host_ip')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class UnifiedAlarmMetric(TeaModel):
    def __init__(
        self,
        metric: str = None,
        data: List[MetricData] = None,
    ):
        # 指标
        self.metric = metric
        # 指标数据
        self.data = data

    def validate(self):
        self.validate_required(self.metric, 'metric')
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.metric is not None:
            result['metric'] = self.metric
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('metric') is not None:
            self.metric = m.get('metric')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = MetricData()
                self.data.append(temp_model.from_map(k))
        return self


class UserOplogDO(TeaModel):
    def __init__(
        self,
        id: int = None,
        table_name: str = None,
        table_entity_id: int = None,
        op_type: str = None,
        gmt_create: int = None,
        creater: str = None,
        combine_query: str = None,
        entity_type: str = None,
        name: str = None,
        op_before_context: str = None,
        op_after_context: str = None,
    ):
        # 操作记录ID
        self.id = id
        # 表名
        self.table_name = table_name
        # 表实体对应ID
        self.table_entity_id = table_entity_id
        # 操作类型(可以是CREATE、UPDATE、DELETE)
        self.op_type = op_type
        # 操作时间 (直接取日志创建时间)
        self.gmt_create = gmt_create
        # 操作人
        self.creater = creater
        # tableName+table_entity_id，方便查询
        self.combine_query = combine_query
        # 实体类型
        self.entity_type = entity_type
        # 名称
        self.name = name
        # 操作前的内容 (JSON String)
        self.op_before_context = op_before_context
        # 操作后的内容 (JSON String)
        self.op_after_context = op_after_context

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.table_name, 'table_name')
        self.validate_required(self.table_entity_id, 'table_entity_id')
        self.validate_required(self.op_type, 'op_type')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.creater, 'creater')
        self.validate_required(self.combine_query, 'combine_query')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.table_name is not None:
            result['table_name'] = self.table_name
        if self.table_entity_id is not None:
            result['table_entity_id'] = self.table_entity_id
        if self.op_type is not None:
            result['op_type'] = self.op_type
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.creater is not None:
            result['creater'] = self.creater
        if self.combine_query is not None:
            result['combine_query'] = self.combine_query
        if self.entity_type is not None:
            result['entity_type'] = self.entity_type
        if self.name is not None:
            result['name'] = self.name
        if self.op_before_context is not None:
            result['op_before_context'] = self.op_before_context
        if self.op_after_context is not None:
            result['op_after_context'] = self.op_after_context
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('table_name') is not None:
            self.table_name = m.get('table_name')
        if m.get('table_entity_id') is not None:
            self.table_entity_id = m.get('table_entity_id')
        if m.get('op_type') is not None:
            self.op_type = m.get('op_type')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('creater') is not None:
            self.creater = m.get('creater')
        if m.get('combine_query') is not None:
            self.combine_query = m.get('combine_query')
        if m.get('entity_type') is not None:
            self.entity_type = m.get('entity_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('op_before_context') is not None:
            self.op_before_context = m.get('op_before_context')
        if m.get('op_after_context') is not None:
            self.op_after_context = m.get('op_after_context')
        return self


class LongKeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: int = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class AppAlarmStats(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        count: int = None,
    ):
        # app_name
        self.app_name = app_name
        # count
        self.count = count

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.count, 'count')

    def to_map(self):
        result = dict()
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.count is not None:
            result['count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('count') is not None:
            self.count = m.get('count')
        return self


class TokenConfig(TeaModel):
    def __init__(
        self,
        token: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        last_editor: str = None,
    ):
        # token
        self.token = token
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # last_editor
        self.last_editor = last_editor

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.token is not None:
            result['token'] = self.token
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.last_editor is not None:
            result['last_editor'] = self.last_editor
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('token') is not None:
            self.token = m.get('token')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('last_editor') is not None:
            self.last_editor = m.get('last_editor')
        return self


class AlarmSubDTO(TeaModel):
    def __init__(
        self,
        id: int = None,
        display_name: str = None,
        modifier: str = None,
        gmt_modified: int = None,
        subscription_type: str = None,
        user_groups: List[UserGroup] = None,
        user_login_names: List[str] = None,
    ):
        # ID
        self.id = id
        # 告警展示名称
        self.display_name = display_name
        # 修改人
        self.modifier = modifier
        # 修改时间
        self.gmt_modified = gmt_modified
        # 告警订阅类型(folder、customplugin)
        self.subscription_type = subscription_type
        # 通知组列表
        self.user_groups = user_groups
        # 联系人登录名数组
        self.user_login_names = user_login_names

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.modifier, 'modifier')
        self.validate_required(self.gmt_modified, 'gmt_modified')
        self.validate_required(self.subscription_type, 'subscription_type')
        if self.user_groups:
            for k in self.user_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.subscription_type is not None:
            result['subscription_type'] = self.subscription_type
        result['user_groups'] = []
        if self.user_groups is not None:
            for k in self.user_groups:
                result['user_groups'].append(k.to_map() if k else None)
        if self.user_login_names is not None:
            result['user_login_names'] = self.user_login_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('subscription_type') is not None:
            self.subscription_type = m.get('subscription_type')
        self.user_groups = []
        if m.get('user_groups') is not None:
            for k in m.get('user_groups'):
                temp_model = UserGroup()
                self.user_groups.append(temp_model.from_map(k))
        if m.get('user_login_names') is not None:
            self.user_login_names = m.get('user_login_names')
        return self


class TopologyNode(TeaModel):
    def __init__(
        self,
        app: str = None,
        type: str = None,
        id: str = None,
    ):
        # 应用名
        self.app = app
        # 节点类型: APP DB MQ CACHE
        self.type = type
        # 节点id
        self.id = id

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.app is not None:
            result['app'] = self.app
        if self.type is not None:
            result['type'] = self.type
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class XSiteExportData(TeaModel):
    def __init__(
        self,
        dashboards: List[XDashboardCRULResponseCURequest] = None,
        datasources: List[XDatasourceCRULResponseCURequest] = None,
        alerts: List[UnifiedAlarmRuleVO] = None,
        stats: XSiteExportStats = None,
        alarm_rules_v2custom: str = None,
    ):
        # 
        self.dashboards = dashboards
        # 
        self.datasources = datasources
        # 
        self.alerts = alerts
        # 
        self.stats = stats
        # 自定义告警的BASE64编码
        self.alarm_rules_v2custom = alarm_rules_v2custom

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()
        if self.datasources:
            for k in self.datasources:
                if k:
                    k.validate()
        if self.alerts:
            for k in self.alerts:
                if k:
                    k.validate()
        if self.stats:
            self.stats.validate()

    def to_map(self):
        result = dict()
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        result['datasources'] = []
        if self.datasources is not None:
            for k in self.datasources:
                result['datasources'].append(k.to_map() if k else None)
        result['alerts'] = []
        if self.alerts is not None:
            for k in self.alerts:
                result['alerts'].append(k.to_map() if k else None)
        if self.stats is not None:
            result['stats'] = self.stats.to_map()
        if self.alarm_rules_v2custom is not None:
            result['alarm_rules_v2_custom'] = self.alarm_rules_v2custom
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = XDashboardCRULResponseCURequest()
                self.dashboards.append(temp_model.from_map(k))
        self.datasources = []
        if m.get('datasources') is not None:
            for k in m.get('datasources'):
                temp_model = XDatasourceCRULResponseCURequest()
                self.datasources.append(temp_model.from_map(k))
        self.alerts = []
        if m.get('alerts') is not None:
            for k in m.get('alerts'):
                temp_model = UnifiedAlarmRuleVO()
                self.alerts.append(temp_model.from_map(k))
        if m.get('stats') is not None:
            temp_model = XSiteExportStats()
            self.stats = temp_model.from_map(m['stats'])
        if m.get('alarm_rules_v2_custom') is not None:
            self.alarm_rules_v2custom = m.get('alarm_rules_v2_custom')
        return self


class AlarmHistoryListKeySetMap(TeaModel):
    def __init__(
        self,
        key: str = None,
        entity: List[AlarmHistoryListKeySet] = None,
    ):
        # key
        self.key = key
        # value
        self.entity = entity

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.entity, 'entity')
        if self.entity:
            for k in self.entity:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        result['entity'] = []
        if self.entity is not None:
            for k in self.entity:
                result['entity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        self.entity = []
        if m.get('entity') is not None:
            for k in m.get('entity'):
                temp_model = AlarmHistoryListKeySet()
                self.entity.append(temp_model.from_map(k))
        return self


class TraasHostMachineDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        hostname: str = None,
        ip: str = None,
        collect_ip: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        zone_uuid: str = None,
        zone_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # hostname
        self.hostname = hostname
        # ip
        self.ip = ip
        # collect_ip
        self.collect_ip = collect_ip
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # zone_uuid
        self.zone_uuid = zone_uuid
        # zone_name
        self.zone_name = zone_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.hostname, 'hostname')
        self.validate_required(self.ip, 'ip')
        self.validate_required(self.collect_ip, 'collect_ip')
        self.validate_required(self.source_from, 'source_from')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.ip is not None:
            result['ip'] = self.ip
        if self.collect_ip is not None:
            result['collect_ip'] = self.collect_ip
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('collect_ip') is not None:
            self.collect_ip = m.get('collect_ip')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class SiteWithDrm(TeaModel):
    def __init__(
        self,
        site_name: str = None,
        endpoint: str = None,
        ldcs: List[str] = None,
    ):
        # 站点名称
        self.site_name = site_name
        # 端点
        self.endpoint = endpoint
        # ldc
        self.ldcs = ldcs

    def validate(self):
        self.validate_required(self.site_name, 'site_name')
        self.validate_required(self.endpoint, 'endpoint')
        self.validate_required(self.ldcs, 'ldcs')

    def to_map(self):
        result = dict()
        if self.site_name is not None:
            result['site_name'] = self.site_name
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.ldcs is not None:
            result['ldcs'] = self.ldcs
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('site_name') is not None:
            self.site_name = m.get('site_name')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('ldcs') is not None:
            self.ldcs = m.get('ldcs')
        return self


class TraceTreeItem(TeaModel):
    def __init__(
        self,
        app: str = None,
        component: str = None,
        duration: int = None,
        idc_name: str = None,
        info: str = None,
        ip: str = None,
        kind: str = None,
        parent_id: str = None,
        request_size: int = None,
        response_size: int = None,
        span_id: str = None,
        start_time: int = None,
        status: str = None,
        tags: List[KeySet] = None,
        tree_id: str = None,
        tree_parent_id: str = None,
        name: str = None,
        cell_name: str = None,
        remote_app: str = None,
        remote_ip: str = None,
        remote_idc_name: str = None,
        remote_cell_name: str = None,
        missing: bool = None,
        has_children: bool = None,
    ):
        # 应用名
        self.app = app
        # 组件类型
        self.component = component
        # 耗时, 毫秒
        self.duration = duration
        # 本地应用机房信息
        self.idc_name = idc_name
        # 描述信息
        self.info = info
        # ip
        self.ip = ip
        # 对应的span的类型 枚举类型 CLIENT SERVER CONSUMER PRODUCER
        self.kind = kind
        # parent span id
        self.parent_id = parent_id
        # 请求体字节大小, 如果取不到就为-1
        self.request_size = request_size
        # 响应体大小, 如果取不到就为-1
        self.response_size = response_size
        # span id
        self.span_id = span_id
        # 开始时间, 毫秒时间戳
        self.start_time = start_time
        # 状态码，0或者00代表成功
        self.status = status
        # 键值对
        self.tags = tags
        # 节点的id, 没有业务语义, 用于帮助前端还原树状结构
        self.tree_id = tree_id
        # 父节点的id, 如果为0表示这是一个顶级节点, 没有业务语义, 用于帮助前端还原树状结构
        self.tree_parent_id = tree_parent_id
        # 方法名
        self.name = name
        # 本地应用所属单元
        self.cell_name = cell_name
        # 远端应用名
        self.remote_app = remote_app
        # 远端应用ip
        self.remote_ip = remote_ip
        # 远端应用机房信息
        self.remote_idc_name = remote_idc_name
        # 远端应用所属单元
        self.remote_cell_name = remote_cell_name
        # 代表是否本节点数据缺失
        self.missing = missing
        # 代表是否有子节点
        self.has_children = has_children

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.app is not None:
            result['app'] = self.app
        if self.component is not None:
            result['component'] = self.component
        if self.duration is not None:
            result['duration'] = self.duration
        if self.idc_name is not None:
            result['idc_name'] = self.idc_name
        if self.info is not None:
            result['info'] = self.info
        if self.ip is not None:
            result['ip'] = self.ip
        if self.kind is not None:
            result['kind'] = self.kind
        if self.parent_id is not None:
            result['parent_id'] = self.parent_id
        if self.request_size is not None:
            result['request_size'] = self.request_size
        if self.response_size is not None:
            result['response_size'] = self.response_size
        if self.span_id is not None:
            result['span_id'] = self.span_id
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.tree_id is not None:
            result['tree_id'] = self.tree_id
        if self.tree_parent_id is not None:
            result['tree_parent_id'] = self.tree_parent_id
        if self.name is not None:
            result['name'] = self.name
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.remote_app is not None:
            result['remote_app'] = self.remote_app
        if self.remote_ip is not None:
            result['remote_ip'] = self.remote_ip
        if self.remote_idc_name is not None:
            result['remote_idc_name'] = self.remote_idc_name
        if self.remote_cell_name is not None:
            result['remote_cell_name'] = self.remote_cell_name
        if self.missing is not None:
            result['missing'] = self.missing
        if self.has_children is not None:
            result['has_children'] = self.has_children
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('component') is not None:
            self.component = m.get('component')
        if m.get('duration') is not None:
            self.duration = m.get('duration')
        if m.get('idc_name') is not None:
            self.idc_name = m.get('idc_name')
        if m.get('info') is not None:
            self.info = m.get('info')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('parent_id') is not None:
            self.parent_id = m.get('parent_id')
        if m.get('request_size') is not None:
            self.request_size = m.get('request_size')
        if m.get('response_size') is not None:
            self.response_size = m.get('response_size')
        if m.get('span_id') is not None:
            self.span_id = m.get('span_id')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeySet()
                self.tags.append(temp_model.from_map(k))
        if m.get('tree_id') is not None:
            self.tree_id = m.get('tree_id')
        if m.get('tree_parent_id') is not None:
            self.tree_parent_id = m.get('tree_parent_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('remote_app') is not None:
            self.remote_app = m.get('remote_app')
        if m.get('remote_ip') is not None:
            self.remote_ip = m.get('remote_ip')
        if m.get('remote_idc_name') is not None:
            self.remote_idc_name = m.get('remote_idc_name')
        if m.get('remote_cell_name') is not None:
            self.remote_cell_name = m.get('remote_cell_name')
        if m.get('missing') is not None:
            self.missing = m.get('missing')
        if m.get('has_children') is not None:
            self.has_children = m.get('has_children')
        return self


class AgentVersion(TeaModel):
    def __init__(
        self,
        version: str = None,
        url: str = None,
    ):
        # 版本号
        self.version = version
        # 存储url
        self.url = url

    def validate(self):
        self.validate_required(self.version, 'version')
        self.validate_required(self.url, 'url')

    def to_map(self):
        result = dict()
        if self.version is not None:
            result['version'] = self.version
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class PluginModelDO(TeaModel):
    def __init__(
        self,
        id: int = None,
        parent_folder_id: int = None,
        plugin_id: int = None,
        plugin_type: str = None,
        name: str = None,
        xflush_apps: str = None,
        stack_expression: StackExpression = None,
        cal_conf: str = None,
        opsmeta_schema: OpsmetaSchema = None,
        save_schema: SaveSchema = None,
        status: StatusDO = None,
        outside_domain_id: int = None,
        old_folder_id: int = None,
        tenant_id: int = None,
        workspace_id: int = None,
        biz_domain_id: int = None,
        creater: str = None,
        gmt_create: int = None,
        modifier: str = None,
        gmt_modified: int = None,
        alarm_pkgs: List[AlarmPkgDO] = None,
        noc: str = None,
        position: str = None,
        alarmed: bool = None,
        recent_alarm_history_id: str = None,
        recent_alarm: int = None,
        key_cms: bool = None,
        key_cms_sort: int = None,
        status_desc: str = None,
        data_from: int = None,
        data_to: int = None,
        from_source: str = None,
    ):
        # id
        self.id = id
        # parent_folder_id
        self.parent_folder_id = parent_folder_id
        # plugin_id
        self.plugin_id = plugin_id
        # plugin_type
        self.plugin_type = plugin_type
        # name
        self.name = name
        # xflush_apps
        self.xflush_apps = xflush_apps
        # stack_expression
        self.stack_expression = stack_expression
        # cal_conf
        self.cal_conf = cal_conf
        # opsmeta_schema
        self.opsmeta_schema = opsmeta_schema
        # save_schema
        self.save_schema = save_schema
        # status
        self.status = status
        # outside_domain_id
        self.outside_domain_id = outside_domain_id
        # old_folder_id
        self.old_folder_id = old_folder_id
        # tenant_id
        self.tenant_id = tenant_id
        # workspace_id
        self.workspace_id = workspace_id
        # biz_domain_id
        self.biz_domain_id = biz_domain_id
        # creater
        self.creater = creater
        # gmt_create
        self.gmt_create = gmt_create
        # modifier
        self.modifier = modifier
        # gmt_modified
        self.gmt_modified = gmt_modified
        # alarm_pkgs
        self.alarm_pkgs = alarm_pkgs
        # noc
        self.noc = noc
        # position
        self.position = position
        # alarmed
        self.alarmed = alarmed
        # recent_alarm_history_id
        self.recent_alarm_history_id = recent_alarm_history_id
        # recent_alarm
        self.recent_alarm = recent_alarm
        # key_cms
        self.key_cms = key_cms
        # key_cms_sort
        self.key_cms_sort = key_cms_sort
        # status_desc
        self.status_desc = status_desc
        # data_from
        self.data_from = data_from
        # data_to
        self.data_to = data_to
        # from_source
        self.from_source = from_source

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.parent_folder_id, 'parent_folder_id')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.plugin_type, 'plugin_type')
        self.validate_required(self.name, 'name')
        self.validate_required(self.xflush_apps, 'xflush_apps')
        self.validate_required(self.stack_expression, 'stack_expression')
        if self.stack_expression:
            self.stack_expression.validate()
        self.validate_required(self.cal_conf, 'cal_conf')
        self.validate_required(self.opsmeta_schema, 'opsmeta_schema')
        if self.opsmeta_schema:
            self.opsmeta_schema.validate()
        self.validate_required(self.save_schema, 'save_schema')
        if self.save_schema:
            self.save_schema.validate()
        self.validate_required(self.status, 'status')
        if self.status:
            self.status.validate()
        self.validate_required(self.outside_domain_id, 'outside_domain_id')
        self.validate_required(self.old_folder_id, 'old_folder_id')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.biz_domain_id, 'biz_domain_id')
        self.validate_required(self.creater, 'creater')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.modifier, 'modifier')
        self.validate_required(self.gmt_modified, 'gmt_modified')
        self.validate_required(self.alarm_pkgs, 'alarm_pkgs')
        if self.alarm_pkgs:
            for k in self.alarm_pkgs:
                if k:
                    k.validate()
        self.validate_required(self.noc, 'noc')
        self.validate_required(self.position, 'position')
        self.validate_required(self.alarmed, 'alarmed')
        self.validate_required(self.recent_alarm_history_id, 'recent_alarm_history_id')
        self.validate_required(self.recent_alarm, 'recent_alarm')
        self.validate_required(self.key_cms, 'key_cms')
        self.validate_required(self.key_cms_sort, 'key_cms_sort')
        self.validate_required(self.status_desc, 'status_desc')
        self.validate_required(self.data_from, 'data_from')
        self.validate_required(self.data_to, 'data_to')
        self.validate_required(self.from_source, 'from_source')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.parent_folder_id is not None:
            result['parent_folder_id'] = self.parent_folder_id
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.plugin_type is not None:
            result['plugin_type'] = self.plugin_type
        if self.name is not None:
            result['name'] = self.name
        if self.xflush_apps is not None:
            result['xflush_apps'] = self.xflush_apps
        if self.stack_expression is not None:
            result['stack_expression'] = self.stack_expression.to_map()
        if self.cal_conf is not None:
            result['cal_conf'] = self.cal_conf
        if self.opsmeta_schema is not None:
            result['opsmeta_schema'] = self.opsmeta_schema.to_map()
        if self.save_schema is not None:
            result['save_schema'] = self.save_schema.to_map()
        if self.status is not None:
            result['status'] = self.status.to_map()
        if self.outside_domain_id is not None:
            result['outside_domain_id'] = self.outside_domain_id
        if self.old_folder_id is not None:
            result['old_folder_id'] = self.old_folder_id
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.biz_domain_id is not None:
            result['biz_domain_id'] = self.biz_domain_id
        if self.creater is not None:
            result['creater'] = self.creater
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        result['alarm_pkgs'] = []
        if self.alarm_pkgs is not None:
            for k in self.alarm_pkgs:
                result['alarm_pkgs'].append(k.to_map() if k else None)
        if self.noc is not None:
            result['noc'] = self.noc
        if self.position is not None:
            result['position'] = self.position
        if self.alarmed is not None:
            result['alarmed'] = self.alarmed
        if self.recent_alarm_history_id is not None:
            result['recent_alarm_history_id'] = self.recent_alarm_history_id
        if self.recent_alarm is not None:
            result['recent_alarm'] = self.recent_alarm
        if self.key_cms is not None:
            result['key_cms'] = self.key_cms
        if self.key_cms_sort is not None:
            result['key_cms_sort'] = self.key_cms_sort
        if self.status_desc is not None:
            result['status_desc'] = self.status_desc
        if self.data_from is not None:
            result['data_from'] = self.data_from
        if self.data_to is not None:
            result['data_to'] = self.data_to
        if self.from_source is not None:
            result['from_source'] = self.from_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('parent_folder_id') is not None:
            self.parent_folder_id = m.get('parent_folder_id')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('plugin_type') is not None:
            self.plugin_type = m.get('plugin_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('xflush_apps') is not None:
            self.xflush_apps = m.get('xflush_apps')
        if m.get('stack_expression') is not None:
            temp_model = StackExpression()
            self.stack_expression = temp_model.from_map(m['stack_expression'])
        if m.get('cal_conf') is not None:
            self.cal_conf = m.get('cal_conf')
        if m.get('opsmeta_schema') is not None:
            temp_model = OpsmetaSchema()
            self.opsmeta_schema = temp_model.from_map(m['opsmeta_schema'])
        if m.get('save_schema') is not None:
            temp_model = SaveSchema()
            self.save_schema = temp_model.from_map(m['save_schema'])
        if m.get('status') is not None:
            temp_model = StatusDO()
            self.status = temp_model.from_map(m['status'])
        if m.get('outside_domain_id') is not None:
            self.outside_domain_id = m.get('outside_domain_id')
        if m.get('old_folder_id') is not None:
            self.old_folder_id = m.get('old_folder_id')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('biz_domain_id') is not None:
            self.biz_domain_id = m.get('biz_domain_id')
        if m.get('creater') is not None:
            self.creater = m.get('creater')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        self.alarm_pkgs = []
        if m.get('alarm_pkgs') is not None:
            for k in m.get('alarm_pkgs'):
                temp_model = AlarmPkgDO()
                self.alarm_pkgs.append(temp_model.from_map(k))
        if m.get('noc') is not None:
            self.noc = m.get('noc')
        if m.get('position') is not None:
            self.position = m.get('position')
        if m.get('alarmed') is not None:
            self.alarmed = m.get('alarmed')
        if m.get('recent_alarm_history_id') is not None:
            self.recent_alarm_history_id = m.get('recent_alarm_history_id')
        if m.get('recent_alarm') is not None:
            self.recent_alarm = m.get('recent_alarm')
        if m.get('key_cms') is not None:
            self.key_cms = m.get('key_cms')
        if m.get('key_cms_sort') is not None:
            self.key_cms_sort = m.get('key_cms_sort')
        if m.get('status_desc') is not None:
            self.status_desc = m.get('status_desc')
        if m.get('data_from') is not None:
            self.data_from = m.get('data_from')
        if m.get('data_to') is not None:
            self.data_to = m.get('data_to')
        if m.get('from_source') is not None:
            self.from_source = m.get('from_source')
        return self


class TraasAppTagDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        tag_value: str = None,
        tag_key: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        app_uuid: str = None,
        app_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # tag_value
        self.tag_value = tag_value
        # tag_key
        self.tag_key = tag_key
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # app_uuid
        self.app_uuid = app_uuid
        # app_name
        self.app_name = app_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.tag_key, 'tag_key')
        self.validate_required(self.source_from, 'source_from')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.tag_value is not None:
            result['tag_value'] = self.tag_value
        if self.tag_key is not None:
            result['tag_key'] = self.tag_key
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.app_uuid is not None:
            result['app_uuid'] = self.app_uuid
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('tag_value') is not None:
            self.tag_value = m.get('tag_value')
        if m.get('tag_key') is not None:
            self.tag_key = m.get('tag_key')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('app_uuid') is not None:
            self.app_uuid = m.get('app_uuid')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class UnifiedAlarmEventVO(TeaModel):
    def __init__(
        self,
        alarm_event_id: str = None,
        alarm_content: str = None,
        alarm_level: int = None,
        status: int = None,
        alarm_target: str = None,
        alarm_start_time: str = None,
        alarm_recover_time: str = None,
        alarm_history_list: List[UnifiedAlarmHistoryVO] = None,
        alarm_history_id: int = None,
        alarm_target_type: str = None,
        alarm_type: str = None,
        alarm_url: str = None,
        data_source_name: str = None,
        alarm_target_deleted: bool = None,
        silence_remain_time: int = None,
        alarm_rule_id: int = None,
    ):
        # 告警事件id
        self.alarm_event_id = alarm_event_id
        # 告警内容
        self.alarm_content = alarm_content
        # 告警等级
        self.alarm_level = alarm_level
        # 触发状态
        self.status = status
        # 告警对象
        self.alarm_target = alarm_target
        # 告警产生时间
        self.alarm_start_time = alarm_start_time
        # 告警恢复时间
        self.alarm_recover_time = alarm_recover_time
        # 分组的告警历史集合
        self.alarm_history_list = alarm_history_list
        # 历史id
        self.alarm_history_id = alarm_history_id
        # type
        self.alarm_target_type = alarm_target_type
        # 告警类型
        self.alarm_type = alarm_type
        # 数据源跳转url
        self.alarm_url = alarm_url
        # 数据源名称
        self.data_source_name = data_source_name
        # 目标对象是否已经删除
        self.alarm_target_deleted = alarm_target_deleted
        # 静默剩余时间
        self.silence_remain_time = silence_remain_time
        # 告警规则ID
        self.alarm_rule_id = alarm_rule_id

    def validate(self):
        if self.alarm_start_time is not None:
            self.validate_pattern(self.alarm_start_time, 'alarm_start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.alarm_recover_time is not None:
            self.validate_pattern(self.alarm_recover_time, 'alarm_recover_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.alarm_history_list:
            for k in self.alarm_history_list:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.alarm_event_id is not None:
            result['alarm_event_id'] = self.alarm_event_id
        if self.alarm_content is not None:
            result['alarm_content'] = self.alarm_content
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.status is not None:
            result['status'] = self.status
        if self.alarm_target is not None:
            result['alarm_target'] = self.alarm_target
        if self.alarm_start_time is not None:
            result['alarm_start_time'] = self.alarm_start_time
        if self.alarm_recover_time is not None:
            result['alarm_recover_time'] = self.alarm_recover_time
        result['alarm_history_list'] = []
        if self.alarm_history_list is not None:
            for k in self.alarm_history_list:
                result['alarm_history_list'].append(k.to_map() if k else None)
        if self.alarm_history_id is not None:
            result['alarm_history_id'] = self.alarm_history_id
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.alarm_type is not None:
            result['alarm_type'] = self.alarm_type
        if self.alarm_url is not None:
            result['alarm_url'] = self.alarm_url
        if self.data_source_name is not None:
            result['data_source_name'] = self.data_source_name
        if self.alarm_target_deleted is not None:
            result['alarm_target_deleted'] = self.alarm_target_deleted
        if self.silence_remain_time is not None:
            result['silence_remain_time'] = self.silence_remain_time
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('alarm_event_id') is not None:
            self.alarm_event_id = m.get('alarm_event_id')
        if m.get('alarm_content') is not None:
            self.alarm_content = m.get('alarm_content')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('alarm_target') is not None:
            self.alarm_target = m.get('alarm_target')
        if m.get('alarm_start_time') is not None:
            self.alarm_start_time = m.get('alarm_start_time')
        if m.get('alarm_recover_time') is not None:
            self.alarm_recover_time = m.get('alarm_recover_time')
        self.alarm_history_list = []
        if m.get('alarm_history_list') is not None:
            for k in m.get('alarm_history_list'):
                temp_model = UnifiedAlarmHistoryVO()
                self.alarm_history_list.append(temp_model.from_map(k))
        if m.get('alarm_history_id') is not None:
            self.alarm_history_id = m.get('alarm_history_id')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('alarm_type') is not None:
            self.alarm_type = m.get('alarm_type')
        if m.get('alarm_url') is not None:
            self.alarm_url = m.get('alarm_url')
        if m.get('data_source_name') is not None:
            self.data_source_name = m.get('data_source_name')
        if m.get('alarm_target_deleted') is not None:
            self.alarm_target_deleted = m.get('alarm_target_deleted')
        if m.get('silence_remain_time') is not None:
            self.silence_remain_time = m.get('silence_remain_time')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        return self


class TraasZoneDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        region_uuid: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # region_uuid
        self.region_uuid = region_uuid
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')
        self.validate_required(self.region_uuid, 'region_uuid')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.region_uuid is not None:
            result['region_uuid'] = self.region_uuid
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('region_uuid') is not None:
            self.region_uuid = m.get('region_uuid')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class TraasTenantDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
    ):
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        return self


class XKeyJson(TeaModel):
    def __init__(
        self,
        key: str = None,
        json: str = None,
    ):
        # 
        self.key = key
        # json string
        self.json = json

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.json, 'json')

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.json is not None:
            result['json'] = self.json
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('json') is not None:
            self.json = m.get('json')
        return self


class UnifiedAlarmRuleBindingVO(TeaModel):
    def __init__(
        self,
        tenant_id: int = None,
        workspace_id: int = None,
        alarm_target_type: str = None,
        alarm_target_identity: str = None,
        alarm_rule_id: int = None,
        datasource_type: str = None,
        datasource: str = None,
        alarm_rule: UnifiedAlarmRuleVO = None,
    ):
        # 租户 ID
        self.tenant_id = tenant_id
        # 工作空间 ID
        self.workspace_id = workspace_id
        # 监控对象类型
        self.alarm_target_type = alarm_target_type
        # 监控对象名称
        self.alarm_target_identity = alarm_target_identity
        # 告警规则 ID
        self.alarm_rule_id = alarm_rule_id
        # 数据源类型
        self.datasource_type = datasource_type
        # 数据源 ID
        self.datasource = datasource
        # 告警规则详情
        self.alarm_rule = alarm_rule

    def validate(self):
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.alarm_target_type, 'alarm_target_type')
        self.validate_required(self.alarm_rule_id, 'alarm_rule_id')
        if self.alarm_rule:
            self.alarm_rule.validate()

    def to_map(self):
        result = dict()
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.alarm_target_identity is not None:
            result['alarm_target_identity'] = self.alarm_target_identity
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.datasource_type is not None:
            result['datasource_type'] = self.datasource_type
        if self.datasource is not None:
            result['datasource'] = self.datasource
        if self.alarm_rule is not None:
            result['alarm_rule'] = self.alarm_rule.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('alarm_target_identity') is not None:
            self.alarm_target_identity = m.get('alarm_target_identity')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('datasource_type') is not None:
            self.datasource_type = m.get('datasource_type')
        if m.get('datasource') is not None:
            self.datasource = m.get('datasource')
        if m.get('alarm_rule') is not None:
            temp_model = UnifiedAlarmRuleVO()
            self.alarm_rule = temp_model.from_map(m['alarm_rule'])
        return self


class TraceDetailTopologyItem(TeaModel):
    def __init__(
        self,
        tree_id: str = None,
        tree_parent_id: str = None,
        app: str = None,
        ip: str = None,
        has_client_mesh: bool = None,
        has_server_mesh: bool = None,
        idc_name: str = None,
        cell_name: str = None,
        name: str = None,
        client_start_time: int = None,
        server_start_time: int = None,
        client_duration: int = None,
        server_duration: int = None,
        client_status: str = None,
        server_status: str = None,
        client_component: str = None,
        server_component: str = None,
        status: str = None,
        apdex_threshold: str = None,
        apdex_status: str = None,
        apdex_value: str = None,
    ):
        # 节点的id, 没有业务语义, 用于帮助前端还原树状结构
        self.tree_id = tree_id
        # 父节点的id, 如果为0表示这是一个顶级节点, 没有业务语义, 用于帮助前端还原树状结构
        self.tree_parent_id = tree_parent_id
        # 应用名
        self.app = app
        # 应用ip
        self.ip = ip
        # 客户端是否经过mesh
        self.has_client_mesh = has_client_mesh
        # 服务端是否经过mesh
        self.has_server_mesh = has_server_mesh
        # 数据中心
        self.idc_name = idc_name
        # 单元名
        self.cell_name = cell_name
        # 方法名
        self.name = name
        # 客户端开始时间, 毫秒时间戳
        self.client_start_time = client_start_time
        # 服务端开始时间, 毫秒时间戳
        self.server_start_time = server_start_time
        # 客户端毫秒耗时
        self.client_duration = client_duration
        # 服务端毫秒耗时
        self.server_duration = server_duration
        # 客户端状态码
        self.client_status = client_status
        # 服务端状态码
        self.server_status = server_status
        # 客户端组件类型
        self.client_component = client_component
        # 服务端组件类型
        self.server_component = server_component
        # 整体状态码
        self.status = status
        # 健康度耗时配置
        self.apdex_threshold = apdex_threshold
        # 健康度
        self.apdex_status = apdex_status
        # 健康度数值
        self.apdex_value = apdex_value

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.tree_id is not None:
            result['tree_id'] = self.tree_id
        if self.tree_parent_id is not None:
            result['tree_parent_id'] = self.tree_parent_id
        if self.app is not None:
            result['app'] = self.app
        if self.ip is not None:
            result['ip'] = self.ip
        if self.has_client_mesh is not None:
            result['has_client_mesh'] = self.has_client_mesh
        if self.has_server_mesh is not None:
            result['has_server_mesh'] = self.has_server_mesh
        if self.idc_name is not None:
            result['idc_name'] = self.idc_name
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.name is not None:
            result['name'] = self.name
        if self.client_start_time is not None:
            result['client_start_time'] = self.client_start_time
        if self.server_start_time is not None:
            result['server_start_time'] = self.server_start_time
        if self.client_duration is not None:
            result['client_duration'] = self.client_duration
        if self.server_duration is not None:
            result['server_duration'] = self.server_duration
        if self.client_status is not None:
            result['client_status'] = self.client_status
        if self.server_status is not None:
            result['server_status'] = self.server_status
        if self.client_component is not None:
            result['client_component'] = self.client_component
        if self.server_component is not None:
            result['server_component'] = self.server_component
        if self.status is not None:
            result['status'] = self.status
        if self.apdex_threshold is not None:
            result['apdex_threshold'] = self.apdex_threshold
        if self.apdex_status is not None:
            result['apdex_status'] = self.apdex_status
        if self.apdex_value is not None:
            result['apdex_value'] = self.apdex_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tree_id') is not None:
            self.tree_id = m.get('tree_id')
        if m.get('tree_parent_id') is not None:
            self.tree_parent_id = m.get('tree_parent_id')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('has_client_mesh') is not None:
            self.has_client_mesh = m.get('has_client_mesh')
        if m.get('has_server_mesh') is not None:
            self.has_server_mesh = m.get('has_server_mesh')
        if m.get('idc_name') is not None:
            self.idc_name = m.get('idc_name')
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('client_start_time') is not None:
            self.client_start_time = m.get('client_start_time')
        if m.get('server_start_time') is not None:
            self.server_start_time = m.get('server_start_time')
        if m.get('client_duration') is not None:
            self.client_duration = m.get('client_duration')
        if m.get('server_duration') is not None:
            self.server_duration = m.get('server_duration')
        if m.get('client_status') is not None:
            self.client_status = m.get('client_status')
        if m.get('server_status') is not None:
            self.server_status = m.get('server_status')
        if m.get('client_component') is not None:
            self.client_component = m.get('client_component')
        if m.get('server_component') is not None:
            self.server_component = m.get('server_component')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('apdex_threshold') is not None:
            self.apdex_threshold = m.get('apdex_threshold')
        if m.get('apdex_status') is not None:
            self.apdex_status = m.get('apdex_status')
        if m.get('apdex_value') is not None:
            self.apdex_value = m.get('apdex_value')
        return self


class StackAlarmRule(TeaModel):
    def __init__(
        self,
        id: int = None,
        config: str = None,
        stack_id: int = None,
        stack_metric_id: int = None,
        stack_relation_id: int = None,
        stack_universal_table_id: str = None,
    ):
        # ID
        self.id = id
        # 告警套餐配置
        self.config = config
        # 栈 ID
        self.stack_id = stack_id
        # 指标 ID (如pv对应的ID)
        self.stack_metric_id = stack_metric_id
        # 关联报警relation (如果未关联，默认为-1)
        self.stack_relation_id = stack_relation_id
        # 实体对象复合 ID
        self.stack_universal_table_id = stack_universal_table_id

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.config, 'config')
        self.validate_required(self.stack_id, 'stack_id')
        self.validate_required(self.stack_metric_id, 'stack_metric_id')
        self.validate_required(self.stack_relation_id, 'stack_relation_id')
        self.validate_required(self.stack_universal_table_id, 'stack_universal_table_id')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.config is not None:
            result['config'] = self.config
        if self.stack_id is not None:
            result['stack_id'] = self.stack_id
        if self.stack_metric_id is not None:
            result['stack_metric_id'] = self.stack_metric_id
        if self.stack_relation_id is not None:
            result['stack_relation_id'] = self.stack_relation_id
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('stack_id') is not None:
            self.stack_id = m.get('stack_id')
        if m.get('stack_metric_id') is not None:
            self.stack_metric_id = m.get('stack_metric_id')
        if m.get('stack_relation_id') is not None:
            self.stack_relation_id = m.get('stack_relation_id')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        return self


class StackGeneratedConfig(TeaModel):
    def __init__(
        self,
        id: int = None,
        stack_id: int = None,
        stack_name: str = None,
        stack_version: str = None,
        stack_entity_id: int = None,
        stack_entity_name: str = None,
        stack_monitor_item_id: int = None,
        stack_monitor_item_name: str = None,
        stack_universal_table_id: str = None,
        xflush_app: str = None,
        xflush_move: bool = None,
        xflush_type: str = None,
        is_open: bool = None,
        storage_config: str = None,
        use_custom: bool = None,
        xflush_config: str = None,
    ):
        # 配置 ID
        self.id = id
        # 所属技术栈 ID
        self.stack_id = stack_id
        # 技术栈名称
        self.stack_name = stack_name
        # 技术栈版本
        self.stack_version = stack_version
        # 栈的一个实体对象 ID
        self.stack_entity_id = stack_entity_id
        # 栈的一个实体对象名称
        self.stack_entity_name = stack_entity_name
        # 实体的一个监控项 ID
        self.stack_monitor_item_id = stack_monitor_item_id
        # 实体的一个监控项名称
        self.stack_monitor_item_name = stack_monitor_item_name
        # 栈实体
        self.stack_universal_table_id = stack_universal_table_id
        # xflush应用名称
        self.xflush_app = xflush_app
        # 是否迁移过来
        self.xflush_move = xflush_move
        # xflush_type
        self.xflush_type = xflush_type
        # 是否开启
        self.is_open = is_open
        # 存储规则(JSON String, 使用前需要解析)
        self.storage_config = storage_config
        # 是否自定义
        self.use_custom = use_custom
        # xflush配置(JSON String, 使用前需要解析)
        self.xflush_config = xflush_config

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.stack_id, 'stack_id')
        self.validate_required(self.stack_name, 'stack_name')
        self.validate_required(self.stack_version, 'stack_version')
        self.validate_required(self.stack_entity_id, 'stack_entity_id')
        self.validate_required(self.stack_entity_name, 'stack_entity_name')
        self.validate_required(self.stack_monitor_item_id, 'stack_monitor_item_id')
        self.validate_required(self.stack_monitor_item_name, 'stack_monitor_item_name')
        self.validate_required(self.stack_universal_table_id, 'stack_universal_table_id')
        self.validate_required(self.xflush_app, 'xflush_app')
        self.validate_required(self.xflush_move, 'xflush_move')
        self.validate_required(self.xflush_type, 'xflush_type')
        self.validate_required(self.is_open, 'is_open')
        self.validate_required(self.storage_config, 'storage_config')
        self.validate_required(self.use_custom, 'use_custom')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.stack_id is not None:
            result['stack_id'] = self.stack_id
        if self.stack_name is not None:
            result['stack_name'] = self.stack_name
        if self.stack_version is not None:
            result['stack_version'] = self.stack_version
        if self.stack_entity_id is not None:
            result['stack_entity_id'] = self.stack_entity_id
        if self.stack_entity_name is not None:
            result['stack_entity_name'] = self.stack_entity_name
        if self.stack_monitor_item_id is not None:
            result['stack_monitor_item_id'] = self.stack_monitor_item_id
        if self.stack_monitor_item_name is not None:
            result['stack_monitor_item_name'] = self.stack_monitor_item_name
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        if self.xflush_app is not None:
            result['xflush_app'] = self.xflush_app
        if self.xflush_move is not None:
            result['xflush_move'] = self.xflush_move
        if self.xflush_type is not None:
            result['xflush_type'] = self.xflush_type
        if self.is_open is not None:
            result['is_open'] = self.is_open
        if self.storage_config is not None:
            result['storage_config'] = self.storage_config
        if self.use_custom is not None:
            result['use_custom'] = self.use_custom
        if self.xflush_config is not None:
            result['xflush_config'] = self.xflush_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('stack_id') is not None:
            self.stack_id = m.get('stack_id')
        if m.get('stack_name') is not None:
            self.stack_name = m.get('stack_name')
        if m.get('stack_version') is not None:
            self.stack_version = m.get('stack_version')
        if m.get('stack_entity_id') is not None:
            self.stack_entity_id = m.get('stack_entity_id')
        if m.get('stack_entity_name') is not None:
            self.stack_entity_name = m.get('stack_entity_name')
        if m.get('stack_monitor_item_id') is not None:
            self.stack_monitor_item_id = m.get('stack_monitor_item_id')
        if m.get('stack_monitor_item_name') is not None:
            self.stack_monitor_item_name = m.get('stack_monitor_item_name')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        if m.get('xflush_app') is not None:
            self.xflush_app = m.get('xflush_app')
        if m.get('xflush_move') is not None:
            self.xflush_move = m.get('xflush_move')
        if m.get('xflush_type') is not None:
            self.xflush_type = m.get('xflush_type')
        if m.get('is_open') is not None:
            self.is_open = m.get('is_open')
        if m.get('storage_config') is not None:
            self.storage_config = m.get('storage_config')
        if m.get('use_custom') is not None:
            self.use_custom = m.get('use_custom')
        if m.get('xflush_config') is not None:
            self.xflush_config = m.get('xflush_config')
        return self


class TraceSpanSearchDbConfig(TeaModel):
    def __init__(
        self,
        tracer_plugin_name: str = None,
        datasource_key: str = None,
        database_key: str = None,
        supported_db_types: List[str] = None,
    ):
        # tracer插件名
        self.tracer_plugin_name = tracer_plugin_name
        # 数据源tag key
        self.datasource_key = datasource_key
        # 数据库tag key
        self.database_key = database_key
        # 支持的数据库类型列表
        self.supported_db_types = supported_db_types

    def validate(self):
        self.validate_required(self.tracer_plugin_name, 'tracer_plugin_name')
        self.validate_required(self.datasource_key, 'datasource_key')
        self.validate_required(self.database_key, 'database_key')
        self.validate_required(self.supported_db_types, 'supported_db_types')

    def to_map(self):
        result = dict()
        if self.tracer_plugin_name is not None:
            result['tracer_plugin_name'] = self.tracer_plugin_name
        if self.datasource_key is not None:
            result['datasource_key'] = self.datasource_key
        if self.database_key is not None:
            result['database_key'] = self.database_key
        if self.supported_db_types is not None:
            result['supported_db_types'] = self.supported_db_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tracer_plugin_name') is not None:
            self.tracer_plugin_name = m.get('tracer_plugin_name')
        if m.get('datasource_key') is not None:
            self.datasource_key = m.get('datasource_key')
        if m.get('database_key') is not None:
            self.database_key = m.get('database_key')
        if m.get('supported_db_types') is not None:
            self.supported_db_types = m.get('supported_db_types')
        return self


class TraasWorkspaceGroupDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # uuid
        self.name = name
        # display_name
        self.display_name = display_name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class TraasEntityFieldDto(TeaModel):
    def __init__(
        self,
        name: str = None,
        display_name: str = None,
    ):
        # name
        self.name = name
        # display_name
        self.display_name = display_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        return self


class TraceWorkspaceSetting(TeaModel):
    def __init__(
        self,
        workspace_name: str = None,
        sample_enabled: bool = None,
        sample_rate: str = None,
        trace_enabled: bool = None,
        error_trace_enabled: bool = None,
        narrow_span_enabled: bool = None,
    ):
        # 工作空间名
        self.workspace_name = workspace_name
        # 是否开启采样率，false代表全采
        self.sample_enabled = sample_enabled
        # 采样率
        self.sample_rate = sample_rate
        # 是否开启链路
        self.trace_enabled = trace_enabled
        # 是否开启异常链路全采样
        self.error_trace_enabled = error_trace_enabled
        # 是否开启链路瘦身
        self.narrow_span_enabled = narrow_span_enabled

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.sample_enabled is not None:
            result['sample_enabled'] = self.sample_enabled
        if self.sample_rate is not None:
            result['sample_rate'] = self.sample_rate
        if self.trace_enabled is not None:
            result['trace_enabled'] = self.trace_enabled
        if self.error_trace_enabled is not None:
            result['error_trace_enabled'] = self.error_trace_enabled
        if self.narrow_span_enabled is not None:
            result['narrow_span_enabled'] = self.narrow_span_enabled
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('sample_enabled') is not None:
            self.sample_enabled = m.get('sample_enabled')
        if m.get('sample_rate') is not None:
            self.sample_rate = m.get('sample_rate')
        if m.get('trace_enabled') is not None:
            self.trace_enabled = m.get('trace_enabled')
        if m.get('error_trace_enabled') is not None:
            self.error_trace_enabled = m.get('error_trace_enabled')
        if m.get('narrow_span_enabled') is not None:
            self.narrow_span_enabled = m.get('narrow_span_enabled')
        return self


class TopologyEdge(TeaModel):
    def __init__(
        self,
        id: str = None,
        source: str = None,
        target: str = None,
    ):
        # id
        self.id = id
        # source节点的id
        self.source = source
        # target节点的id
        self.target = target

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.source is not None:
            result['source'] = self.source
        if self.target is not None:
            result['target'] = self.target
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('target') is not None:
            self.target = m.get('target')
        return self


class AlarmStackInfo(TeaModel):
    def __init__(
        self,
        datasource_type: str = None,
        datasource: str = None,
        alarm_target_type: str = None,
        alarm_target_identify: str = None,
    ):
        # 是应用监控，还是自定义监控
        self.datasource_type = datasource_type
        # 数据源
        self.datasource = datasource
        # 应用类型
        self.alarm_target_type = alarm_target_type
        # 应用名称
        self.alarm_target_identify = alarm_target_identify

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.datasource_type is not None:
            result['datasource_type'] = self.datasource_type
        if self.datasource is not None:
            result['datasource'] = self.datasource
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.alarm_target_identify is not None:
            result['alarm_target_identify'] = self.alarm_target_identify
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('datasource_type') is not None:
            self.datasource_type = m.get('datasource_type')
        if m.get('datasource') is not None:
            self.datasource = m.get('datasource')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('alarm_target_identify') is not None:
            self.alarm_target_identify = m.get('alarm_target_identify')
        return self


class AlarmLevelStatsVOKeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: AlarmLevelStatsVO = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')
        if self.value:
            self.value.validate()

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            temp_model = AlarmLevelStatsVO()
            self.value = temp_model.from_map(m['value'])
        return self


class AppMeta(TeaModel):
    def __init__(
        self,
        workspace_id: int = None,
        app_name: str = None,
        app_id: int = None,
    ):
        # workspace_id
        self.workspace_id = workspace_id
        # 应用名
        self.app_name = app_name
        # app_id
        self.app_id = app_id

    def validate(self):
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.app_id, 'app_id')

    def to_map(self):
        result = dict()
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.app_id is not None:
            result['app_id'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        return self


class AliyunOpenState(TeaModel):
    def __init__(
        self,
        aliyun_user_id: int = None,
        aliyun_instance_id: str = None,
        tenant_id: int = None,
        tenant_name: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        state: int = None,
    ):
        # 阿里云用户ID
        self.aliyun_user_id = aliyun_user_id
        # 阿里云实例ID
        self.aliyun_instance_id = aliyun_instance_id
        # 监控租户ID
        self.tenant_id = tenant_id
        # 监控租户名称
        self.tenant_name = tenant_name
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # 开通状态，0未开通，1开通
        self.state = state

    def validate(self):
        self.validate_required(self.aliyun_user_id, 'aliyun_user_id')
        self.validate_required(self.aliyun_instance_id, 'aliyun_instance_id')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.tenant_name, 'tenant_name')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.gmt_modified, 'gmt_modified')
        self.validate_required(self.state, 'state')

    def to_map(self):
        result = dict()
        if self.aliyun_user_id is not None:
            result['aliyun_user_id'] = self.aliyun_user_id
        if self.aliyun_instance_id is not None:
            result['aliyun_instance_id'] = self.aliyun_instance_id
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.state is not None:
            result['state'] = self.state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('aliyun_user_id') is not None:
            self.aliyun_user_id = m.get('aliyun_user_id')
        if m.get('aliyun_instance_id') is not None:
            self.aliyun_instance_id = m.get('aliyun_instance_id')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('state') is not None:
            self.state = m.get('state')
        return self


class UserFavoriteVO(TeaModel):
    def __init__(
        self,
        resource_id: str = None,
        resource_type: str = None,
        user_favorite_id: int = None,
    ):
        # 收藏资源 ID
        self.resource_id = resource_id
        # 收藏资源类型
        self.resource_type = resource_type
        # 用户收藏的 ID
        self.user_favorite_id = user_favorite_id

    def validate(self):
        self.validate_required(self.resource_id, 'resource_id')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.user_favorite_id, 'user_favorite_id')

    def to_map(self):
        result = dict()
        if self.resource_id is not None:
            result['resource_id'] = self.resource_id
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.user_favorite_id is not None:
            result['user_favorite_id'] = self.user_favorite_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('resource_id') is not None:
            self.resource_id = m.get('resource_id')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('user_favorite_id') is not None:
            self.user_favorite_id = m.get('user_favorite_id')
        return self


class TraceCompactTreeItem(TeaModel):
    def __init__(
        self,
        name: str = None,
        tree_id: str = None,
        tree_parent_id: str = None,
        client_missing: bool = None,
        server_missing: bool = None,
        has_client_mesh: bool = None,
        has_server_mesh: bool = None,
        has_children: bool = None,
        client_app: str = None,
        server_app: str = None,
        client_ip: str = None,
        server_ip: str = None,
        client_idc_name: str = None,
        server_idc_name: str = None,
        client_cell_name: str = None,
        server_cell_name: str = None,
        client_start_time: int = None,
        server_start_time: int = None,
        client_duration: int = None,
        server_duration: int = None,
        client_status: str = None,
        server_status: str = None,
        client_component: str = None,
        server_component: str = None,
        client_span: TraceSpan = None,
        server_span: TraceSpan = None,
        status: str = None,
        apdex_threshold: str = None,
        apdex_status: str = None,
    ):
        # 方法名
        self.name = name
        # 节点的id, 没有业务语义, 用于帮助前端还原树状结构
        self.tree_id = tree_id
        # 父节点的id, 如果为0表示这是一个顶级节点, 没有业务语义, 用于帮助前端还原树状结构
        self.tree_parent_id = tree_parent_id
        # 客户端span是否缺失
        self.client_missing = client_missing
        # 服务端span是否缺失
        self.server_missing = server_missing
        # 客户端是否经过mesh
        self.has_client_mesh = has_client_mesh
        # 服务端是否经过mesh
        self.has_server_mesh = has_server_mesh
        # 是否包含子节点
        self.has_children = has_children
        # 客户端应用名
        self.client_app = client_app
        # 服务端应用名
        self.server_app = server_app
        # 客户端 ip
        self.client_ip = client_ip
        # 服务端 ip
        self.server_ip = server_ip
        # 客户端 idc
        self.client_idc_name = client_idc_name
        # 服务端 idc
        self.server_idc_name = server_idc_name
        # 客户端 cell
        self.client_cell_name = client_cell_name
        # 服务端 cell
        self.server_cell_name = server_cell_name
        # 客户端开始时间, 毫秒时间戳
        self.client_start_time = client_start_time
        # 服务端开始时间, 毫秒时间戳
        self.server_start_time = server_start_time
        # 客户端毫秒耗时
        self.client_duration = client_duration
        # 服务端毫秒耗时
        self.server_duration = server_duration
        # 客户端状态码
        self.client_status = client_status
        # 服务端状态码
        self.server_status = server_status
        # 客户端组件类型
        self.client_component = client_component
        # 服务端组件类型
        self.server_component = server_component
        # 客户端span
        self.client_span = client_span
        # 服务端span
        self.server_span = server_span
        # 整体状态码
        self.status = status
        # 健康度耗时配置
        self.apdex_threshold = apdex_threshold
        # 健康度
        self.apdex_status = apdex_status

    def validate(self):
        if self.client_span:
            self.client_span.validate()
        if self.server_span:
            self.server_span.validate()

    def to_map(self):
        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.tree_id is not None:
            result['tree_id'] = self.tree_id
        if self.tree_parent_id is not None:
            result['tree_parent_id'] = self.tree_parent_id
        if self.client_missing is not None:
            result['client_missing'] = self.client_missing
        if self.server_missing is not None:
            result['server_missing'] = self.server_missing
        if self.has_client_mesh is not None:
            result['has_client_mesh'] = self.has_client_mesh
        if self.has_server_mesh is not None:
            result['has_server_mesh'] = self.has_server_mesh
        if self.has_children is not None:
            result['has_children'] = self.has_children
        if self.client_app is not None:
            result['client_app'] = self.client_app
        if self.server_app is not None:
            result['server_app'] = self.server_app
        if self.client_ip is not None:
            result['client_ip'] = self.client_ip
        if self.server_ip is not None:
            result['server_ip'] = self.server_ip
        if self.client_idc_name is not None:
            result['client_idc_name'] = self.client_idc_name
        if self.server_idc_name is not None:
            result['server_idc_name'] = self.server_idc_name
        if self.client_cell_name is not None:
            result['client_cell_name'] = self.client_cell_name
        if self.server_cell_name is not None:
            result['server_cell_name'] = self.server_cell_name
        if self.client_start_time is not None:
            result['client_start_time'] = self.client_start_time
        if self.server_start_time is not None:
            result['server_start_time'] = self.server_start_time
        if self.client_duration is not None:
            result['client_duration'] = self.client_duration
        if self.server_duration is not None:
            result['server_duration'] = self.server_duration
        if self.client_status is not None:
            result['client_status'] = self.client_status
        if self.server_status is not None:
            result['server_status'] = self.server_status
        if self.client_component is not None:
            result['client_component'] = self.client_component
        if self.server_component is not None:
            result['server_component'] = self.server_component
        if self.client_span is not None:
            result['client_span'] = self.client_span.to_map()
        if self.server_span is not None:
            result['server_span'] = self.server_span.to_map()
        if self.status is not None:
            result['status'] = self.status
        if self.apdex_threshold is not None:
            result['apdex_threshold'] = self.apdex_threshold
        if self.apdex_status is not None:
            result['apdex_status'] = self.apdex_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tree_id') is not None:
            self.tree_id = m.get('tree_id')
        if m.get('tree_parent_id') is not None:
            self.tree_parent_id = m.get('tree_parent_id')
        if m.get('client_missing') is not None:
            self.client_missing = m.get('client_missing')
        if m.get('server_missing') is not None:
            self.server_missing = m.get('server_missing')
        if m.get('has_client_mesh') is not None:
            self.has_client_mesh = m.get('has_client_mesh')
        if m.get('has_server_mesh') is not None:
            self.has_server_mesh = m.get('has_server_mesh')
        if m.get('has_children') is not None:
            self.has_children = m.get('has_children')
        if m.get('client_app') is not None:
            self.client_app = m.get('client_app')
        if m.get('server_app') is not None:
            self.server_app = m.get('server_app')
        if m.get('client_ip') is not None:
            self.client_ip = m.get('client_ip')
        if m.get('server_ip') is not None:
            self.server_ip = m.get('server_ip')
        if m.get('client_idc_name') is not None:
            self.client_idc_name = m.get('client_idc_name')
        if m.get('server_idc_name') is not None:
            self.server_idc_name = m.get('server_idc_name')
        if m.get('client_cell_name') is not None:
            self.client_cell_name = m.get('client_cell_name')
        if m.get('server_cell_name') is not None:
            self.server_cell_name = m.get('server_cell_name')
        if m.get('client_start_time') is not None:
            self.client_start_time = m.get('client_start_time')
        if m.get('server_start_time') is not None:
            self.server_start_time = m.get('server_start_time')
        if m.get('client_duration') is not None:
            self.client_duration = m.get('client_duration')
        if m.get('server_duration') is not None:
            self.server_duration = m.get('server_duration')
        if m.get('client_status') is not None:
            self.client_status = m.get('client_status')
        if m.get('server_status') is not None:
            self.server_status = m.get('server_status')
        if m.get('client_component') is not None:
            self.client_component = m.get('client_component')
        if m.get('server_component') is not None:
            self.server_component = m.get('server_component')
        if m.get('client_span') is not None:
            temp_model = TraceSpan()
            self.client_span = temp_model.from_map(m['client_span'])
        if m.get('server_span') is not None:
            temp_model = TraceSpan()
            self.server_span = temp_model.from_map(m['server_span'])
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('apdex_threshold') is not None:
            self.apdex_threshold = m.get('apdex_threshold')
        if m.get('apdex_status') is not None:
            self.apdex_status = m.get('apdex_status')
        return self


class StackMonitorItem(TeaModel):
    def __init__(
        self,
        id: int = None,
        stack_id: int = None,
        name: str = None,
        display_name: str = None,
        can_custom: bool = None,
        manage_entity_id: int = None,
        metric_type: str = None,
        config: str = None,
        title: str = None,
    ):
        # 监控项 ID
        self.id = id
        # 技术栈 ID
        self.stack_id = stack_id
        # 名称，必须是英文
        self.name = name
        # 显示名
        self.display_name = display_name
        # 能否自定义
        self.can_custom = can_custom
        # 管理实体 ID
        self.manage_entity_id = manage_entity_id
        # metric类型(dependency、error、service、resource等)
        self.metric_type = metric_type
        # 配置(JSON String, 使用前需要解析)
        self.config = config
        # 标题
        self.title = title

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.stack_id, 'stack_id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.can_custom, 'can_custom')
        self.validate_required(self.manage_entity_id, 'manage_entity_id')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.stack_id is not None:
            result['stack_id'] = self.stack_id
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.can_custom is not None:
            result['can_custom'] = self.can_custom
        if self.manage_entity_id is not None:
            result['manage_entity_id'] = self.manage_entity_id
        if self.metric_type is not None:
            result['metric_type'] = self.metric_type
        if self.config is not None:
            result['config'] = self.config
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('stack_id') is not None:
            self.stack_id = m.get('stack_id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('can_custom') is not None:
            self.can_custom = m.get('can_custom')
        if m.get('manage_entity_id') is not None:
            self.manage_entity_id = m.get('manage_entity_id')
        if m.get('metric_type') is not None:
            self.metric_type = m.get('metric_type')
        if m.get('config') is not None:
            self.config = m.get('config')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class ErrorRealte(TeaModel):
    def __init__(
        self,
        ips: List[str] = None,
        log_paths: List[str] = None,
    ):
        # ips
        self.ips = ips
        # log_paths
        self.log_paths = log_paths

    def validate(self):
        self.validate_required(self.ips, 'ips')
        self.validate_required(self.log_paths, 'log_paths')

    def to_map(self):
        result = dict()
        if self.ips is not None:
            result['ips'] = self.ips
        if self.log_paths is not None:
            result['log_paths'] = self.log_paths
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ips') is not None:
            self.ips = m.get('ips')
        if m.get('log_paths') is not None:
            self.log_paths = m.get('log_paths')
        return self


class NodeOverviewDTO(TeaModel):
    def __init__(
        self,
        disk_top_nodes: List[NodeTopItem] = None,
        cpu_top_nodes: List[NodeTopItem] = None,
        mem_top_nodes: List[NodeTopItem] = None,
    ):
        # 磁盘 top排序应用
        self.disk_top_nodes = disk_top_nodes
        # 
        # cpu top排序应用
        self.cpu_top_nodes = cpu_top_nodes
        # mem top排序应用
        self.mem_top_nodes = mem_top_nodes

    def validate(self):
        self.validate_required(self.disk_top_nodes, 'disk_top_nodes')
        if self.disk_top_nodes:
            for k in self.disk_top_nodes:
                if k:
                    k.validate()
        self.validate_required(self.cpu_top_nodes, 'cpu_top_nodes')
        if self.cpu_top_nodes:
            for k in self.cpu_top_nodes:
                if k:
                    k.validate()
        self.validate_required(self.mem_top_nodes, 'mem_top_nodes')
        if self.mem_top_nodes:
            for k in self.mem_top_nodes:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        result['disk_top_nodes'] = []
        if self.disk_top_nodes is not None:
            for k in self.disk_top_nodes:
                result['disk_top_nodes'].append(k.to_map() if k else None)
        result['cpu_top_nodes'] = []
        if self.cpu_top_nodes is not None:
            for k in self.cpu_top_nodes:
                result['cpu_top_nodes'].append(k.to_map() if k else None)
        result['mem_top_nodes'] = []
        if self.mem_top_nodes is not None:
            for k in self.mem_top_nodes:
                result['mem_top_nodes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.disk_top_nodes = []
        if m.get('disk_top_nodes') is not None:
            for k in m.get('disk_top_nodes'):
                temp_model = NodeTopItem()
                self.disk_top_nodes.append(temp_model.from_map(k))
        self.cpu_top_nodes = []
        if m.get('cpu_top_nodes') is not None:
            for k in m.get('cpu_top_nodes'):
                temp_model = NodeTopItem()
                self.cpu_top_nodes.append(temp_model.from_map(k))
        self.mem_top_nodes = []
        if m.get('mem_top_nodes') is not None:
            for k in m.get('mem_top_nodes'):
                temp_model = NodeTopItem()
                self.mem_top_nodes.append(temp_model.from_map(k))
        return self


class InitInfo(TeaModel):
    def __init__(
        self,
        auth_url: str = None,
        user: MonitorUser = None,
        nav_head: NavContent = None,
    ):
        # auth_url
        self.auth_url = auth_url
        # user
        self.user = user
        # nav_head
        self.nav_head = nav_head

    def validate(self):
        self.validate_required(self.auth_url, 'auth_url')
        self.validate_required(self.user, 'user')
        if self.user:
            self.user.validate()
        self.validate_required(self.nav_head, 'nav_head')
        if self.nav_head:
            self.nav_head.validate()

    def to_map(self):
        result = dict()
        if self.auth_url is not None:
            result['auth_url'] = self.auth_url
        if self.user is not None:
            result['user'] = self.user.to_map()
        if self.nav_head is not None:
            result['nav_head'] = self.nav_head.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_url') is not None:
            self.auth_url = m.get('auth_url')
        if m.get('user') is not None:
            temp_model = MonitorUser()
            self.user = temp_model.from_map(m['user'])
        if m.get('nav_head') is not None:
            temp_model = NavContent()
            self.nav_head = temp_model.from_map(m['nav_head'])
        return self


class SpiConfig(TeaModel):
    def __init__(
        self,
        end_point: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
        last_editor: str = None,
        field_naming_strategy: str = None,
        cloud_vendor_type: str = None,
    ):
        # end_point或token
        self.end_point = end_point
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # last_editor
        self.last_editor = last_editor
        # 字段格式
        self.field_naming_strategy = field_naming_strategy
        # 云厂商类型
        self.cloud_vendor_type = cloud_vendor_type

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.end_point is not None:
            result['end_point'] = self.end_point
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.last_editor is not None:
            result['last_editor'] = self.last_editor
        if self.field_naming_strategy is not None:
            result['field_naming_strategy'] = self.field_naming_strategy
        if self.cloud_vendor_type is not None:
            result['cloud_vendor_type'] = self.cloud_vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('end_point') is not None:
            self.end_point = m.get('end_point')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('last_editor') is not None:
            self.last_editor = m.get('last_editor')
        if m.get('field_naming_strategy') is not None:
            self.field_naming_strategy = m.get('field_naming_strategy')
        if m.get('cloud_vendor_type') is not None:
            self.cloud_vendor_type = m.get('cloud_vendor_type')
        return self


class AlarmTest(TeaModel):
    def __init__(
        self,
        workspace_name: str = None,
        alarm_rule_id: int = None,
    ):
        # 工作空间名称
        self.workspace_name = workspace_name
        # 告警规则id
        self.alarm_rule_id = alarm_rule_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.alarm_rule_id, 'alarm_rule_id')

    def to_map(self):
        result = dict()
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        return self


class FolderPaths(TeaModel):
    def __init__(
        self,
        paths: List[FolderPath] = None,
    ):
        # paths
        self.paths = paths

    def validate(self):
        self.validate_required(self.paths, 'paths')
        if self.paths:
            for k in self.paths:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        result['paths'] = []
        if self.paths is not None:
            for k in self.paths:
                result['paths'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.paths = []
        if m.get('paths') is not None:
            for k in m.get('paths'):
                temp_model = FolderPath()
                self.paths.append(temp_model.from_map(k))
        return self


class AlarmNotifyStatsKeySet(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: AlarmNotifyStats = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')
        if self.value:
            self.value.validate()

    def to_map(self):
        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            temp_model = AlarmNotifyStats()
            self.value = temp_model.from_map(m['value'])
        return self


class TraasRegionDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class StringValue(TeaModel):
    def __init__(
        self,
        value: str = None,
    ):
        # value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class OpsDataCheck(TeaModel):
    def __init__(
        self,
        id: int = None,
        target_name: str = None,
        target_type: str = None,
        status: int = None,
        check_result: str = None,
    ):
        # id
        self.id = id
        # 指标名称
        self.target_name = target_name
        # 指标类型
        self.target_type = target_type
        # 0：异常 1：正常
        self.status = status
        # check_result
        self.check_result = check_result

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.target_name, 'target_name')
        self.validate_required(self.target_type, 'target_type')
        self.validate_required(self.status, 'status')
        self.validate_required(self.check_result, 'check_result')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.target_name is not None:
            result['target_name'] = self.target_name
        if self.target_type is not None:
            result['target_type'] = self.target_type
        if self.status is not None:
            result['status'] = self.status
        if self.check_result is not None:
            result['check_result'] = self.check_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('target_name') is not None:
            self.target_name = m.get('target_name')
        if m.get('target_type') is not None:
            self.target_type = m.get('target_type')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('check_result') is not None:
            self.check_result = m.get('check_result')
        return self


class UnifiedAlarmSubDTO(TeaModel):
    def __init__(
        self,
        subscriber: str = None,
        subscriber_type: str = None,
        subscriber_source: str = None,
        subscriber_name: str = None,
    ):
        # 订阅者id
        self.subscriber = subscriber
        # 订阅者类型
        self.subscriber_type = subscriber_type
        # 订阅者来源
        self.subscriber_source = subscriber_source
        # 告警对象的名称
        self.subscriber_name = subscriber_name

    def validate(self):
        self.validate_required(self.subscriber, 'subscriber')
        self.validate_required(self.subscriber_type, 'subscriber_type')
        self.validate_required(self.subscriber_source, 'subscriber_source')
        self.validate_required(self.subscriber_name, 'subscriber_name')

    def to_map(self):
        result = dict()
        if self.subscriber is not None:
            result['subscriber'] = self.subscriber
        if self.subscriber_type is not None:
            result['subscriber_type'] = self.subscriber_type
        if self.subscriber_source is not None:
            result['subscriber_source'] = self.subscriber_source
        if self.subscriber_name is not None:
            result['subscriber_name'] = self.subscriber_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('subscriber') is not None:
            self.subscriber = m.get('subscriber')
        if m.get('subscriber_type') is not None:
            self.subscriber_type = m.get('subscriber_type')
        if m.get('subscriber_source') is not None:
            self.subscriber_source = m.get('subscriber_source')
        if m.get('subscriber_name') is not None:
            self.subscriber_name = m.get('subscriber_name')
        return self


class MenuConfig(TeaModel):
    def __init__(
        self,
        show_top_nav_pages: bool = None,
        hide_menus: List[Menu] = None,
    ):
        # 是否需要在顶部菜单展示各个入口
        self.show_top_nav_pages = show_top_nav_pages
        # 需要隐藏的菜单
        self.hide_menus = hide_menus

    def validate(self):
        self.validate_required(self.show_top_nav_pages, 'show_top_nav_pages')
        self.validate_required(self.hide_menus, 'hide_menus')
        if self.hide_menus:
            for k in self.hide_menus:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.show_top_nav_pages is not None:
            result['show_top_nav_pages'] = self.show_top_nav_pages
        result['hide_menus'] = []
        if self.hide_menus is not None:
            for k in self.hide_menus:
                result['hide_menus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('show_top_nav_pages') is not None:
            self.show_top_nav_pages = m.get('show_top_nav_pages')
        self.hide_menus = []
        if m.get('hide_menus') is not None:
            for k in m.get('hide_menus'):
                temp_model = Menu()
                self.hide_menus.append(temp_model.from_map(k))
        return self


class XTableResponse(TeaModel):
    def __init__(
        self,
        result_type: str = None,
        result: List[XTableData] = None,
    ):
        # 
        self.result_type = result_type
        # 
        self.result = result

    def validate(self):
        self.validate_required(self.result_type, 'result_type')
        self.validate_required(self.result, 'result')
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.result_type is not None:
            result['result_type'] = self.result_type
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('result_type') is not None:
            self.result_type = m.get('result_type')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = XTableData()
                self.result.append(temp_model.from_map(k))
        return self


class OpsCheckResult(TeaModel):
    def __init__(
        self,
        app: str = None,
        actual_instance_num: int = None,
        expect_instance_num: int = None,
        app_healthy_num: int = None,
        app_unhealthy_num: int = None,
        custom_healthy_num: int = None,
        custom_unhealthy_num: int = None,
        id: int = None,
        rule_status: int = None,
        rule_id: str = None,
    ):
        # 应用名
        self.app = app
        # 实际实例数
        self.actual_instance_num = actual_instance_num
        # 预期实例数
        self.expect_instance_num = expect_instance_num
        # 应用监控指标健康数
        self.app_healthy_num = app_healthy_num
        # 
        # 应用监控指标异常数
        self.app_unhealthy_num = app_unhealthy_num
        # 自定义监控指标健康数
        self.custom_healthy_num = custom_healthy_num
        # 自定义监控指标异常数
        self.custom_unhealthy_num = custom_unhealthy_num
        # id
        self.id = id
        # 规则状态 0：已关闭 1：已开启
        self.rule_status = rule_status
        # rule_id
        self.rule_id = rule_id

    def validate(self):
        self.validate_required(self.app, 'app')
        self.validate_required(self.actual_instance_num, 'actual_instance_num')
        self.validate_required(self.expect_instance_num, 'expect_instance_num')
        self.validate_required(self.app_healthy_num, 'app_healthy_num')
        self.validate_required(self.app_unhealthy_num, 'app_unhealthy_num')
        self.validate_required(self.custom_healthy_num, 'custom_healthy_num')
        self.validate_required(self.custom_unhealthy_num, 'custom_unhealthy_num')
        self.validate_required(self.id, 'id')
        self.validate_required(self.rule_status, 'rule_status')

    def to_map(self):
        result = dict()
        if self.app is not None:
            result['app'] = self.app
        if self.actual_instance_num is not None:
            result['actual_instance_num'] = self.actual_instance_num
        if self.expect_instance_num is not None:
            result['expect_instance_num'] = self.expect_instance_num
        if self.app_healthy_num is not None:
            result['app_healthy_num'] = self.app_healthy_num
        if self.app_unhealthy_num is not None:
            result['app_unhealthy_num'] = self.app_unhealthy_num
        if self.custom_healthy_num is not None:
            result['custom_healthy_num'] = self.custom_healthy_num
        if self.custom_unhealthy_num is not None:
            result['custom_unhealthy_num'] = self.custom_unhealthy_num
        if self.id is not None:
            result['id'] = self.id
        if self.rule_status is not None:
            result['rule_status'] = self.rule_status
        if self.rule_id is not None:
            result['rule_id'] = self.rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('actual_instance_num') is not None:
            self.actual_instance_num = m.get('actual_instance_num')
        if m.get('expect_instance_num') is not None:
            self.expect_instance_num = m.get('expect_instance_num')
        if m.get('app_healthy_num') is not None:
            self.app_healthy_num = m.get('app_healthy_num')
        if m.get('app_unhealthy_num') is not None:
            self.app_unhealthy_num = m.get('app_unhealthy_num')
        if m.get('custom_healthy_num') is not None:
            self.custom_healthy_num = m.get('custom_healthy_num')
        if m.get('custom_unhealthy_num') is not None:
            self.custom_unhealthy_num = m.get('custom_unhealthy_num')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('rule_status') is not None:
            self.rule_status = m.get('rule_status')
        if m.get('rule_id') is not None:
            self.rule_id = m.get('rule_id')
        return self


class WorkspaceSettingDetail(TeaModel):
    def __init__(
        self,
        old_alarm_lang: str = None,
        old_alarm_enable: bool = None,
        unified_alarm_lang: str = None,
        unified_alarm_enable: bool = None,
        trace_enable: bool = None,
        diagnose_enable: bool = None,
    ):
        # old_alarm_lang
        self.old_alarm_lang = old_alarm_lang
        # 旧版告警开关
        self.old_alarm_enable = old_alarm_enable
        # unified_alarm_lang
        self.unified_alarm_lang = unified_alarm_lang
        # unified_alarm_enable
        self.unified_alarm_enable = unified_alarm_enable
        # trace_enable
        self.trace_enable = trace_enable
        # 监控诊断开关
        self.diagnose_enable = diagnose_enable

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.old_alarm_lang is not None:
            result['old_alarm_lang'] = self.old_alarm_lang
        if self.old_alarm_enable is not None:
            result['old_alarm_enable'] = self.old_alarm_enable
        if self.unified_alarm_lang is not None:
            result['unified_alarm_lang'] = self.unified_alarm_lang
        if self.unified_alarm_enable is not None:
            result['unified_alarm_enable'] = self.unified_alarm_enable
        if self.trace_enable is not None:
            result['trace_enable'] = self.trace_enable
        if self.diagnose_enable is not None:
            result['diagnose_enable'] = self.diagnose_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('old_alarm_lang') is not None:
            self.old_alarm_lang = m.get('old_alarm_lang')
        if m.get('old_alarm_enable') is not None:
            self.old_alarm_enable = m.get('old_alarm_enable')
        if m.get('unified_alarm_lang') is not None:
            self.unified_alarm_lang = m.get('unified_alarm_lang')
        if m.get('unified_alarm_enable') is not None:
            self.unified_alarm_enable = m.get('unified_alarm_enable')
        if m.get('trace_enable') is not None:
            self.trace_enable = m.get('trace_enable')
        if m.get('diagnose_enable') is not None:
            self.diagnose_enable = m.get('diagnose_enable')
        return self


class AlarmTarget(TeaModel):
    def __init__(
        self,
        target_identity: str = None,
        target_type: str = None,
    ):
        # 告警对象标识:
        self.target_identity = target_identity
        # 告警对象类型
        self.target_type = target_type

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.target_identity is not None:
            result['target_identity'] = self.target_identity
        if self.target_type is not None:
            result['target_type'] = self.target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('target_identity') is not None:
            self.target_identity = m.get('target_identity')
        if m.get('target_type') is not None:
            self.target_type = m.get('target_type')
        return self


class OneConsoleRegion(TeaModel):
    def __init__(
        self,
        id: str = None,
        identity: str = None,
        name: str = None,
        workspaces: List[OneConsoleWorkspace] = None,
    ):
        # region id
        self.id = id
        # identity
        self.identity = identity
        # name
        self.name = name
        # workspaces
        self.workspaces = workspaces

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspaces, 'workspaces')
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.identity is not None:
            result['identity'] = self.identity
        if self.name is not None:
            result['name'] = self.name
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = OneConsoleWorkspace()
                self.workspaces.append(temp_model.from_map(k))
        return self


class AlarmHistoryStatsVO(TeaModel):
    def __init__(
        self,
        trends: List[AlarmHistoryStatsDTOsKeySet] = None,
    ):
        # trends
        self.trends = trends

    def validate(self):
        self.validate_required(self.trends, 'trends')
        if self.trends:
            for k in self.trends:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        result['trends'] = []
        if self.trends is not None:
            for k in self.trends:
                result['trends'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.trends = []
        if m.get('trends') is not None:
            for k in m.get('trends'):
                temp_model = AlarmHistoryStatsDTOsKeySet()
                self.trends.append(temp_model.from_map(k))
        return self


class TraasWorkspaceDto(TeaModel):
    def __init__(
        self,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_group_uuid: str = None,
        region_uuid: str = None,
        zone_uuids: List[str] = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        gmt_create: str = None,
        gmt_modified: str = None,
    ):
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_group_uuid
        self.workspace_group_uuid = workspace_group_uuid
        # region_uuid
        self.region_uuid = region_uuid
        # zone_uuids
        self.zone_uuids = zone_uuids
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # gmt_create
        self.gmt_create = gmt_create
        # gmt_modified
        self.gmt_modified = gmt_modified

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')
        if self.gmt_create is not None:
            self.validate_pattern(self.gmt_create, 'gmt_create', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.gmt_modified is not None:
            self.validate_pattern(self.gmt_modified, 'gmt_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        result = dict()
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_group_uuid is not None:
            result['workspace_group_uuid'] = self.workspace_group_uuid
        if self.region_uuid is not None:
            result['region_uuid'] = self.region_uuid
        if self.zone_uuids is not None:
            result['zone_uuids'] = self.zone_uuids
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_group_uuid') is not None:
            self.workspace_group_uuid = m.get('workspace_group_uuid')
        if m.get('region_uuid') is not None:
            self.region_uuid = m.get('region_uuid')
        if m.get('zone_uuids') is not None:
            self.zone_uuids = m.get('zone_uuids')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        return self


class AlarmSub(TeaModel):
    def __init__(
        self,
        id: int = None,
        user_login_name: str = None,
        user_group_id: int = None,
        notify_channel: str = None,
        alarm_pkg_id: int = None,
        custom_plugin_id: int = None,
        stack_alarm_rule_id: int = None,
        folder_id: int = None,
        meta_group_id: int = None,
        stack_universal_table_id: str = None,
        gmt_create: int = None,
        gmt_modified: int = None,
        creater: str = None,
        modifier: str = None,
        alarm_level: int = None,
        notify_reduce_switch: int = None,
        alarm_http_web_hook_id: int = None,
    ):
        # 主键 ID
        self.id = id
        # 用户登录名
        self.user_login_name = user_login_name
        # 告警组 ID
        self.user_group_id = user_group_id
        # the notifyChannel
        self.notify_channel = notify_channel
        # 告警套餐 ID
        self.alarm_pkg_id = alarm_pkg_id
        # 自定义监控 ID
        self.custom_plugin_id = custom_plugin_id
        # the stackAlarmRuleId
        self.stack_alarm_rule_id = stack_alarm_rule_id
        # 文件夹 ID
        self.folder_id = folder_id
        # the metaGroupId
        self.meta_group_id = meta_group_id
        # 技术栈实体
        self.stack_universal_table_id = stack_universal_table_id
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modified = gmt_modified
        # 创建者
        self.creater = creater
        # 修改人
        self.modifier = modifier
        # 告警级别
        self.alarm_level = alarm_level
        # 降频通知开关
        self.notify_reduce_switch = notify_reduce_switch
        # web hook id
        self.alarm_http_web_hook_id = alarm_http_web_hook_id

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.creater, 'creater')
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.notify_reduce_switch, 'notify_reduce_switch')

    def to_map(self):
        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.user_login_name is not None:
            result['user_login_name'] = self.user_login_name
        if self.user_group_id is not None:
            result['user_group_id'] = self.user_group_id
        if self.notify_channel is not None:
            result['notify_channel'] = self.notify_channel
        if self.alarm_pkg_id is not None:
            result['alarm_pkg_id'] = self.alarm_pkg_id
        if self.custom_plugin_id is not None:
            result['custom_plugin_id'] = self.custom_plugin_id
        if self.stack_alarm_rule_id is not None:
            result['stack_alarm_rule_id'] = self.stack_alarm_rule_id
        if self.folder_id is not None:
            result['folder_id'] = self.folder_id
        if self.meta_group_id is not None:
            result['meta_group_id'] = self.meta_group_id
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modified is not None:
            result['gmt_modified'] = self.gmt_modified
        if self.creater is not None:
            result['creater'] = self.creater
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.notify_reduce_switch is not None:
            result['notify_reduce_switch'] = self.notify_reduce_switch
        if self.alarm_http_web_hook_id is not None:
            result['alarm_http_web_hook_id'] = self.alarm_http_web_hook_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('user_login_name') is not None:
            self.user_login_name = m.get('user_login_name')
        if m.get('user_group_id') is not None:
            self.user_group_id = m.get('user_group_id')
        if m.get('notify_channel') is not None:
            self.notify_channel = m.get('notify_channel')
        if m.get('alarm_pkg_id') is not None:
            self.alarm_pkg_id = m.get('alarm_pkg_id')
        if m.get('custom_plugin_id') is not None:
            self.custom_plugin_id = m.get('custom_plugin_id')
        if m.get('stack_alarm_rule_id') is not None:
            self.stack_alarm_rule_id = m.get('stack_alarm_rule_id')
        if m.get('folder_id') is not None:
            self.folder_id = m.get('folder_id')
        if m.get('meta_group_id') is not None:
            self.meta_group_id = m.get('meta_group_id')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modified') is not None:
            self.gmt_modified = m.get('gmt_modified')
        if m.get('creater') is not None:
            self.creater = m.get('creater')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('notify_reduce_switch') is not None:
            self.notify_reduce_switch = m.get('notify_reduce_switch')
        if m.get('alarm_http_web_hook_id') is not None:
            self.alarm_http_web_hook_id = m.get('alarm_http_web_hook_id')
        return self


class LogTail(TeaModel):
    def __init__(
        self,
        agent: str = None,
        app: str = None,
        lines: List[str] = None,
        nc: str = None,
    ):
        # 代理IP
        self.agent = agent
        # 应用名
        self.app = app
        # 日志行数据
        self.lines = lines
        # collectId
        self.nc = nc

    def validate(self):
        self.validate_required(self.agent, 'agent')
        self.validate_required(self.app, 'app')
        self.validate_required(self.lines, 'lines')
        self.validate_required(self.nc, 'nc')

    def to_map(self):
        result = dict()
        if self.agent is not None:
            result['agent'] = self.agent
        if self.app is not None:
            result['app'] = self.app
        if self.lines is not None:
            result['lines'] = self.lines
        if self.nc is not None:
            result['nc'] = self.nc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('agent') is not None:
            self.agent = m.get('agent')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('lines') is not None:
            self.lines = m.get('lines')
        if m.get('nc') is not None:
            self.nc = m.get('nc')
        return self


class TimeSeriesMetrics(TeaModel):
    def __init__(
        self,
        start_time: int = None,
        end_time: int = None,
        tags: List[KeyValuePair] = None,
        type: str = None,
        values: List[TimeSeriesMetricsPoint] = None,
    ):
        # 开始时间, 毫秒时间戳
        self.start_time = start_time
        # 结束时间, 毫秒时间戳
        self.end_time = end_time
        # 标识 metrics，类似 sql 查询条件
        self.tags = tags
        # 指标的分类
        self.type = type
        # Metrics 多个 point 的集合
        self.values = values

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.values:
            for k in self.values:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        result['values'] = []
        if self.values is not None:
            for k in self.values:
                result['values'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeyValuePair()
                self.tags.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        self.values = []
        if m.get('values') is not None:
            for k in m.get('values'):
                temp_model = TimeSeriesMetricsPoint()
                self.values.append(temp_model.from_map(k))
        return self


class QueryRmsAgentloglocateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_id: str = None,
        batch_ip_files: List[IpFileOs] = None,
        charset_str: str = None,
        error_msg: str = None,
        ips: List[str] = None,
        ip_file: IpFileOs = None,
        is_batch: bool = None,
        log_path: str = None,
        log_paths: List[str] = None,
        time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app_id
        self.app_id = app_id
        # batch_ip_files
        self.batch_ip_files = batch_ip_files
        # charset_str
        self.charset_str = charset_str
        # error_msg
        self.error_msg = error_msg
        # ips
        self.ips = ips
        # ip_file
        self.ip_file = ip_file
        # is_batch
        self.is_batch = is_batch
        # log_path
        self.log_path = log_path
        # log_paths
        self.log_paths = log_paths
        # time
        self.time = time

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.batch_ip_files, 'batch_ip_files')
        if self.batch_ip_files:
            for k in self.batch_ip_files:
                if k:
                    k.validate()
        self.validate_required(self.charset_str, 'charset_str')
        self.validate_required(self.error_msg, 'error_msg')
        self.validate_required(self.ips, 'ips')
        self.validate_required(self.ip_file, 'ip_file')
        if self.ip_file:
            self.ip_file.validate()
        self.validate_required(self.is_batch, 'is_batch')
        self.validate_required(self.log_path, 'log_path')
        self.validate_required(self.log_paths, 'log_paths')
        self.validate_required(self.time, 'time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_id is not None:
            result['app_id'] = self.app_id
        result['batch_ip_files'] = []
        if self.batch_ip_files is not None:
            for k in self.batch_ip_files:
                result['batch_ip_files'].append(k.to_map() if k else None)
        if self.charset_str is not None:
            result['charset_str'] = self.charset_str
        if self.error_msg is not None:
            result['error_msg'] = self.error_msg
        if self.ips is not None:
            result['ips'] = self.ips
        if self.ip_file is not None:
            result['ip_file'] = self.ip_file.to_map()
        if self.is_batch is not None:
            result['is_batch'] = self.is_batch
        if self.log_path is not None:
            result['log_path'] = self.log_path
        if self.log_paths is not None:
            result['log_paths'] = self.log_paths
        if self.time is not None:
            result['time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        self.batch_ip_files = []
        if m.get('batch_ip_files') is not None:
            for k in m.get('batch_ip_files'):
                temp_model = IpFileOs()
                self.batch_ip_files.append(temp_model.from_map(k))
        if m.get('charset_str') is not None:
            self.charset_str = m.get('charset_str')
        if m.get('error_msg') is not None:
            self.error_msg = m.get('error_msg')
        if m.get('ips') is not None:
            self.ips = m.get('ips')
        if m.get('ip_file') is not None:
            temp_model = IpFileOs()
            self.ip_file = temp_model.from_map(m['ip_file'])
        if m.get('is_batch') is not None:
            self.is_batch = m.get('is_batch')
        if m.get('log_path') is not None:
            self.log_path = m.get('log_path')
        if m.get('log_paths') is not None:
            self.log_paths = m.get('log_paths')
        if m.get('time') is not None:
            self.time = m.get('time')
        return self


class QueryRmsAgentloglocateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
        error_message: CallErrorMessage = None,
        result: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # success
        self.success = success
        # error_message
        self.error_message = error_message
        # result
        self.result = result

    def validate(self):
        if self.error_message:
            self.error_message.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        if self.error_message is not None:
            result['error_message'] = self.error_message.to_map()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('error_message') is not None:
            temp_model = CallErrorMessage()
            self.error_message = temp_model.from_map(m['error_message'])
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class QueryRmsAgenttailRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        tenant_id: str = None,
        app_name: str = None,
        prefer_host: str = None,
        full_path: str = None,
        scan_dirs: List[str] = None,
        need_bytes: int = None,
        line_break_str: str = None,
        extra_suffixs: List[str] = None,
        charset_str: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # tenant_id
        self.tenant_id = tenant_id
        # app_name
        self.app_name = app_name
        # prefer_host
        self.prefer_host = prefer_host
        # full_path
        self.full_path = full_path
        # scan_dirs
        self.scan_dirs = scan_dirs
        # need_bytes
        self.need_bytes = need_bytes
        # line_break_str
        self.line_break_str = line_break_str
        # extra_suffixs
        self.extra_suffixs = extra_suffixs
        # charset_str
        self.charset_str = charset_str

    def validate(self):
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.prefer_host, 'prefer_host')
        self.validate_required(self.full_path, 'full_path')
        self.validate_required(self.scan_dirs, 'scan_dirs')
        self.validate_required(self.need_bytes, 'need_bytes')
        self.validate_required(self.line_break_str, 'line_break_str')
        self.validate_required(self.extra_suffixs, 'extra_suffixs')
        self.validate_required(self.charset_str, 'charset_str')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.prefer_host is not None:
            result['prefer_host'] = self.prefer_host
        if self.full_path is not None:
            result['full_path'] = self.full_path
        if self.scan_dirs is not None:
            result['scan_dirs'] = self.scan_dirs
        if self.need_bytes is not None:
            result['need_bytes'] = self.need_bytes
        if self.line_break_str is not None:
            result['line_break_str'] = self.line_break_str
        if self.extra_suffixs is not None:
            result['extra_suffixs'] = self.extra_suffixs
        if self.charset_str is not None:
            result['charset_str'] = self.charset_str
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('prefer_host') is not None:
            self.prefer_host = m.get('prefer_host')
        if m.get('full_path') is not None:
            self.full_path = m.get('full_path')
        if m.get('scan_dirs') is not None:
            self.scan_dirs = m.get('scan_dirs')
        if m.get('need_bytes') is not None:
            self.need_bytes = m.get('need_bytes')
        if m.get('line_break_str') is not None:
            self.line_break_str = m.get('line_break_str')
        if m.get('extra_suffixs') is not None:
            self.extra_suffixs = m.get('extra_suffixs')
        if m.get('charset_str') is not None:
            self.charset_str = m.get('charset_str')
        return self


class QueryRmsAgenttailResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
        error_message: CallErrorMessage = None,
        result: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # success
        self.success = success
        # error_message
        self.error_message = error_message
        # result
        self.result = result

    def validate(self):
        if self.error_message:
            self.error_message.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        if self.error_message is not None:
            result['error_message'] = self.error_message.to_map()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('error_message') is not None:
            temp_model = CallErrorMessage()
            self.error_message = temp_model.from_map(m['error_message'])
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class QueryRmsAgentbrowserRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        extra_suffixs: List[str] = None,
        scan_dirs: List[str] = None,
        prefer_host: str = None,
        tenant_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app_name
        self.app_name = app_name
        # extra_suffixs
        self.extra_suffixs = extra_suffixs
        # scan_dirs
        self.scan_dirs = scan_dirs
        # prefer_host
        self.prefer_host = prefer_host
        # tenant_id
        self.tenant_id = tenant_id

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.extra_suffixs, 'extra_suffixs')
        self.validate_required(self.scan_dirs, 'scan_dirs')
        self.validate_required(self.prefer_host, 'prefer_host')
        self.validate_required(self.tenant_id, 'tenant_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.extra_suffixs is not None:
            result['extra_suffixs'] = self.extra_suffixs
        if self.scan_dirs is not None:
            result['scan_dirs'] = self.scan_dirs
        if self.prefer_host is not None:
            result['prefer_host'] = self.prefer_host
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('extra_suffixs') is not None:
            self.extra_suffixs = m.get('extra_suffixs')
        if m.get('scan_dirs') is not None:
            self.scan_dirs = m.get('scan_dirs')
        if m.get('prefer_host') is not None:
            self.prefer_host = m.get('prefer_host')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        return self


class QueryRmsAgentbrowserResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
        error_message: CallErrorMessage = None,
        result: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # success
        self.success = success
        # error_message
        self.error_message = error_message
        # result
        self.result = result

    def validate(self):
        if self.error_message:
            self.error_message.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        if self.error_message is not None:
            result['error_message'] = self.error_message.to_map()
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('error_message') is not None:
            temp_model = CallErrorMessage()
            self.error_message = temp_model.from_map(m['error_message'])
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class QueryRmsAlarmhistorytypeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        from_: int = None,
        to: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # from
        self.from_ = from_
        # to
        self.to = to

    def validate(self):
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class QueryRmsAlarmhistorytypeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AlarmTypeStatsVOKeySet] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AlarmTypeStatsVOKeySet()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsAlarmhistorylevelRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        from_: int = None,
        to: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # from
        self.from_ = from_
        # to
        self.to = to

    def validate(self):
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class QueryRmsAlarmhistorylevelResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AlarmLevelStatsVOKeySet] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AlarmLevelStatsVOKeySet()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsNotifyhistoryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        from_: int = None,
        login_name: str = None,
        to: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # from
        self.from_ = from_
        # login_name
        self.login_name = login_name
        # to
        self.to = to

    def validate(self):
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.login_name, 'login_name')
        self.validate_required(self.to, 'to')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.from_ is not None:
            result['from'] = self.from_
        if self.login_name is not None:
            result['login_name'] = self.login_name
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('login_name') is not None:
            self.login_name = m.get('login_name')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class QueryRmsNotifyhistoryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AlarmNotifyStats] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AlarmNotifyStats()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsStackentityRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class QueryRmsStackentityResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[LongKeySet] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = LongKeySet()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsAlarmhistoryappcountRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_list: AppStats = None,
        from_: int = None,
        to: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app_list
        self.app_list = app_list
        # from
        self.from_ = from_
        # to
        self.to = to

    def validate(self):
        self.validate_required(self.app_list, 'app_list')
        if self.app_list:
            self.app_list.validate()
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_list is not None:
            result['app_list'] = self.app_list.to_map()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_list') is not None:
            temp_model = AppStats()
            self.app_list = temp_model.from_map(m['app_list'])
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class QueryRmsAlarmhistoryappcountResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AlarmAppStats] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AlarmAppStats()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsAlarmhistoryappstatsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_list: AppStats = None,
        from_: int = None,
        to: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app_list
        self.app_list = app_list
        # from
        self.from_ = from_
        # to
        self.to = to

    def validate(self):
        self.validate_required(self.app_list, 'app_list')
        if self.app_list:
            self.app_list.validate()
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_list is not None:
            result['app_list'] = self.app_list.to_map()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_list') is not None:
            temp_model = AppStats()
            self.app_list = temp_model.from_map(m['app_list'])
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class QueryRmsAlarmhistoryappstatsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AlarmHistoryListKeySetMap] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AlarmHistoryListKeySetMap()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsAppstatspageableRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_list: AppStats = None,
        from_: int = None,
        to: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app_list
        self.app_list = app_list
        # from
        self.from_ = from_
        # to
        self.to = to

    def validate(self):
        self.validate_required(self.app_list, 'app_list')
        if self.app_list:
            self.app_list.validate()
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_list is not None:
            result['app_list'] = self.app_list.to_map()
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_list') is not None:
            temp_model = AppStats()
            self.app_list = temp_model.from_map(m['app_list'])
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        return self


class QueryRmsAppstatspageableResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AlarmHistoryListKeySetMap] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AlarmHistoryListKeySetMap()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsLogreaderrorRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app: str = None,
        time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app
        self.app = app
        # time
        self.time = time

    def validate(self):
        self.validate_required(self.app, 'app')
        self.validate_required(self.time, 'time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app is not None:
            result['app'] = self.app
        if self.time is not None:
            result['time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('time') is not None:
            self.time = m.get('time')
        return self


class QueryRmsLogreaderrorResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: ErrorRealte = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = ErrorRealte()
            self.data = temp_model.from_map(m['data'])
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsUniversalreadRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cmds: List[UniversalBodyCmd] = None,
        rid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cmds
        self.cmds = cmds
        # rid
        self.rid = rid

    def validate(self):
        self.validate_required(self.cmds, 'cmds')
        if self.cmds:
            for k in self.cmds:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['cmds'] = []
        if self.cmds is not None:
            for k in self.cmds:
                result['cmds'].append(k.to_map() if k else None)
        if self.rid is not None:
            result['rid'] = self.rid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.cmds = []
        if m.get('cmds') is not None:
            for k in m.get('cmds'):
                temp_model = UniversalBodyCmd()
                self.cmds.append(temp_model.from_map(k))
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        return self


class QueryRmsUniversalreadResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[str] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsUniversalwriteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cmds: List[UniversalBodyCmd] = None,
        rid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cmds
        self.cmds = cmds
        # rid
        self.rid = rid

    def validate(self):
        self.validate_required(self.cmds, 'cmds')
        if self.cmds:
            for k in self.cmds:
                if k:
                    k.validate()
        self.validate_required(self.rid, 'rid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['cmds'] = []
        if self.cmds is not None:
            for k in self.cmds:
                result['cmds'].append(k.to_map() if k else None)
        if self.rid is not None:
            result['rid'] = self.rid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.cmds = []
        if m.get('cmds') is not None:
            for k in m.get('cmds'):
                temp_model = UniversalBodyCmd()
                self.cmds.append(temp_model.from_map(k))
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        return self


class QueryRmsUniversalwriteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[str] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CreateRmsPluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class CreateRmsPluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DeleteRmsPluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class DeleteRmsPluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CloseRmsPluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class CloseRmsPluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class OpenRmsPluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class OpenRmsPluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateRmsPluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class UpdateRmsPluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsPluginbytypeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class QueryRmsPluginbytypeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[PluginModelDO] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = PluginModelDO()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsPluginbyfolderRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class QueryRmsPluginbyfolderResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[ModelTreeNode] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ModelTreeNode()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsPluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class QueryRmsPluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: PluginModelDO = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = PluginModelDO()
            self.data = temp_model.from_map(m['data'])
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsPlugintestRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        body: str = None,
        file_id: int = None,
        id: int = None,
        outside_bizdomain: str = None,
        plugin_id: int = None,
        table: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # body
        self.body = body
        # file_id
        self.file_id = file_id
        # id
        self.id = id
        # outside_bizdomain
        self.outside_bizdomain = outside_bizdomain
        # plugin_id
        self.plugin_id = plugin_id
        # table
        self.table = table

    def validate(self):
        self.validate_required(self.body, 'body')
        self.validate_required(self.file_id, 'file_id')
        self.validate_required(self.id, 'id')
        self.validate_required(self.outside_bizdomain, 'outside_bizdomain')
        self.validate_required(self.plugin_id, 'plugin_id')
        self.validate_required(self.table, 'table')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.body is not None:
            result['body'] = self.body
        if self.file_id is not None:
            result['file_id'] = self.file_id
        if self.id is not None:
            result['id'] = self.id
        if self.outside_bizdomain is not None:
            result['outside_bizdomain'] = self.outside_bizdomain
        if self.plugin_id is not None:
            result['plugin_id'] = self.plugin_id
        if self.table is not None:
            result['table'] = self.table
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('file_id') is not None:
            self.file_id = m.get('file_id')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('outside_bizdomain') is not None:
            self.outside_bizdomain = m.get('outside_bizdomain')
        if m.get('plugin_id') is not None:
            self.plugin_id = m.get('plugin_id')
        if m.get('table') is not None:
            self.table = m.get('table')
        return self


class QueryRmsPlugintestResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: Threshold = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = Threshold()
            self.data = temp_model.from_map(m['data'])
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsPathRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        requests: List[FolderRequestCmd] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # requests
        self.requests = requests

    def validate(self):
        self.validate_required(self.requests, 'requests')
        if self.requests:
            for k in self.requests:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['requests'] = []
        if self.requests is not None:
            for k in self.requests:
                result['requests'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.requests = []
        if m.get('requests') is not None:
            for k in m.get('requests'):
                temp_model = FolderRequestCmd()
                self.requests.append(temp_model.from_map(k))
        return self


class QueryRmsPathResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[FolderPaths] = None,
        error_code: str = None,
        rid: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data
        # error_code
        self.error_code = error_code
        # rid
        self.rid = rid
        # success
        self.success = success

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.error_code is not None:
            result['error_code'] = self.error_code
        if self.rid is not None:
            result['rid'] = self.rid
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = FolderPaths()
                self.data.append(temp_model.from_map(k))
        if m.get('error_code') is not None:
            self.error_code = m.get('error_code')
        if m.get('rid') is not None:
            self.rid = m.get('rid')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ExecRmsUniversalcleankeyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        req_params: List[KeySet] = None,
        tenant_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # req_params
        self.req_params = req_params
        # tenant_id
        self.tenant_id = tenant_id

    def validate(self):
        self.validate_required(self.req_params, 'req_params')
        if self.req_params:
            for k in self.req_params:
                if k:
                    k.validate()
        self.validate_required(self.tenant_id, 'tenant_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['req_params'] = []
        if self.req_params is not None:
            for k in self.req_params:
                result['req_params'].append(k.to_map() if k else None)
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.req_params = []
        if m.get('req_params') is not None:
            for k in m.get('req_params'):
                temp_model = KeySet()
                self.req_params.append(temp_model.from_map(k))
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        return self


class ExecRmsUniversalcleankeyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        error_message: CallErrorMessage = None,
        part_suc: bool = None,
        result: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # error_message
        self.error_message = error_message
        # part_suc
        self.part_suc = part_suc
        # result
        self.result = result
        # success
        self.success = success

    def validate(self):
        if self.error_message:
            self.error_message.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.error_message is not None:
            result['error_message'] = self.error_message.to_map()
        if self.part_suc is not None:
            result['part_suc'] = self.part_suc
        if self.result is not None:
            result['result'] = self.result
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('error_message') is not None:
            temp_model = CallErrorMessage()
            self.error_message = temp_model.from_map(m['error_message'])
        if m.get('part_suc') is not None:
            self.part_suc = m.get('part_suc')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class QueryRmsUniversalRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        post_body: str = None,
        tenant_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # post_body
        self.post_body = post_body
        # tenant_id
        self.tenant_id = tenant_id

    def validate(self):
        self.validate_required(self.post_body, 'post_body')
        self.validate_required(self.tenant_id, 'tenant_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.post_body is not None:
            result['post_body'] = self.post_body
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('post_body') is not None:
            self.post_body = m.get('post_body')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        return self


class QueryRmsUniversalResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # result
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class QueryRmsTracespanRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app: str = None,
        end_time: int = None,
        extensions: List[KeySet] = None,
        max_duration: int = None,
        min_duration: int = None,
        page_number: int = None,
        page_size: int = None,
        start_time: int = None,
        status: str = None,
        tags: List[KeySet] = None,
        trace_id: str = None,
        workspace_id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 如果指定了app, 那么是 localServiceName or remoteServiceName 的效果, 任何一个命中了都行
        self.app = app
        # 最大的毫秒开始时间戳
        self.end_time = end_time
        # 万能扩展字段
        self.extensions = extensions
        # 最大毫秒耗时
        self.max_duration = max_duration
        # 最小毫秒耗时
        self.min_duration = min_duration
        # 分页号
        self.page_number = page_number
        # 分页大小
        self.page_size = page_size
        # 搜索的毫秒开始时间戳
        self.start_time = start_time
        # 结果码
        self.status = status
        # 用来动态传递一些tags或条件匹配, 有一些key是保留的, 服务端会进行特殊解释, 其他的则会认为是要对tags做精确匹配.
        self.tags = tags
        # 按traceId搜索时会用到 此时其他条件自动失效
        self.trace_id = trace_id
        # workspace_id
        self.workspace_id = workspace_id

    def validate(self):
        if self.extensions:
            for k in self.extensions:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app is not None:
            result['app'] = self.app
        if self.end_time is not None:
            result['end_time'] = self.end_time
        result['extensions'] = []
        if self.extensions is not None:
            for k in self.extensions:
                result['extensions'].append(k.to_map() if k else None)
        if self.max_duration is not None:
            result['max_duration'] = self.max_duration
        if self.min_duration is not None:
            result['min_duration'] = self.min_duration
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        self.extensions = []
        if m.get('extensions') is not None:
            for k in m.get('extensions'):
                temp_model = KeySet()
                self.extensions.append(temp_model.from_map(k))
        if m.get('max_duration') is not None:
            self.max_duration = m.get('max_duration')
        if m.get('min_duration') is not None:
            self.min_duration = m.get('min_duration')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeySet()
                self.tags.append(temp_model.from_map(k))
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        return self


class QueryRmsTracespanResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        page_number: int = None,
        page_size: int = None,
        spans: List[TraceSpan] = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 分页号
        self.page_number = page_number
        # 分页大小
        self.page_size = page_size
        # 搜索出的spans, 查无结果时为空数组
        self.spans = spans
        # 总页数
        self.total_page = total_page

    def validate(self):
        if self.spans:
            for k in self.spans:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        result['spans'] = []
        if self.spans is not None:
            for k in self.spans:
                result['spans'].append(k.to_map() if k else None)
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        self.spans = []
        if m.get('spans') is not None:
            for k in m.get('spans'):
                temp_model = TraceSpan()
                self.spans.append(temp_model.from_map(k))
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class GetRmsTracespanqueryconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class GetRmsTracespanqueryconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tag_configs: List[TraceSpanSearchTagConfig] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 支持的tags列表
        self.tag_configs = tag_configs

    def validate(self):
        if self.tag_configs:
            for k in self.tag_configs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['tag_configs'] = []
        if self.tag_configs is not None:
            for k in self.tag_configs:
                result['tag_configs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.tag_configs = []
        if m.get('tag_configs') is not None:
            for k in m.get('tag_configs'):
                temp_model = TraceSpanSearchTagConfig()
                self.tag_configs.append(temp_model.from_map(k))
        return self


class DescribeRmsTracetreeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        trace_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # trace_id
        self.trace_id = trace_id

    def validate(self):
        self.validate_required(self.trace_id, 'trace_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        return self


class DescribeRmsTracetreeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        trace_tree_items: List[TraceTreeItem] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 树状图结构体
        # 找不到数据时 trace_tree_items 为空数组, 并不会报错
        self.trace_tree_items = trace_tree_items

    def validate(self):
        if self.trace_tree_items:
            for k in self.trace_tree_items:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['trace_tree_items'] = []
        if self.trace_tree_items is not None:
            for k in self.trace_tree_items:
                result['trace_tree_items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.trace_tree_items = []
        if m.get('trace_tree_items') is not None:
            for k in m.get('trace_tree_items'):
                temp_model = TraceTreeItem()
                self.trace_tree_items.append(temp_model.from_map(k))
        return self


class CallbackSpiCompletecommodityRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        data: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 南天门的请求体都是做成json字符串放在data字段里
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CallbackSpiCompletecommodityResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        code: str = None,
        data: str = None,
        message: str = None,
        synchro: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # code
        self.code = code
        # data
        self.data = data
        # message
        self.message = message
        # synchro
        self.synchro = synchro
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.synchro is not None:
            result['synchro'] = self.synchro
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('synchro') is not None:
            self.synchro = m.get('synchro')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CallbackSpiPayordercallbackRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        data: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 南天门支付后回调请求, 见 http://help.aliyun-inc.com/internaldoc/detail/134798.html?spm=ntm.workbench-devPlatform-extendPoint.0.0.42a919afQhBhEB.
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CallbackSpiPayordercallbackResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        code: str = None,
        data: str = None,
        message: str = None,
        synchro: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # code
        self.code = code
        # data
        self.data = data
        # message
        self.message = message
        # synchro
        self.synchro = synchro
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.synchro is not None:
            result['synchro'] = self.synchro
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('synchro') is not None:
            self.synchro = m.get('synchro')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CallbackSpiCompleteorderparamRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        data: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # data
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CallbackSpiCompleteorderparamResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        code: str = None,
        data: str = None,
        message: str = None,
        synchro: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # code
        self.code = code
        # data
        self.data = data
        # message
        self.message = message
        # synchro
        self.synchro = synchro
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.synchro is not None:
            result['synchro'] = self.synchro
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('synchro') is not None:
            self.synchro = m.get('synchro')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CallbackSpiVerifyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        data: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # data
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CallbackSpiVerifyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        code: str = None,
        data: str = None,
        message: str = None,
        synchro: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # code
        self.code = code
        # data
        self.data = data
        # message
        self.message = message
        # synchro
        self.synchro = synchro
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.synchro is not None:
            result['synchro'] = self.synchro
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('synchro') is not None:
            self.synchro = m.get('synchro')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CallbackSpiRefundRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        data: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # data
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CallbackSpiRefundResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        code: str = None,
        data: str = None,
        message: str = None,
        synchro: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # code
        self.code = code
        # data
        self.data = data
        # message
        self.message = message
        # synchro
        self.synchro = synchro
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.synchro is not None:
            result['synchro'] = self.synchro
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('synchro') is not None:
            self.synchro = m.get('synchro')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CallbackSpiLifecycleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        data: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # data
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CallbackSpiLifecycleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        code: str = None,
        data: str = None,
        message: str = None,
        synchro: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # code
        self.code = code
        # data
        self.data = data
        # message
        self.message = message
        # a synchro
        self.synchro = synchro
        # success
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.synchro is not None:
            result['synchro'] = self.synchro
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('synchro') is not None:
            self.synchro = m.get('synchro')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class DescribeRmsTimeseriesmetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        aggregator: str = None,
        end_time: int = None,
        metrics: List[StringValue] = None,
        start_time: int = None,
        tags: List[KeyValuePair] = None,
        type: str = None,
        workspace_id: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # sum或none
        self.aggregator = aggregator
        # 结束毫秒时间戳
        self.end_time = end_time
        # metrics字段名称
        self.metrics = metrics
        # 开始毫秒时间戳
        self.start_time = start_time
        # 扩展字段tags
        self.tags = tags
        # metrics类型
        self.type = type
        # workspace_id或workspace_name选填一个
        self.workspace_id = workspace_id
        # workspace_id或workspace_name选填一个
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.aggregator, 'aggregator')
        self.validate_required(self.end_time, 'end_time')
        self.validate_required(self.metrics, 'metrics')
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        self.validate_required(self.start_time, 'start_time')
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        self.validate_required(self.type, 'type')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.aggregator is not None:
            result['aggregator'] = self.aggregator
        if self.end_time is not None:
            result['end_time'] = self.end_time
        result['metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['metrics'].append(k.to_map() if k else None)
        if self.start_time is not None:
            result['start_time'] = self.start_time
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('aggregator') is not None:
            self.aggregator = m.get('aggregator')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        self.metrics = []
        if m.get('metrics') is not None:
            for k in m.get('metrics'):
                temp_model = StringValue()
                self.metrics.append(temp_model.from_map(k))
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeyValuePair()
                self.tags.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class DescribeRmsTimeseriesmetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        results: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # metrics reulsts
        self.results = results

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['results'] = []
        if self.results is not None:
            for k in self.results:
                result['results'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.results = []
        if m.get('results') is not None:
            for k in m.get('results'):
                temp_model = TimeSeriesMetrics()
                self.results.append(temp_model.from_map(k))
        return self


class DescribeRmsTopologyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        end_time: int = None,
        start_time: int = None,
        workspace_id: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 结束毫秒时间戳
        self.end_time = end_time
        # 开始毫秒时间戳
        self.start_time = start_time
        # workspace_id或workspace_name二选一
        self.workspace_id = workspace_id
        # workspace_id或workspace_name二选一
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class DescribeRmsTopologyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        nodes: List[TopologyNode] = None,
        edges: List[TopologyEdge] = None,
        node_metrics: List[TimeSeriesMetrics] = None,
        edge_metrics: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 拓扑节点
        self.nodes = nodes
        # 拓扑边
        self.edges = edges
        # 节点性能指标
        self.node_metrics = node_metrics
        # 边性能指标
        self.edge_metrics = edge_metrics

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()
        if self.node_metrics:
            for k in self.node_metrics:
                if k:
                    k.validate()
        if self.edge_metrics:
            for k in self.edge_metrics:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['nodes'].append(k.to_map() if k else None)
        result['edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['edges'].append(k.to_map() if k else None)
        result['node_metrics'] = []
        if self.node_metrics is not None:
            for k in self.node_metrics:
                result['node_metrics'].append(k.to_map() if k else None)
        result['edge_metrics'] = []
        if self.edge_metrics is not None:
            for k in self.edge_metrics:
                result['edge_metrics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.nodes = []
        if m.get('nodes') is not None:
            for k in m.get('nodes'):
                temp_model = TopologyNode()
                self.nodes.append(temp_model.from_map(k))
        self.edges = []
        if m.get('edges') is not None:
            for k in m.get('edges'):
                temp_model = TopologyEdge()
                self.edges.append(temp_model.from_map(k))
        self.node_metrics = []
        if m.get('node_metrics') is not None:
            for k in m.get('node_metrics'):
                temp_model = TimeSeriesMetrics()
                self.node_metrics.append(temp_model.from_map(k))
        self.edge_metrics = []
        if m.get('edge_metrics') is not None:
            for k in m.get('edge_metrics'):
                temp_model = TimeSeriesMetrics()
                self.edge_metrics.append(temp_model.from_map(k))
        return self


class QueryMetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        start: int = None,
        end: int = None,
        plugin: str = None,
        ds_id: str = None,
        content_type: str = None,
        workspace_name: str = None,
        period_type: str = None,
        fields: List[str] = None,
        where: List[KeySet] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 开始时间
        self.start = start
        # 结束时间
        self.end = end
        # 插件类型
        self.plugin = plugin
        # 监控指标 ID
        self.ds_id = ds_id
        # contentType
        self.content_type = content_type
        # 工作空间
        self.workspace_name = workspace_name
        # //采集频率
        self.period_type = period_type
        # 查询目标列
        self.fields = fields
        # 查询条件
        self.where = where

    def validate(self):
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        self.validate_required(self.plugin, 'plugin')
        self.validate_required(self.ds_id, 'ds_id')
        self.validate_required(self.workspace_name, 'workspace_name')
        if self.where:
            for k in self.where:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.plugin is not None:
            result['plugin'] = self.plugin
        if self.ds_id is not None:
            result['ds_id'] = self.ds_id
        if self.content_type is not None:
            result['content_type'] = self.content_type
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.period_type is not None:
            result['period_type'] = self.period_type
        if self.fields is not None:
            result['fields'] = self.fields
        result['where'] = []
        if self.where is not None:
            for k in self.where:
                result['where'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('plugin') is not None:
            self.plugin = m.get('plugin')
        if m.get('ds_id') is not None:
            self.ds_id = m.get('ds_id')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('period_type') is not None:
            self.period_type = m.get('period_type')
        if m.get('fields') is not None:
            self.fields = m.get('fields')
        self.where = []
        if m.get('where') is not None:
            for k in m.get('where'):
                temp_model = KeySet()
                self.where.append(temp_model.from_map(k))
        return self


class QueryMetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 查询数据结果
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class QueryTraceSpanRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start_time: int = None,
        end_time: int = None,
        trace_id: str = None,
        app: str = None,
        min_duration: int = None,
        max_duration: int = None,
        current_page: int = None,
        page_size: int = None,
        tags: List[KeySet] = None,
        total_page: int = None,
        total_size: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        filter: TraceQuerySummary = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 搜索的毫秒开始时间戳
        self.start_time = start_time
        # 最大的毫秒开始时间戳
        self.end_time = end_time
        # 按traceId搜索时会用到 此时其他条件自动失效
        self.trace_id = trace_id
        # 如果指定了app, 那么是 localServiceName or remoteServiceName 的效果, 任何一个命中了都行
        self.app = app
        # 最小毫秒耗时
        self.min_duration = min_duration
        # 最大毫秒耗时
        self.max_duration = max_duration
        # 分页号
        self.current_page = current_page
        # 每页记录条数
        self.page_size = page_size
        # 用来动态传递一些tags或条件匹配, 有一些key是保留的, 服务端会进行特殊解释, 其他的则会认为是要对tags做精确匹配.
        self.tags = tags
        # 总页数，小于0或不填代表第一次查询，用来获取总页数
        self.total_page = total_page
        # 总数，小于0或不填代表第一次查询，用来获取总数
        self.total_size = total_size
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 传递需要过滤的字段
        self.filter = filter

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.filter:
            self.filter.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        if self.app is not None:
            result['app'] = self.app
        if self.min_duration is not None:
            result['min_duration'] = self.min_duration
        if self.max_duration is not None:
            result['max_duration'] = self.max_duration
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.total_page is not None:
            result['total_page'] = self.total_page
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.filter is not None:
            result['filter'] = self.filter.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('min_duration') is not None:
            self.min_duration = m.get('min_duration')
        if m.get('max_duration') is not None:
            self.max_duration = m.get('max_duration')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeySet()
                self.tags.append(temp_model.from_map(k))
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('filter') is not None:
            temp_model = TraceQuerySummary()
            self.filter = temp_model.from_map(m['filter'])
        return self


class QueryTraceSpanResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
        spans: List[TraceSpan] = None,
        summary: TraceQuerySummary = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page
        # 搜索出的spans, 查无结果时为空数组
        self.spans = spans
        # 链路查询结果的关键字段取值集
        self.summary = summary

    def validate(self):
        if self.spans:
            for k in self.spans:
                if k:
                    k.validate()
        if self.summary:
            self.summary.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        result['spans'] = []
        if self.spans is not None:
            for k in self.spans:
                result['spans'].append(k.to_map() if k else None)
        if self.summary is not None:
            result['summary'] = self.summary.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        self.spans = []
        if m.get('spans') is not None:
            for k in m.get('spans'):
                temp_model = TraceSpan()
                self.spans.append(temp_model.from_map(k))
        if m.get('summary') is not None:
            temp_model = TraceQuerySummary()
            self.summary = temp_model.from_map(m['summary'])
        return self


class ListAppNameRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        current_page: int = None,
        page_size: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 实际SQL查询时LIMIT的第一个字段
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class ListAppNameResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_names: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 应用名称列表
        self.app_names = app_names

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_names is not None:
            result['app_names'] = self.app_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_names') is not None:
            self.app_names = m.get('app_names')
        return self


class CreateCustompluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        custom_plugin: CustomPluginDO = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 自定义监控指标详细信息 (嵌套对象)
        self.custom_plugin = custom_plugin

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.custom_plugin, 'custom_plugin')
        if self.custom_plugin:
            self.custom_plugin.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.custom_plugin is not None:
            result['custom_plugin'] = self.custom_plugin.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('custom_plugin') is not None:
            temp_model = CustomPluginDO()
            self.custom_plugin = temp_model.from_map(m['custom_plugin'])
        return self


class CreateCustompluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteCustompluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        plugin_type: str = None,
        id: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 监控产品类型
        self.plugin_type = plugin_type
        # id
        self.id = id
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.plugin_type, 'plugin_type')
        self.validate_required(self.id, 'id')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.plugin_type is not None:
            result['plugin_type'] = self.plugin_type
        if self.id is not None:
            result['id'] = self.id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('plugin_type') is not None:
            self.plugin_type = m.get('plugin_type')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class DeleteCustompluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateFolderRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        name: str = None,
        parent_folder_id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 文件夹名称
        self.name = name
        # 父级文件夹id
        self.parent_folder_id = parent_folder_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.name, 'name')
        self.validate_required(self.parent_folder_id, 'parent_folder_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.name is not None:
            result['name'] = self.name
        if self.parent_folder_id is not None:
            result['parent_folder_id'] = self.parent_folder_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('parent_folder_id') is not None:
            self.parent_folder_id = m.get('parent_folder_id')
        return self


class CreateFolderResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        folder_id: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 文件夹 ID
        self.folder_id = folder_id

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.folder_id is not None:
            result['folder_id'] = self.folder_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('folder_id') is not None:
            self.folder_id = m.get('folder_id')
        return self


class UpdateFolderRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        name: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 文件夹id
        self.id = id
        # 文件夹新名称
        self.name = name
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class UpdateFolderResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryTraceConfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryTraceConfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tags: List[TraceSpanSearchTagConfig] = None,
        categories: List[str] = None,
        dbconfigs: List[TraceSpanSearchDbConfig] = None,
        mqkinds: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 链路配置
        self.tags = tags
        # 链路搜索的大类
        self.categories = categories
        # 数据库配置
        self.dbconfigs = dbconfigs
        # 消息队列的kind取值范围
        self.mqkinds = mqkinds

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        if self.dbconfigs:
            for k in self.dbconfigs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.categories is not None:
            result['categories'] = self.categories
        result['dbconfigs'] = []
        if self.dbconfigs is not None:
            for k in self.dbconfigs:
                result['dbconfigs'].append(k.to_map() if k else None)
        if self.mqkinds is not None:
            result['mqkinds'] = self.mqkinds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = TraceSpanSearchTagConfig()
                self.tags.append(temp_model.from_map(k))
        if m.get('categories') is not None:
            self.categories = m.get('categories')
        self.dbconfigs = []
        if m.get('dbconfigs') is not None:
            for k in m.get('dbconfigs'):
                temp_model = TraceSpanSearchDbConfig()
                self.dbconfigs.append(temp_model.from_map(k))
        if m.get('mqkinds') is not None:
            self.mqkinds = m.get('mqkinds')
        return self


class QueryFolderPathRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        custom_plugin_id: int = None,
        folder_id: int = None,
        include_plugin_name: bool = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 自定义监控 ID
        self.custom_plugin_id = custom_plugin_id
        # 文件夹 ID
        self.folder_id = folder_id
        # 是否包含插件名
        self.include_plugin_name = include_plugin_name
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.folder_id, 'folder_id')
        self.validate_required(self.include_plugin_name, 'include_plugin_name')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.custom_plugin_id is not None:
            result['custom_plugin_id'] = self.custom_plugin_id
        if self.folder_id is not None:
            result['folder_id'] = self.folder_id
        if self.include_plugin_name is not None:
            result['include_plugin_name'] = self.include_plugin_name
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('custom_plugin_id') is not None:
            self.custom_plugin_id = m.get('custom_plugin_id')
        if m.get('folder_id') is not None:
            self.folder_id = m.get('folder_id')
        if m.get('include_plugin_name') is not None:
            self.include_plugin_name = m.get('include_plugin_name')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryFolderPathResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        paths: List[FolderPath] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 文件夹路径
        self.paths = paths

    def validate(self):
        if self.paths:
            for k in self.paths:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['paths'] = []
        if self.paths is not None:
            for k in self.paths:
                result['paths'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.paths = []
        if m.get('paths') is not None:
            for k in m.get('paths'):
                temp_model = FolderPath()
                self.paths.append(temp_model.from_map(k))
        return self


class QueryTraceDetailRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        trace_id: str = None,
        backup_entryip: str = None,
        first_query: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # traceId
        self.trace_id = trace_id
        # 备选的入口ip
        self.backup_entryip = backup_entryip
        # 是否为第一次查询
        self.first_query = first_query

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.trace_id, 'trace_id')
        self.validate_required(self.first_query, 'first_query')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        if self.backup_entryip is not None:
            result['backup_entryip'] = self.backup_entryip
        if self.first_query is not None:
            result['first_query'] = self.first_query
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        if m.get('backup_entryip') is not None:
            self.backup_entryip = m.get('backup_entryip')
        if m.get('first_query') is not None:
            self.first_query = m.get('first_query')
        return self


class QueryTraceDetailResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        items: List[TraceTreeItem] = None,
        attributes: List[KeySet] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 节点
        self.items = items
        # 描述整体链路的额外信息，比span总数，应用总数之类的
        self.attributes = attributes

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()
        if self.attributes:
            for k in self.attributes:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        result['attributes'] = []
        if self.attributes is not None:
            for k in self.attributes:
                result['attributes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = TraceTreeItem()
                self.items.append(temp_model.from_map(k))
        self.attributes = []
        if m.get('attributes') is not None:
            for k in m.get('attributes'):
                temp_model = KeySet()
                self.attributes.append(temp_model.from_map(k))
        return self


class QueryTraceTopologyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start_time: int = None,
        end_time: int = None,
        trace_id: str = None,
        app: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # trace_id
        self.trace_id = trace_id
        # app
        self.app = app

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        if self.app is not None:
            result['app'] = self.app
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        if m.get('app') is not None:
            self.app = m.get('app')
        return self


class QueryTraceTopologyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        nodes: List[TopologyNode] = None,
        edges: List[TopologyEdge] = None,
        node_metrics: List[TimeSeriesMetrics] = None,
        edge_metrics: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 拓扑节点
        self.nodes = nodes
        # 拓扑边
        self.edges = edges
        # 节点性能指标
        self.node_metrics = node_metrics
        # 边性能指标
        self.edge_metrics = edge_metrics

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()
        if self.node_metrics:
            for k in self.node_metrics:
                if k:
                    k.validate()
        if self.edge_metrics:
            for k in self.edge_metrics:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['nodes'].append(k.to_map() if k else None)
        result['edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['edges'].append(k.to_map() if k else None)
        result['node_metrics'] = []
        if self.node_metrics is not None:
            for k in self.node_metrics:
                result['node_metrics'].append(k.to_map() if k else None)
        result['edge_metrics'] = []
        if self.edge_metrics is not None:
            for k in self.edge_metrics:
                result['edge_metrics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.nodes = []
        if m.get('nodes') is not None:
            for k in m.get('nodes'):
                temp_model = TopologyNode()
                self.nodes.append(temp_model.from_map(k))
        self.edges = []
        if m.get('edges') is not None:
            for k in m.get('edges'):
                temp_model = TopologyEdge()
                self.edges.append(temp_model.from_map(k))
        self.node_metrics = []
        if m.get('node_metrics') is not None:
            for k in m.get('node_metrics'):
                temp_model = TimeSeriesMetrics()
                self.node_metrics.append(temp_model.from_map(k))
        self.edge_metrics = []
        if m.get('edge_metrics') is not None:
            for k in m.get('edge_metrics'):
                temp_model = TimeSeriesMetrics()
                self.edge_metrics.append(temp_model.from_map(k))
        return self


class QueryTraceMetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        aggregator: str = None,
        end_time: int = None,
        start_time: int = None,
        metrics: List[str] = None,
        tags: List[KeyValuePair] = None,
        type: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # sum或none
        self.aggregator = aggregator
        # 结束毫秒时间戳
        self.end_time = end_time
        # 开始毫秒时间戳
        self.start_time = start_time
        # metrics字段名称
        self.metrics = metrics
        # 扩展字段tags
        self.tags = tags
        # metrics类型
        self.type = type
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.aggregator, 'aggregator')
        self.validate_required(self.end_time, 'end_time')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.metrics, 'metrics')
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.aggregator is not None:
            result['aggregator'] = self.aggregator
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.metrics is not None:
            result['metrics'] = self.metrics
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('aggregator') is not None:
            self.aggregator = m.get('aggregator')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('metrics') is not None:
            self.metrics = m.get('metrics')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeyValuePair()
                self.tags.append(temp_model.from_map(k))
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryTraceMetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: TimeSeriesMetrics = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # metrics reulsts
        self.result = result

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.result is not None:
            result['result'] = self.result.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('result') is not None:
            temp_model = TimeSeriesMetrics()
            self.result = temp_model.from_map(m['result'])
        return self


class GetCustompluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
        plugin_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 自定义监控指标 ID
        self.id = id
        # 类型
        self.plugin_type = plugin_type

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')
        self.validate_required(self.plugin_type, 'plugin_type')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        if self.plugin_type is not None:
            result['plugin_type'] = self.plugin_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('plugin_type') is not None:
            self.plugin_type = m.get('plugin_type')
        return self


class GetCustompluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        custom_plugin: CustomPluginDO = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 自定义监控指标详情
        self.custom_plugin = custom_plugin

    def validate(self):
        if self.custom_plugin:
            self.custom_plugin.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.custom_plugin is not None:
            result['custom_plugin'] = self.custom_plugin.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('custom_plugin') is not None:
            temp_model = CustomPluginDO()
            self.custom_plugin = temp_model.from_map(m['custom_plugin'])
        return self


class QueryAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        current_page: int = None,
        page_size: int = None,
        keyword: str = None,
        app_names: List[str] = None,
        only_mine: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # 应用名称模糊搜索
        self.keyword = keyword
        # 应用名称列表
        self.app_names = app_names
        # 为true时表示查询我的应用
        self.only_mine = only_mine

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.app_names is not None:
            result['app_names'] = self.app_names
        if self.only_mine is not None:
            result['only_mine'] = self.only_mine
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('app_names') is not None:
            self.app_names = m.get('app_names')
        if m.get('only_mine') is not None:
            self.only_mine = m.get('only_mine')
        return self


class QueryAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        apps: List[MonitorApp] = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 应用列表
        self.apps = apps
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # 总记录数
        self.total_count = total_count

    def validate(self):
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['apps'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.apps = []
        if m.get('apps') is not None:
            for k in m.get('apps'):
                temp_model = MonitorApp()
                self.apps.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class GetUserFavoriteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        resource_type: str = None,
        resource_id: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 收藏资源类型
        self.resource_type = resource_type
        # 收藏资源 ID
        self.resource_id = resource_id
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_id, 'resource_id')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_id is not None:
            result['resource_id'] = self.resource_id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_id') is not None:
            self.resource_id = m.get('resource_id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetUserFavoriteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        status: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 是否收藏
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class QueryFolderRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        parent_folder_id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 父目录 ID
        self.parent_folder_id = parent_folder_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.parent_folder_id, 'parent_folder_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.parent_folder_id is not None:
            result['parent_folder_id'] = self.parent_folder_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('parent_folder_id') is not None:
            self.parent_folder_id = m.get('parent_folder_id')
        return self


class QueryFolderResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        folders: List[FolderDO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 文件夹列表
        self.folders = folders

    def validate(self):
        if self.folders:
            for k in self.folders:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['folders'] = []
        if self.folders is not None:
            for k in self.folders:
                result['folders'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.folders = []
        if m.get('folders') is not None:
            for k in m.get('folders'):
                temp_model = FolderDO()
                self.folders.append(temp_model.from_map(k))
        return self


class QueryCustompluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        parent_folder_id: int = None,
        plugin_type: str = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 父级文件夹 ID
        self.parent_folder_id = parent_folder_id
        # 插件类型
        self.plugin_type = plugin_type
        # 当前页码
        self.current_page = current_page
        # 每页大小
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.parent_folder_id, 'parent_folder_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.parent_folder_id is not None:
            result['parent_folder_id'] = self.parent_folder_id
        if self.plugin_type is not None:
            result['plugin_type'] = self.plugin_type
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('parent_folder_id') is not None:
            self.parent_folder_id = m.get('parent_folder_id')
        if m.get('plugin_type') is not None:
            self.plugin_type = m.get('plugin_type')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryCustompluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        custom_plugins: List[CustomPluginDO] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 自定义指标监控配置列表
        self.custom_plugins = custom_plugins
        # 页面大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 总记录数
        self.total_count = total_count

    def validate(self):
        if self.custom_plugins:
            for k in self.custom_plugins:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['custom_plugins'] = []
        if self.custom_plugins is not None:
            for k in self.custom_plugins:
                result['custom_plugins'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.custom_plugins = []
        if m.get('custom_plugins') is not None:
            for k in m.get('custom_plugins'):
                temp_model = CustomPluginDO()
                self.custom_plugins.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class QueryUserFavoriteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        resource_ids: List[str] = None,
        resource_type: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 收藏资源 ID 列表
        self.resource_ids = resource_ids
        # 收藏资源类型
        self.resource_type = resource_type
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.resource_ids, 'resource_ids')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.resource_ids is not None:
            result['resource_ids'] = self.resource_ids
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('resource_ids') is not None:
            self.resource_ids = m.get('resource_ids')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryUserFavoriteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        favorites: List[UserFavoriteVO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 用户收藏的资源列表
        self.favorites = favorites

    def validate(self):
        if self.favorites:
            for k in self.favorites:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['favorites'] = []
        if self.favorites is not None:
            for k in self.favorites:
                result['favorites'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.favorites = []
        if m.get('favorites') is not None:
            for k in m.get('favorites'):
                temp_model = UserFavoriteVO()
                self.favorites.append(temp_model.from_map(k))
        return self


class QueryAlarmPauseRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class QueryAlarmPauseResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CountAlarmAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start: int = None,
        end: int = None,
        app_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 开始时间 - 时间戳
        self.start = start
        # 结束时间 - 时间戳
        self.end = end
        # 应用名称模糊搜索
        self.app_name = app_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.app_name is not None:
            result['app_name'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        return self


class CountAlarmAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_apps: List[AlarmAppStats] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警应用
        self.alarm_apps = alarm_apps

    def validate(self):
        if self.alarm_apps:
            for k in self.alarm_apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_apps'] = []
        if self.alarm_apps is not None:
            for k in self.alarm_apps:
                result['alarm_apps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_apps = []
        if m.get('alarm_apps') is not None:
            for k in m.get('alarm_apps'):
                temp_model = AlarmAppStats()
                self.alarm_apps.append(temp_model.from_map(k))
        return self


class QueryAlarmApprelationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        from_: int = None,
        to: int = None,
        app_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 开始时间 - 时间戳
        self.from_ = from_
        # 结束时间 - 时间戳
        self.to = to
        # 应用名称
        self.app_name = app_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        if self.app_name is not None:
            result['app_name'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        return self


class QueryAlarmApprelationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[AlarmHistoryListKeySetMap] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警应用关联信息
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = AlarmHistoryListKeySetMap()
                self.result.append(temp_model.from_map(k))
        return self


class BatchqueryStackGeneratedconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_names: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名列表
        self.app_names = app_names

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_names is not None:
            result['app_names'] = self.app_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_names') is not None:
            self.app_names = m.get('app_names')
        return self


class BatchqueryStackGeneratedconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        generated_configs: List[StackGeneratedConfig] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 技术栈配置列表
        self.generated_configs = generated_configs

    def validate(self):
        if self.generated_configs:
            for k in self.generated_configs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['generated_configs'] = []
        if self.generated_configs is not None:
            for k in self.generated_configs:
                result['generated_configs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.generated_configs = []
        if m.get('generated_configs') is not None:
            for k in m.get('generated_configs'):
                temp_model = StackGeneratedConfig()
                self.generated_configs.append(temp_model.from_map(k))
        return self


class ListDashboardRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        dashboard_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 大盘类型：MINE(我的大盘)、CORE(关键大盘)
        self.dashboard_type = dashboard_type

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.dashboard_type, 'dashboard_type')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.dashboard_type is not None:
            result['dashboard_type'] = self.dashboard_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('dashboard_type') is not None:
            self.dashboard_type = m.get('dashboard_type')
        return self


class ListDashboardResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        dashboards: List[PluginModelDO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 大盘列表
        self.dashboards = dashboards

    def validate(self):
        if self.dashboards:
            for k in self.dashboards:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['dashboards'] = []
        if self.dashboards is not None:
            for k in self.dashboards:
                result['dashboards'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.dashboards = []
        if m.get('dashboards') is not None:
            for k in m.get('dashboards'):
                temp_model = PluginModelDO()
                self.dashboards.append(temp_model.from_map(k))
        return self


class QueryStackGeneratedconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        stack_universal_table_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 栈实体对象复合ID
        self.stack_universal_table_id = stack_universal_table_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.stack_universal_table_id, 'stack_universal_table_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        return self


class QueryStackGeneratedconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        generated_configs: List[StackGeneratedConfig] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 栈配置列表
        self.generated_configs = generated_configs

    def validate(self):
        if self.generated_configs:
            for k in self.generated_configs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['generated_configs'] = []
        if self.generated_configs is not None:
            for k in self.generated_configs:
                result['generated_configs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.generated_configs = []
        if m.get('generated_configs') is not None:
            for k in m.get('generated_configs'):
                temp_model = StackGeneratedConfig()
                self.generated_configs.append(temp_model.from_map(k))
        return self


class QueryStackMonitoritemRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        stack_id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 技术栈 ID
        self.stack_id = stack_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.stack_id, 'stack_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.stack_id is not None:
            result['stack_id'] = self.stack_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('stack_id') is not None:
            self.stack_id = m.get('stack_id')
        return self


class QueryStackMonitoritemResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        monitor_items: List[StackMonitorItem] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 监控项列表
        self.monitor_items = monitor_items

    def validate(self):
        if self.monitor_items:
            for k in self.monitor_items:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['monitor_items'] = []
        if self.monitor_items is not None:
            for k in self.monitor_items:
                result['monitor_items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.monitor_items = []
        if m.get('monitor_items') is not None:
            for k in m.get('monitor_items'):
                temp_model = StackMonitorItem()
                self.monitor_items.append(temp_model.from_map(k))
        return self


class QueryUsergroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        user_login_names: str = None,
        page_size: int = None,
        current_page: int = None,
        keyword: str = None,
        only_current_staff: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 联系人登录名称数组
        self.user_login_names = user_login_names
        # 页面大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 通知组名称
        self.keyword = keyword
        # 是否只查询当前操作者的
        self.only_current_staff = only_current_staff

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.user_login_names is not None:
            result['user_login_names'] = self.user_login_names
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.only_current_staff is not None:
            result['only_current_staff'] = self.only_current_staff
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('user_login_names') is not None:
            self.user_login_names = m.get('user_login_names')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('only_current_staff') is not None:
            self.only_current_staff = m.get('only_current_staff')
        return self


class QueryUsergroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        user_groups: List[UserGroup] = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 通知组列表
        self.user_groups = user_groups
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # 总记录数
        self.total_count = total_count

    def validate(self):
        if self.user_groups:
            for k in self.user_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['user_groups'] = []
        if self.user_groups is not None:
            for k in self.user_groups:
                result['user_groups'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.user_groups = []
        if m.get('user_groups') is not None:
            for k in m.get('user_groups'):
                temp_model = UserGroup()
                self.user_groups.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class CreateUsergroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        name: str = None,
        dingtalk_webhooks: List[str] = None,
        user_login_names: List[str] = None,
        valid_scope: int = None,
        ding_ding_robots: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 通知组名称
        self.name = name
        # 钉钉机器人token数组
        self.dingtalk_webhooks = dingtalk_webhooks
        # 联系人登录名称数组
        self.user_login_names = user_login_names
        # 0、当前workspace有效；
        # 1、当前租户有效
        self.valid_scope = valid_scope
        # 钉钉机器人
        self.ding_ding_robots = ding_ding_robots

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.name, 'name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.name is not None:
            result['name'] = self.name
        if self.dingtalk_webhooks is not None:
            result['dingtalk_webhooks'] = self.dingtalk_webhooks
        if self.user_login_names is not None:
            result['user_login_names'] = self.user_login_names
        if self.valid_scope is not None:
            result['valid_scope'] = self.valid_scope
        if self.ding_ding_robots is not None:
            result['ding_ding_robots'] = self.ding_ding_robots
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('dingtalk_webhooks') is not None:
            self.dingtalk_webhooks = m.get('dingtalk_webhooks')
        if m.get('user_login_names') is not None:
            self.user_login_names = m.get('user_login_names')
        if m.get('valid_scope') is not None:
            self.valid_scope = m.get('valid_scope')
        if m.get('ding_ding_robots') is not None:
            self.ding_ding_robots = m.get('ding_ding_robots')
        return self


class CreateUsergroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        group_id: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 通知组 ID
        self.group_id = group_id

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.group_id is not None:
            result['group_id'] = self.group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('group_id') is not None:
            self.group_id = m.get('group_id')
        return self


class UpdateUsergroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
        name: str = None,
        dingtalk_webhooks: List[str] = None,
        user_login_names: List[str] = None,
        scope_global: bool = None,
        valid_scope: int = None,
        ding_ding_robots: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 通知组 ID
        self.id = id
        # 通知组名称
        self.name = name
        # 钉钉机器人token数组
        self.dingtalk_webhooks = dingtalk_webhooks
        # 联系人登录名称数组
        self.user_login_names = user_login_names
        # 全局订阅
        self.scope_global = scope_global
        # 0、当前workspace有效；
        # 1、租户有效；
        self.valid_scope = valid_scope
        # 钉钉机器人
        self.ding_ding_robots = ding_ding_robots

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.dingtalk_webhooks is not None:
            result['dingtalk_webhooks'] = self.dingtalk_webhooks
        if self.user_login_names is not None:
            result['user_login_names'] = self.user_login_names
        if self.scope_global is not None:
            result['scope_global'] = self.scope_global
        if self.valid_scope is not None:
            result['valid_scope'] = self.valid_scope
        if self.ding_ding_robots is not None:
            result['ding_ding_robots'] = self.ding_ding_robots
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('dingtalk_webhooks') is not None:
            self.dingtalk_webhooks = m.get('dingtalk_webhooks')
        if m.get('user_login_names') is not None:
            self.user_login_names = m.get('user_login_names')
        if m.get('scope_global') is not None:
            self.scope_global = m.get('scope_global')
        if m.get('valid_scope') is not None:
            self.valid_scope = m.get('valid_scope')
        if m.get('ding_ding_robots') is not None:
            self.ding_ding_robots = m.get('ding_ding_robots')
        return self


class UpdateUsergroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteUsergroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 通知组 ID
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteUsergroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryAlarmTrendRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start: int = None,
        end: int = None,
        alarm_types: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 开始时间
        self.start = start
        # 结束时间
        self.end = end
        # 告警类型 (固定传入自定义、应用、应用组3个告警类型)
        self.alarm_types = alarm_types

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        self.validate_required(self.alarm_types, 'alarm_types')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.alarm_types is not None:
            result['alarm_types'] = self.alarm_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('alarm_types') is not None:
            self.alarm_types = m.get('alarm_types')
        return self


class QueryAlarmTrendResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AlarmCountInfoKeySet] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 返回数据
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AlarmCountInfoKeySet()
                self.data.append(temp_model.from_map(k))
        return self


class QueryAlarmHistoryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start: int = None,
        end: int = None,
        all_types: bool = None,
        alarm_types: List[str] = None,
        current_page: int = None,
        page_size: int = None,
        dsid: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 开始时间
        self.start = start
        # 结束时间
        self.end = end
        # 是否查询所有告警类型
        self.all_types = all_types
        # 告警类型数组
        self.alarm_types = alarm_types
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # dsid
        self.dsid = dsid

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        self.validate_required(self.all_types, 'all_types')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.all_types is not None:
            result['all_types'] = self.all_types
        if self.alarm_types is not None:
            result['alarm_types'] = self.alarm_types
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.dsid is not None:
            result['dsid'] = self.dsid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('all_types') is not None:
            self.all_types = m.get('all_types')
        if m.get('alarm_types') is not None:
            self.alarm_types = m.get('alarm_types')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('dsid') is not None:
            self.dsid = m.get('dsid')
        return self


class QueryAlarmHistoryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_historys: List[AlarmHistory] = None,
        total_count: int = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警历史数组
        self.alarm_historys = alarm_historys
        # 总记录数
        self.total_count = total_count
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size

    def validate(self):
        if self.alarm_historys:
            for k in self.alarm_historys:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_historys'] = []
        if self.alarm_historys is not None:
            for k in self.alarm_historys:
                result['alarm_historys'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_historys = []
        if m.get('alarm_historys') is not None:
            for k in m.get('alarm_historys'):
                temp_model = AlarmHistory()
                self.alarm_historys.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryAlarmSubscriptionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        only_mine: bool = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 是否只查询我的订阅
        self.only_mine = only_mine
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.only_mine is not None:
            result['only_mine'] = self.only_mine
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('only_mine') is not None:
            self.only_mine = m.get('only_mine')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryAlarmSubscriptionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_subscriptions: List[AlarmSubDTO] = None,
        total_count: int = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警订阅数组
        self.alarm_subscriptions = alarm_subscriptions
        # 总记录数
        self.total_count = total_count
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size

    def validate(self):
        if self.alarm_subscriptions:
            for k in self.alarm_subscriptions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_subscriptions'] = []
        if self.alarm_subscriptions is not None:
            for k in self.alarm_subscriptions:
                result['alarm_subscriptions'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_subscriptions = []
        if m.get('alarm_subscriptions') is not None:
            for k in m.get('alarm_subscriptions'):
                temp_model = AlarmSubDTO()
                self.alarm_subscriptions.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryStackAlarmruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        stack_universal_table_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 栈实体对象复合ID
        self.stack_universal_table_id = stack_universal_table_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.stack_universal_table_id, 'stack_universal_table_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.stack_universal_table_id is not None:
            result['stack_universal_table_id'] = self.stack_universal_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('stack_universal_table_id') is not None:
            self.stack_universal_table_id = m.get('stack_universal_table_id')
        return self


class QueryStackAlarmruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_rules: List[StackAlarmRule] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警套餐配置数组
        self.alarm_rules = alarm_rules

    def validate(self):
        if self.alarm_rules:
            for k in self.alarm_rules:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_rules'] = []
        if self.alarm_rules is not None:
            for k in self.alarm_rules:
                result['alarm_rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_rules = []
        if m.get('alarm_rules') is not None:
            for k in m.get('alarm_rules'):
                temp_model = StackAlarmRule()
                self.alarm_rules.append(temp_model.from_map(k))
        return self


class UpdateCustompluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        custom_plugin: CustomPluginDO = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 自定义监控指标详细信息 (嵌套对象)
        self.custom_plugin = custom_plugin

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.custom_plugin, 'custom_plugin')
        if self.custom_plugin:
            self.custom_plugin.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.custom_plugin is not None:
            result['custom_plugin'] = self.custom_plugin.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('custom_plugin') is not None:
            temp_model = CustomPluginDO()
            self.custom_plugin = temp_model.from_map(m['custom_plugin'])
        return self


class UpdateCustompluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryAgentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        page_size: int = None,
        current_page: int = None,
        deploy_type: str = None,
        keyword: str = None,
        app_keyword: str = None,
        service_ip_keyword: str = None,
        host_ip_keyword: str = None,
        status: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 每页大小
        self.page_size = page_size
        # 当前页码
        self.current_page = current_page
        # agent部署类型：容器CONTAINER、经典MACHINE
        self.deploy_type = deploy_type
        # 模糊搜索关键字
        self.keyword = keyword
        # app 模糊搜索关键字
        self.app_keyword = app_keyword
        # 服务 IP 模糊搜索关键字
        self.service_ip_keyword = service_ip_keyword
        # 主机 IP 模糊搜索关键字
        self.host_ip_keyword = host_ip_keyword
        # agent 状态
        self.status = status

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.deploy_type is not None:
            result['deploy_type'] = self.deploy_type
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.app_keyword is not None:
            result['app_keyword'] = self.app_keyword
        if self.service_ip_keyword is not None:
            result['service_ip_keyword'] = self.service_ip_keyword
        if self.host_ip_keyword is not None:
            result['host_ip_keyword'] = self.host_ip_keyword
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('deploy_type') is not None:
            self.deploy_type = m.get('deploy_type')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('app_keyword') is not None:
            self.app_keyword = m.get('app_keyword')
        if m.get('service_ip_keyword') is not None:
            self.service_ip_keyword = m.get('service_ip_keyword')
        if m.get('host_ip_keyword') is not None:
            self.host_ip_keyword = m.get('host_ip_keyword')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class QueryAgentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        agent_instances: List[AgentInstance] = None,
        total_count: int = None,
        page_size: int = None,
        current_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # agent 实例列表
        self.agent_instances = agent_instances
        # agent 实例总数
        self.total_count = total_count
        # 每页大小
        self.page_size = page_size
        # 当前页码
        self.current_page = current_page

    def validate(self):
        if self.agent_instances:
            for k in self.agent_instances:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['agent_instances'] = []
        if self.agent_instances is not None:
            for k in self.agent_instances:
                result['agent_instances'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.agent_instances = []
        if m.get('agent_instances') is not None:
            for k in m.get('agent_instances'):
                temp_model = AgentInstance()
                self.agent_instances.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        return self


class InstallAgentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        collect_ids: List[str] = None,
        type: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 需要安装 agent 的目标列表
        self.collect_ids = collect_ids
        # 0 容器，1经典
        self.type = type

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.collect_ids is not None:
            result['collect_ids'] = self.collect_ids
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('collect_ids') is not None:
            self.collect_ids = m.get('collect_ids')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class InstallAgentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetAgentVersionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        collect_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # agent 机器对应的唯一标识
        self.collect_id = collect_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.collect_id is not None:
            result['collect_id'] = self.collect_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('collect_id') is not None:
            self.collect_id = m.get('collect_id')
        return self


class GetAgentVersionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        agent_version: AgentVersion = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # agent版本信息
        self.agent_version = agent_version

    def validate(self):
        if self.agent_version:
            self.agent_version.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.agent_version is not None:
            result['agent_version'] = self.agent_version.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('agent_version') is not None:
            temp_model = AgentVersion()
            self.agent_version = temp_model.from_map(m['agent_version'])
        return self


class EnableAgentVersionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        agent_version: str = None,
        agent_url: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # agent版本号
        self.agent_version = agent_version
        # agent存储url
        self.agent_url = agent_url

    def validate(self):
        self.validate_required(self.agent_version, 'agent_version')
        self.validate_required(self.agent_url, 'agent_url')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.agent_version is not None:
            result['agent_version'] = self.agent_version
        if self.agent_url is not None:
            result['agent_url'] = self.agent_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('agent_version') is not None:
            self.agent_version = m.get('agent_version')
        if m.get('agent_url') is not None:
            self.agent_url = m.get('agent_url')
        return self


class EnableAgentVersionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        agent_version: AgentVersion = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 版本信息
        self.agent_version = agent_version

    def validate(self):
        if self.agent_version:
            self.agent_version.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.agent_version is not None:
            result['agent_version'] = self.agent_version.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('agent_version') is not None:
            temp_model = AgentVersion()
            self.agent_version = temp_model.from_map(m['agent_version'])
        return self


class GetWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace: Workspace = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 工作空间
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace') is not None:
            temp_model = Workspace()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class GetTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class GetTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenant: Tenant = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 租户
        self.tenant = tenant

    def validate(self):
        if self.tenant:
            self.tenant.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.tenant is not None:
            result['tenant'] = self.tenant.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('tenant') is not None:
            temp_model = Tenant()
            self.tenant = temp_model.from_map(m['tenant'])
        return self


class QueryKernelstackGeneratedconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        simple_table_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 不带租户id和workspaceId的universalTableId后缀
        self.simple_table_id = simple_table_id

    def validate(self):
        self.validate_required(self.simple_table_id, 'simple_table_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.simple_table_id is not None:
            result['simple_table_id'] = self.simple_table_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('simple_table_id') is not None:
            self.simple_table_id = m.get('simple_table_id')
        return self


class QueryKernelstackGeneratedconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        generated_configs: List[StackGeneratedConfig] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 栈配置列表
        self.generated_configs = generated_configs

    def validate(self):
        if self.generated_configs:
            for k in self.generated_configs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['generated_configs'] = []
        if self.generated_configs is not None:
            for k in self.generated_configs:
                result['generated_configs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.generated_configs = []
        if m.get('generated_configs') is not None:
            for k in m.get('generated_configs'):
                temp_model = StackGeneratedConfig()
                self.generated_configs.append(temp_model.from_map(k))
        return self


class GetAliyunStatusRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class GetAliyunStatusResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        status: AliyunOpenState = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 阿里云开通状态
        self.status = status

    def validate(self):
        if self.status:
            self.status.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.status is not None:
            result['status'] = self.status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('status') is not None:
            temp_model = AliyunOpenState()
            self.status = temp_model.from_map(m['status'])
        return self


class OpenWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        workspace_display_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 工作空间展示名称
        self.workspace_display_name = workspace_display_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.workspace_display_name is not None:
            result['workspace_display_name'] = self.workspace_display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('workspace_display_name') is not None:
            self.workspace_display_name = m.get('workspace_display_name')
        return self


class OpenWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace: Workspace = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 工作空间信息
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace') is not None:
            temp_model = Workspace()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class UpdateStackGeneratedconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        generated_config: StackGeneratedConfig = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 待修改的技术栈配置
        self.generated_config = generated_config

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.generated_config, 'generated_config')
        if self.generated_config:
            self.generated_config.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.generated_config is not None:
            result['generated_config'] = self.generated_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('generated_config') is not None:
            temp_model = StackGeneratedConfig()
            self.generated_config = temp_model.from_map(m['generated_config'])
        return self


class UpdateStackGeneratedconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUserRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        keyword: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 用户名(支持模糊搜索)
        self.keyword = keyword

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.keyword, 'keyword')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.keyword is not None:
            result['keyword'] = self.keyword
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        return self


class QueryUserResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        users: List[MonitorUserDO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 用户列表
        self.users = users

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['users'] = []
        if self.users is not None:
            for k in self.users:
                result['users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.users = []
        if m.get('users') is not None:
            for k in m.get('users'):
                temp_model = MonitorUserDO()
                self.users.append(temp_model.from_map(k))
        return self


class ListAuthRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        auth: str = None,
        resource_type: str = None,
        resource_ids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 权限码
        self.auth = auth
        # 资源类型（取值范围：CUSTOM_PLUGIN(自定义监控)、FOLDER(文件夹)、UNIVERSAL_TABLE(用户应用)）
        self.resource_type = resource_type
        # 资源ID列表
        self.resource_ids = resource_ids

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.auth, 'auth')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_ids, 'resource_ids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.auth is not None:
            result['auth'] = self.auth
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_ids is not None:
            result['resource_ids'] = self.resource_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('auth') is not None:
            self.auth = m.get('auth')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_ids') is not None:
            self.resource_ids = m.get('resource_ids')
        return self


class ListAuthResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AuthDO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 权限列表
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AuthDO()
                self.data.append(temp_model.from_map(k))
        return self


class DeleteAuthRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 待删除的权限ID
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteAuthResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateAuthRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        auth: str = None,
        user_names: List[str] = None,
        resource_type: str = None,
        resource_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 权限码
        self.auth = auth
        # 用户名列表
        self.user_names = user_names
        # 权限的资源类型（取值范围：CUSTOM_PLUGIN(自定义监控)、FOLDER(文件夹)、UNIVERSAL_TABLE(用户应用)）
        self.resource_type = resource_type
        # 权限对应的资源ID
        self.resource_id = resource_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.auth, 'auth')
        self.validate_required(self.user_names, 'user_names')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_id, 'resource_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.auth is not None:
            result['auth'] = self.auth
        if self.user_names is not None:
            result['user_names'] = self.user_names
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_id is not None:
            result['resource_id'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('auth') is not None:
            self.auth = m.get('auth')
        if m.get('user_names') is not None:
            self.user_names = m.get('user_names')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_id') is not None:
            self.resource_id = m.get('resource_id')
        return self


class CreateAuthResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchcreateUserFavoriteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        resource_type: str = None,
        resource_ids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 收藏资源类型（取值范围：CUSTOM_PLUGIN(自定义监控)、FOLDER(文件夹)、UNIVERSAL_TABLE(用户应用)）
        self.resource_type = resource_type
        # 收藏资源ID列表，需要是相同类型下的ID (如果是自定义监控或文件夹，为数值类型，如果是用户应用，是复杂组合字符串)
        self.resource_ids = resource_ids

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_ids, 'resource_ids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_ids is not None:
            result['resource_ids'] = self.resource_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_ids') is not None:
            self.resource_ids = m.get('resource_ids')
        return self


class BatchcreateUserFavoriteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteUserFavoriteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        resource_type: str = None,
        resource_ids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 资源类型
        self.resource_type = resource_type
        # 已收藏资源ID列表（文件夹，传入文件夹ID；自定义监控，传入自定义监控ID；应用，传入universal_table_id）
        self.resource_ids = resource_ids

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_ids, 'resource_ids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_ids is not None:
            result['resource_ids'] = self.resource_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_ids') is not None:
            self.resource_ids = m.get('resource_ids')
        return self


class BatchdeleteUserFavoriteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUserOperationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start: int = None,
        end: int = None,
        table_name: str = None,
        table_entity_id: int = None,
        page_size: int = None,
        current_page: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 开始时间
        self.start = start
        # 结束时间
        self.end = end
        # 表名
        self.table_name = table_name
        # 表实体对应ID
        self.table_entity_id = table_entity_id
        # 页面大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        self.validate_required(self.table_name, 'table_name')
        self.validate_required(self.table_entity_id, 'table_entity_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.table_name is not None:
            result['table_name'] = self.table_name
        if self.table_entity_id is not None:
            result['table_entity_id'] = self.table_entity_id
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('table_name') is not None:
            self.table_name = m.get('table_name')
        if m.get('table_entity_id') is not None:
            self.table_entity_id = m.get('table_entity_id')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        return self


class QueryUserOperationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        operations: List[UserOplogDO] = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 操作日志列表
        self.operations = operations
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # 总记录数
        self.total_count = total_count

    def validate(self):
        if self.operations:
            for k in self.operations:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['operations'] = []
        if self.operations is not None:
            for k in self.operations:
                result['operations'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.operations = []
        if m.get('operations') is not None:
            for k in m.get('operations'):
                temp_model = UserOplogDO()
                self.operations.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class CreateAlarmSubscriptionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        alarm_level: int = None,
        notify_reduce_switch: int = None,
        resource_type: str = None,
        resource_id: str = None,
        user_login_names: List[str] = None,
        user_group_ids: List[int] = None,
        alarm_web_hook_ids: List[int] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 告警等级 (-1表示全部订阅)
        self.alarm_level = alarm_level
        # 是否开启通知降频 (0 - 关闭，1 - 开启)
        self.notify_reduce_switch = notify_reduce_switch
        # 资源类型（取值范围：CUSTOM_PLUGIN(自定义监控)、FOLDER(文件夹)、UNIVERSAL_TABLE(用户应用)）
        self.resource_type = resource_type
        # 资源 ID
        self.resource_id = resource_id
        # 用户登录名列表
        self.user_login_names = user_login_names
        # 用户组 ID列表
        self.user_group_ids = user_group_ids
        # http web hook id列表
        self.alarm_web_hook_ids = alarm_web_hook_ids

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.notify_reduce_switch, 'notify_reduce_switch')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_id, 'resource_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.notify_reduce_switch is not None:
            result['notify_reduce_switch'] = self.notify_reduce_switch
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_id is not None:
            result['resource_id'] = self.resource_id
        if self.user_login_names is not None:
            result['user_login_names'] = self.user_login_names
        if self.user_group_ids is not None:
            result['user_group_ids'] = self.user_group_ids
        if self.alarm_web_hook_ids is not None:
            result['alarm_web_hook_ids'] = self.alarm_web_hook_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('notify_reduce_switch') is not None:
            self.notify_reduce_switch = m.get('notify_reduce_switch')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_id') is not None:
            self.resource_id = m.get('resource_id')
        if m.get('user_login_names') is not None:
            self.user_login_names = m.get('user_login_names')
        if m.get('user_group_ids') is not None:
            self.user_group_ids = m.get('user_group_ids')
        if m.get('alarm_web_hook_ids') is not None:
            self.alarm_web_hook_ids = m.get('alarm_web_hook_ids')
        return self


class CreateAlarmSubscriptionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteAlarmSubscriptionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 待删除的告警订阅 ID
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteAlarmSubscriptionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class PauseAlarmRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start: int = None,
        end: int = None,
        reason: str = None,
        resource_type: str = None,
        resource_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 告警暂停开始时间
        self.start = start
        # 告警暂停结束时间
        self.end = end
        # 告警关闭原因
        self.reason = reason
        # 资源类型（取值范围：CUSTOM_PLUGIN(自定义监控)、FOLDER(文件夹)、UNIVERSAL_TABLE(用户应用)）
        self.resource_type = resource_type
        # 资源 ID
        self.resource_id = resource_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        self.validate_required(self.reason, 'reason')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_id, 'resource_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.reason is not None:
            result['reason'] = self.reason
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_id is not None:
            result['resource_id'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_id') is not None:
            self.resource_id = m.get('resource_id')
        return self


class PauseAlarmResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ResumeAlarmRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 待恢复的告警 ID
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class ResumeAlarmResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetLogTailRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        prefer_host: str = None,
        full_path: str = None,
        scan_dirs: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # the preferHost
        self.prefer_host = prefer_host
        # 日志完整路径
        self.full_path = full_path
        # 扫描路径
        self.scan_dirs = scan_dirs

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.prefer_host is not None:
            result['prefer_host'] = self.prefer_host
        if self.full_path is not None:
            result['full_path'] = self.full_path
        if self.scan_dirs is not None:
            result['scan_dirs'] = self.scan_dirs
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('prefer_host') is not None:
            self.prefer_host = m.get('prefer_host')
        if m.get('full_path') is not None:
            self.full_path = m.get('full_path')
        if m.get('scan_dirs') is not None:
            self.scan_dirs = m.get('scan_dirs')
        return self


class GetLogTailResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        log_tail: LogTail = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 返回对象
        self.log_tail = log_tail

    def validate(self):
        if self.log_tail:
            self.log_tail.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.log_tail is not None:
            result['log_tail'] = self.log_tail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('log_tail') is not None:
            temp_model = LogTail()
            self.log_tail = temp_model.from_map(m['log_tail'])
        return self


class GetLogBrowserRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        scan_dirs: List[str] = None,
        prefer_host: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 扫描根目录
        self.scan_dirs = scan_dirs
        # preferHost
        self.prefer_host = prefer_host

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.scan_dirs, 'scan_dirs')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.scan_dirs is not None:
            result['scan_dirs'] = self.scan_dirs
        if self.prefer_host is not None:
            result['prefer_host'] = self.prefer_host
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('scan_dirs') is not None:
            self.scan_dirs = m.get('scan_dirs')
        if m.get('prefer_host') is not None:
            self.prefer_host = m.get('prefer_host')
        return self


class GetLogBrowserResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 返回结果，JSON String
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class DeleteFolderRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 主键 ID
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteFolderResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetAppOverviewRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        end_time: int = None,
        start_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 查询截止时间，unix timestamp in ms
        self.end_time = end_time
        # 查询开始时间，unix timestamp in ms
        self.start_time = start_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.start_time is not None:
            result['start_time'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        return self


class GetAppOverviewResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: AppOverviewDTO = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 返回结果
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = AppOverviewDTO()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryUnifiedalarmHistoryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start: int = None,
        end: int = None,
        current_page: int = None,
        page_size: int = None,
        alarm_target_type: str = None,
        alarm_target: str = None,
        alarm_level: int = None,
        status: int = None,
        alarm_stack_info: AlarmStackInfo = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 开始时间
        self.start = start
        # 结束时间
        self.end = end
        # 当前页码
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # 应用 / 主机
        self.alarm_target_type = alarm_target_type
        # 告警对象
        self.alarm_target = alarm_target
        # 告警级别
        self.alarm_level = alarm_level
        # 触发状态
        self.status = status
        # 根据应用过滤告警历史
        self.alarm_stack_info = alarm_stack_info

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        if self.alarm_stack_info:
            self.alarm_stack_info.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.alarm_target is not None:
            result['alarm_target'] = self.alarm_target
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.status is not None:
            result['status'] = self.status
        if self.alarm_stack_info is not None:
            result['alarm_stack_info'] = self.alarm_stack_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('alarm_target') is not None:
            self.alarm_target = m.get('alarm_target')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('alarm_stack_info') is not None:
            temp_model = AlarmStackInfo()
            self.alarm_stack_info = temp_model.from_map(m['alarm_stack_info'])
        return self


class QueryUnifiedalarmHistoryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_histories: List[UnifiedAlarmHistoryVO] = None,
        total_count: int = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警历史列表
        self.alarm_histories = alarm_histories
        # 总数
        self.total_count = total_count
        # 当前页
        self.current_page = current_page
        # 每页大小
        self.page_size = page_size

    def validate(self):
        if self.alarm_histories:
            for k in self.alarm_histories:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_histories'] = []
        if self.alarm_histories is not None:
            for k in self.alarm_histories:
                result['alarm_histories'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_histories = []
        if m.get('alarm_histories') is not None:
            for k in m.get('alarm_histories'):
                temp_model = UnifiedAlarmHistoryVO()
                self.alarm_histories.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class GetAlarmTestRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        alarm_unique_name: str = None,
        type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 告警规则的唯一名称
        self.alarm_unique_name = alarm_unique_name
        # 类型
        self.type = type

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.alarm_unique_name, 'alarm_unique_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.alarm_unique_name is not None:
            result['alarm_unique_name'] = self.alarm_unique_name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('alarm_unique_name') is not None:
            self.alarm_unique_name = m.get('alarm_unique_name')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetAlarmTestResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: str = None,
        alarm_context: List[AlarmTest] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 数据结果
        self.result = result
        # 测试
        self.alarm_context = alarm_context

    def validate(self):
        if self.alarm_context:
            for k in self.alarm_context:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.result is not None:
            result['result'] = self.result
        result['alarm_context'] = []
        if self.alarm_context is not None:
            for k in self.alarm_context:
                result['alarm_context'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('result') is not None:
            self.result = m.get('result')
        self.alarm_context = []
        if m.get('alarm_context') is not None:
            for k in m.get('alarm_context'):
                temp_model = AlarmTest()
                self.alarm_context.append(temp_model.from_map(k))
        return self


class QueryAlarmwebhookRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        create_or_modify_by_me: bool = None,
        current_page: int = None,
        page_size: int = None,
        name: str = None,
        modifier: str = None,
        ids: List[int] = None,
        only_current_staff: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # createOrModifyByMe
        self.create_or_modify_by_me = create_or_modify_by_me
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # webhook名称
        self.name = name
        # 修改人
        self.modifier = modifier
        # ID列表
        self.ids = ids
        # 是否只查询当前操作者的
        self.only_current_staff = only_current_staff

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.create_or_modify_by_me, 'create_or_modify_by_me')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.create_or_modify_by_me is not None:
            result['create_or_modify_by_me'] = self.create_or_modify_by_me
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.name is not None:
            result['name'] = self.name
        if self.modifier is not None:
            result['modifier'] = self.modifier
        if self.ids is not None:
            result['ids'] = self.ids
        if self.only_current_staff is not None:
            result['only_current_staff'] = self.only_current_staff
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('create_or_modify_by_me') is not None:
            self.create_or_modify_by_me = m.get('create_or_modify_by_me')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('modifier') is not None:
            self.modifier = m.get('modifier')
        if m.get('ids') is not None:
            self.ids = m.get('ids')
        if m.get('only_current_staff') is not None:
            self.only_current_staff = m.get('only_current_staff')
        return self


class QueryAlarmwebhookResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        web_hooks: List[AlarmWebHook] = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # webhook列表
        self.web_hooks = web_hooks
        # 当前页
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size
        # 总记录数
        self.total_count = total_count

    def validate(self):
        if self.web_hooks:
            for k in self.web_hooks:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['web_hooks'] = []
        if self.web_hooks is not None:
            for k in self.web_hooks:
                result['web_hooks'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.web_hooks = []
        if m.get('web_hooks') is not None:
            for k in m.get('web_hooks'):
                temp_model = AlarmWebHook()
                self.web_hooks.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class CreateUnifiedalarmRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        category: str = None,
        rule_config: str = None,
        alarm_nodata: int = None,
        level: int = None,
        emergency: str = None,
        emergency_url: str = None,
        pending_hit: int = None,
        recovered_hit: int = None,
        step: int = None,
        channels: List[str] = None,
        notify_target: List[UnifiedAlarmSubDTO] = None,
        silence_time: int = None,
        notify_firing: int = None,
        notify_recovered: int = None,
        notify_nodata: int = None,
        notify_time_filter: TimeFilter = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 告警规则名称
        self.name = name
        # 标识符 区分规则是自定义规则还是pql规则
        self.category = category
        # 规则配置
        self.rule_config = rule_config
        # 指标无数据触发告警 这是个开关 1表示打开 0表示闭合
        self.alarm_nodata = alarm_nodata
        # 告警等级
        self.level = level
        # 应急处理人
        self.emergency = emergency
        # 应急处理链接
        self.emergency_url = emergency_url
        # 触发周期
        self.pending_hit = pending_hit
        # 恢复周期
        self.recovered_hit = recovered_hit
        # 检测频率
        self.step = step
        # 通知渠道
        self.channels = channels
        # 通知对象
        self.notify_target = notify_target
        # 静默时间
        self.silence_time = silence_time
        # 告警触发时通知 1:勾选 0:不勾选
        self.notify_firing = notify_firing
        # 告警恢复时通知 1:勾选 0:不勾选
        self.notify_recovered = notify_recovered
        # 告警无数据时通知 1:勾选 0:不勾选
        self.notify_nodata = notify_nodata
        # 通知时间
        self.notify_time_filter = notify_time_filter
        # 工作区名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.category, 'category')
        self.validate_required(self.rule_config, 'rule_config')
        self.validate_required(self.alarm_nodata, 'alarm_nodata')
        self.validate_required(self.level, 'level')
        self.validate_required(self.pending_hit, 'pending_hit')
        self.validate_required(self.recovered_hit, 'recovered_hit')
        self.validate_required(self.step, 'step')
        self.validate_required(self.channels, 'channels')
        if self.notify_target:
            for k in self.notify_target:
                if k:
                    k.validate()
        self.validate_required(self.silence_time, 'silence_time')
        self.validate_required(self.notify_firing, 'notify_firing')
        self.validate_required(self.notify_recovered, 'notify_recovered')
        self.validate_required(self.notify_nodata, 'notify_nodata')
        if self.notify_time_filter:
            self.notify_time_filter.validate()
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.category is not None:
            result['category'] = self.category
        if self.rule_config is not None:
            result['rule_config'] = self.rule_config
        if self.alarm_nodata is not None:
            result['alarm_nodata'] = self.alarm_nodata
        if self.level is not None:
            result['level'] = self.level
        if self.emergency is not None:
            result['emergency'] = self.emergency
        if self.emergency_url is not None:
            result['emergency_url'] = self.emergency_url
        if self.pending_hit is not None:
            result['pending_hit'] = self.pending_hit
        if self.recovered_hit is not None:
            result['recovered_hit'] = self.recovered_hit
        if self.step is not None:
            result['step'] = self.step
        if self.channels is not None:
            result['channels'] = self.channels
        result['notify_target'] = []
        if self.notify_target is not None:
            for k in self.notify_target:
                result['notify_target'].append(k.to_map() if k else None)
        if self.silence_time is not None:
            result['silence_time'] = self.silence_time
        if self.notify_firing is not None:
            result['notify_firing'] = self.notify_firing
        if self.notify_recovered is not None:
            result['notify_recovered'] = self.notify_recovered
        if self.notify_nodata is not None:
            result['notify_nodata'] = self.notify_nodata
        if self.notify_time_filter is not None:
            result['notify_time_filter'] = self.notify_time_filter.to_map()
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('rule_config') is not None:
            self.rule_config = m.get('rule_config')
        if m.get('alarm_nodata') is not None:
            self.alarm_nodata = m.get('alarm_nodata')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('emergency') is not None:
            self.emergency = m.get('emergency')
        if m.get('emergency_url') is not None:
            self.emergency_url = m.get('emergency_url')
        if m.get('pending_hit') is not None:
            self.pending_hit = m.get('pending_hit')
        if m.get('recovered_hit') is not None:
            self.recovered_hit = m.get('recovered_hit')
        if m.get('step') is not None:
            self.step = m.get('step')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        self.notify_target = []
        if m.get('notify_target') is not None:
            for k in m.get('notify_target'):
                temp_model = UnifiedAlarmSubDTO()
                self.notify_target.append(temp_model.from_map(k))
        if m.get('silence_time') is not None:
            self.silence_time = m.get('silence_time')
        if m.get('notify_firing') is not None:
            self.notify_firing = m.get('notify_firing')
        if m.get('notify_recovered') is not None:
            self.notify_recovered = m.get('notify_recovered')
        if m.get('notify_nodata') is not None:
            self.notify_nodata = m.get('notify_nodata')
        if m.get('notify_time_filter') is not None:
            temp_model = TimeFilter()
            self.notify_time_filter = temp_model.from_map(m['notify_time_filter'])
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class CreateUnifiedalarmRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateUnifiedalarmRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        name: str = None,
        category: str = None,
        rule_config: str = None,
        alarm_nodata: int = None,
        level: int = None,
        emergency: str = None,
        emergency_url: str = None,
        pending_hit: int = None,
        recovered_hit: int = None,
        step: int = None,
        channels: List[str] = None,
        notify_target: List[UnifiedAlarmSubDTO] = None,
        silence_time: int = None,
        notify_firing: int = None,
        notify_recovered: int = None,
        notify_nodata: int = None,
        notify_time_filter: TimeFilter = None,
        status: str = None,
        suspended_start_time: int = None,
        suspended_end_time: int = None,
        suspended_reason: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 主键
        self.id = id
        # 规则名称
        self.name = name
        # 规则分类
        self.category = category
        # 规则配置
        self.rule_config = rule_config
        # 指标无数据时触发告警
        self.alarm_nodata = alarm_nodata
        # 告警等级
        self.level = level
        # 应急处理人
        self.emergency = emergency
        # 应急处理链接
        self.emergency_url = emergency_url
        # 触发周期
        self.pending_hit = pending_hit
        # 恢复周期
        self.recovered_hit = recovered_hit
        # 检测频率
        self.step = step
        # 通知渠道
        self.channels = channels
        # 通知对象
        self.notify_target = notify_target
        # 静默时间
        self.silence_time = silence_time
        # 告警触发时通知
        self.notify_firing = notify_firing
        # 告警恢复时通知
        self.notify_recovered = notify_recovered
        # 告警无数据时通知
        self.notify_nodata = notify_nodata
        # 通知时间
        self.notify_time_filter = notify_time_filter
        # 启停状态
        self.status = status
        # 暂停开始时间
        self.suspended_start_time = suspended_start_time
        # 告警结束时间
        self.suspended_end_time = suspended_end_time
        # 暂停原因
        self.suspended_reason = suspended_reason
        # 工作空间名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.category, 'category')
        self.validate_required(self.rule_config, 'rule_config')
        self.validate_required(self.alarm_nodata, 'alarm_nodata')
        self.validate_required(self.level, 'level')
        self.validate_required(self.pending_hit, 'pending_hit')
        self.validate_required(self.recovered_hit, 'recovered_hit')
        self.validate_required(self.step, 'step')
        self.validate_required(self.channels, 'channels')
        if self.notify_target:
            for k in self.notify_target:
                if k:
                    k.validate()
        self.validate_required(self.silence_time, 'silence_time')
        self.validate_required(self.notify_firing, 'notify_firing')
        self.validate_required(self.notify_recovered, 'notify_recovered')
        self.validate_required(self.notify_nodata, 'notify_nodata')
        if self.notify_time_filter:
            self.notify_time_filter.validate()
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.category is not None:
            result['category'] = self.category
        if self.rule_config is not None:
            result['rule_config'] = self.rule_config
        if self.alarm_nodata is not None:
            result['alarm_nodata'] = self.alarm_nodata
        if self.level is not None:
            result['level'] = self.level
        if self.emergency is not None:
            result['emergency'] = self.emergency
        if self.emergency_url is not None:
            result['emergency_url'] = self.emergency_url
        if self.pending_hit is not None:
            result['pending_hit'] = self.pending_hit
        if self.recovered_hit is not None:
            result['recovered_hit'] = self.recovered_hit
        if self.step is not None:
            result['step'] = self.step
        if self.channels is not None:
            result['channels'] = self.channels
        result['notify_target'] = []
        if self.notify_target is not None:
            for k in self.notify_target:
                result['notify_target'].append(k.to_map() if k else None)
        if self.silence_time is not None:
            result['silence_time'] = self.silence_time
        if self.notify_firing is not None:
            result['notify_firing'] = self.notify_firing
        if self.notify_recovered is not None:
            result['notify_recovered'] = self.notify_recovered
        if self.notify_nodata is not None:
            result['notify_nodata'] = self.notify_nodata
        if self.notify_time_filter is not None:
            result['notify_time_filter'] = self.notify_time_filter.to_map()
        if self.status is not None:
            result['status'] = self.status
        if self.suspended_start_time is not None:
            result['suspended_start_time'] = self.suspended_start_time
        if self.suspended_end_time is not None:
            result['suspended_end_time'] = self.suspended_end_time
        if self.suspended_reason is not None:
            result['suspended_reason'] = self.suspended_reason
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('rule_config') is not None:
            self.rule_config = m.get('rule_config')
        if m.get('alarm_nodata') is not None:
            self.alarm_nodata = m.get('alarm_nodata')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('emergency') is not None:
            self.emergency = m.get('emergency')
        if m.get('emergency_url') is not None:
            self.emergency_url = m.get('emergency_url')
        if m.get('pending_hit') is not None:
            self.pending_hit = m.get('pending_hit')
        if m.get('recovered_hit') is not None:
            self.recovered_hit = m.get('recovered_hit')
        if m.get('step') is not None:
            self.step = m.get('step')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        self.notify_target = []
        if m.get('notify_target') is not None:
            for k in m.get('notify_target'):
                temp_model = UnifiedAlarmSubDTO()
                self.notify_target.append(temp_model.from_map(k))
        if m.get('silence_time') is not None:
            self.silence_time = m.get('silence_time')
        if m.get('notify_firing') is not None:
            self.notify_firing = m.get('notify_firing')
        if m.get('notify_recovered') is not None:
            self.notify_recovered = m.get('notify_recovered')
        if m.get('notify_nodata') is not None:
            self.notify_nodata = m.get('notify_nodata')
        if m.get('notify_time_filter') is not None:
            temp_model = TimeFilter()
            self.notify_time_filter = temp_model.from_map(m['notify_time_filter'])
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('suspended_start_time') is not None:
            self.suspended_start_time = m.get('suspended_start_time')
        if m.get('suspended_end_time') is not None:
            self.suspended_end_time = m.get('suspended_end_time')
        if m.get('suspended_reason') is not None:
            self.suspended_reason = m.get('suspended_reason')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class UpdateUnifiedalarmRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUnifiedalarmRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        keyword: str = None,
        level: int = None,
        alarm_target: AlarmTarget = None,
        rule_status: int = None,
        alarm_status: int = None,
        only_me: bool = None,
        current_page: int = None,
        page_size: int = None,
        workspace_name: str = None,
        rule_id: int = None,
        rule_unique_identity: str = None,
        category: str = None,
        ref_datasource_type: str = None,
        filter_user_group: int = None,
        filter_webhook: int = None,
        filter_ding_robot: int = None,
        alarm_stack_info: AlarmStackInfo = None,
        data_source_type: str = None,
        levels: List[int] = None,
        alarm_event_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 告警规则名称模糊搜索
        self.keyword = keyword
        # 告警等级
        self.level = level
        # 告警对象
        self.alarm_target = alarm_target
        # 启停状态
        self.rule_status = rule_status
        # 告警状态
        self.alarm_status = alarm_status
        # 只看我
        self.only_me = only_me
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 工作区名
        self.workspace_name = workspace_name
        # 告警规则id
        self.rule_id = rule_id
        # 告警唯一标识
        self.rule_unique_identity = rule_unique_identity
        # 标识符 区分规则是自定义规则还是pql规则
        self.category = category
        # 
        self.ref_datasource_type = ref_datasource_type
        # 根据用户组过滤
        self.filter_user_group = filter_user_group
        # 根据webhook过滤
        self.filter_webhook = filter_webhook
        # 钉钉机器人过滤
        self.filter_ding_robot = filter_ding_robot
        # 根据应栈信息对告警规则做过滤
        self.alarm_stack_info = alarm_stack_info
        # CUSTOM,STACK,HOST
        self.data_source_type = data_source_type
        # 过滤的告警级别
        self.levels = levels
        # 告警事件id
        self.alarm_event_id = alarm_event_id

    def validate(self):
        if self.alarm_target:
            self.alarm_target.validate()
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.category, 'category')
        if self.alarm_stack_info:
            self.alarm_stack_info.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.level is not None:
            result['level'] = self.level
        if self.alarm_target is not None:
            result['alarm_target'] = self.alarm_target.to_map()
        if self.rule_status is not None:
            result['rule_status'] = self.rule_status
        if self.alarm_status is not None:
            result['alarm_status'] = self.alarm_status
        if self.only_me is not None:
            result['only_me'] = self.only_me
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.rule_id is not None:
            result['rule_id'] = self.rule_id
        if self.rule_unique_identity is not None:
            result['rule_unique_identity'] = self.rule_unique_identity
        if self.category is not None:
            result['category'] = self.category
        if self.ref_datasource_type is not None:
            result['ref_datasource_type'] = self.ref_datasource_type
        if self.filter_user_group is not None:
            result['filter_user_group'] = self.filter_user_group
        if self.filter_webhook is not None:
            result['filter_webhook'] = self.filter_webhook
        if self.filter_ding_robot is not None:
            result['filter_ding_robot'] = self.filter_ding_robot
        if self.alarm_stack_info is not None:
            result['alarm_stack_info'] = self.alarm_stack_info.to_map()
        if self.data_source_type is not None:
            result['data_source_type'] = self.data_source_type
        if self.levels is not None:
            result['levels'] = self.levels
        if self.alarm_event_id is not None:
            result['alarm_event_id'] = self.alarm_event_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('alarm_target') is not None:
            temp_model = AlarmTarget()
            self.alarm_target = temp_model.from_map(m['alarm_target'])
        if m.get('rule_status') is not None:
            self.rule_status = m.get('rule_status')
        if m.get('alarm_status') is not None:
            self.alarm_status = m.get('alarm_status')
        if m.get('only_me') is not None:
            self.only_me = m.get('only_me')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('rule_id') is not None:
            self.rule_id = m.get('rule_id')
        if m.get('rule_unique_identity') is not None:
            self.rule_unique_identity = m.get('rule_unique_identity')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('ref_datasource_type') is not None:
            self.ref_datasource_type = m.get('ref_datasource_type')
        if m.get('filter_user_group') is not None:
            self.filter_user_group = m.get('filter_user_group')
        if m.get('filter_webhook') is not None:
            self.filter_webhook = m.get('filter_webhook')
        if m.get('filter_ding_robot') is not None:
            self.filter_ding_robot = m.get('filter_ding_robot')
        if m.get('alarm_stack_info') is not None:
            temp_model = AlarmStackInfo()
            self.alarm_stack_info = temp_model.from_map(m['alarm_stack_info'])
        if m.get('data_source_type') is not None:
            self.data_source_type = m.get('data_source_type')
        if m.get('levels') is not None:
            self.levels = m.get('levels')
        if m.get('alarm_event_id') is not None:
            self.alarm_event_id = m.get('alarm_event_id')
        return self


class QueryUnifiedalarmRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_rules: List[UnifiedAlarmRuleVO] = None,
        total_count: int = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警规则列表
        self.alarm_rules = alarm_rules
        # 总记录数
        self.total_count = total_count
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size

    def validate(self):
        if self.alarm_rules:
            for k in self.alarm_rules:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_rules'] = []
        if self.alarm_rules is not None:
            for k in self.alarm_rules:
                result['alarm_rules'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_rules = []
        if m.get('alarm_rules') is not None:
            for k in m.get('alarm_rules'):
                temp_model = UnifiedAlarmRuleVO()
                self.alarm_rules.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class GetUnifiedalarmRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 告警规则id
        self.id = id
        # 工作空间名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetUnifiedalarmRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_rule: UnifiedAlarmRuleVO = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警规则详情
        self.alarm_rule = alarm_rule

    def validate(self):
        if self.alarm_rule:
            self.alarm_rule.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.alarm_rule is not None:
            result['alarm_rule'] = self.alarm_rule.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('alarm_rule') is not None:
            temp_model = UnifiedAlarmRuleVO()
            self.alarm_rule = temp_model.from_map(m['alarm_rule'])
        return self


class DeleteUnifiedalarmRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 告警规则 id
        self.id = id
        # 工作空间名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class DeleteUnifiedalarmRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUnifiedalarmNotifyhistoryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        status: int = None,
        channel: str = None,
        subscriber: str = None,
        current_page: int = None,
        page_size: int = None,
        workspace_name: str = None,
        event_id: str = None,
        start_time: int = None,
        end_time: int = None,
        keyword: str = None,
        alarm_rule_id: int = None,
        alarm_status: int = None,
        alarm_stack_info: AlarmStackInfo = None,
        alarm_subscribers: List[UnifiedAlarmSubDTO] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发送状态
        self.status = status
        # 通知渠道
        self.channel = channel
        # 通知人id
        self.subscriber = subscriber
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 工作区名
        self.workspace_name = workspace_name
        # 事件id
        self.event_id = event_id
        # 开始时间
        self.start_time = start_time
        # 结束时间
        self.end_time = end_time
        # 查询告警内容
        self.keyword = keyword
        # 告警规则 ID
        self.alarm_rule_id = alarm_rule_id
        # 告警状态
        self.alarm_status = alarm_status
        # 根据应用过滤告警历史
        self.alarm_stack_info = alarm_stack_info
        # 是否根据通知对象过滤
        self.alarm_subscribers = alarm_subscribers

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')
        if self.alarm_stack_info:
            self.alarm_stack_info.validate()
        if self.alarm_subscribers:
            for k in self.alarm_subscribers:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.status is not None:
            result['status'] = self.status
        if self.channel is not None:
            result['channel'] = self.channel
        if self.subscriber is not None:
            result['subscriber'] = self.subscriber
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.event_id is not None:
            result['event_id'] = self.event_id
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.alarm_status is not None:
            result['alarm_status'] = self.alarm_status
        if self.alarm_stack_info is not None:
            result['alarm_stack_info'] = self.alarm_stack_info.to_map()
        result['alarm_subscribers'] = []
        if self.alarm_subscribers is not None:
            for k in self.alarm_subscribers:
                result['alarm_subscribers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('subscriber') is not None:
            self.subscriber = m.get('subscriber')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('event_id') is not None:
            self.event_id = m.get('event_id')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('alarm_status') is not None:
            self.alarm_status = m.get('alarm_status')
        if m.get('alarm_stack_info') is not None:
            temp_model = AlarmStackInfo()
            self.alarm_stack_info = temp_model.from_map(m['alarm_stack_info'])
        self.alarm_subscribers = []
        if m.get('alarm_subscribers') is not None:
            for k in m.get('alarm_subscribers'):
                temp_model = UnifiedAlarmSubDTO()
                self.alarm_subscribers.append(temp_model.from_map(k))
        return self


class QueryUnifiedalarmNotifyhistoryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        total_count: int = None,
        current_page: int = None,
        page_size: int = None,
        alarm_notify_histories: List[UnifiedAlarmNotifyHistoryVO] = None,
        alarm_notify_subs: List[UnifiedAlarmSubDTO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 总记录数
        self.total_count = total_count
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 响应结果
        self.alarm_notify_histories = alarm_notify_histories
        # 告警通知历史中对应的通知对象
        self.alarm_notify_subs = alarm_notify_subs

    def validate(self):
        if self.alarm_notify_histories:
            for k in self.alarm_notify_histories:
                if k:
                    k.validate()
        if self.alarm_notify_subs:
            for k in self.alarm_notify_subs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        result['alarm_notify_histories'] = []
        if self.alarm_notify_histories is not None:
            for k in self.alarm_notify_histories:
                result['alarm_notify_histories'].append(k.to_map() if k else None)
        result['alarm_notify_subs'] = []
        if self.alarm_notify_subs is not None:
            for k in self.alarm_notify_subs:
                result['alarm_notify_subs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        self.alarm_notify_histories = []
        if m.get('alarm_notify_histories') is not None:
            for k in m.get('alarm_notify_histories'):
                temp_model = UnifiedAlarmNotifyHistoryVO()
                self.alarm_notify_histories.append(temp_model.from_map(k))
        self.alarm_notify_subs = []
        if m.get('alarm_notify_subs') is not None:
            for k in m.get('alarm_notify_subs'):
                temp_model = UnifiedAlarmSubDTO()
                self.alarm_notify_subs.append(temp_model.from_map(k))
        return self


class BatchcreateUnifiedalarmSubRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        alarm_subs: List[UnifiedAlarmSubDTO] = None,
        alarm_rule_ids: List[int] = None,
        sub_all: bool = None,
        workspace_name: str = None,
        is_append: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 通知对象 可能有多个
        self.alarm_subs = alarm_subs
        # 告警规则id集合
        self.alarm_rule_ids = alarm_rule_ids
        # 是否全部订阅
        self.sub_all = sub_all
        # 工作区名
        self.workspace_name = workspace_name
        # 订阅成员是新增吗？新增时，不做旧的订阅关系做覆盖
        self.is_append = is_append

    def validate(self):
        self.validate_required(self.alarm_subs, 'alarm_subs')
        if self.alarm_subs:
            for k in self.alarm_subs:
                if k:
                    k.validate()
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['alarm_subs'] = []
        if self.alarm_subs is not None:
            for k in self.alarm_subs:
                result['alarm_subs'].append(k.to_map() if k else None)
        if self.alarm_rule_ids is not None:
            result['alarm_rule_ids'] = self.alarm_rule_ids
        if self.sub_all is not None:
            result['sub_all'] = self.sub_all
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.is_append is not None:
            result['is_append'] = self.is_append
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.alarm_subs = []
        if m.get('alarm_subs') is not None:
            for k in m.get('alarm_subs'):
                temp_model = UnifiedAlarmSubDTO()
                self.alarm_subs.append(temp_model.from_map(k))
        if m.get('alarm_rule_ids') is not None:
            self.alarm_rule_ids = m.get('alarm_rule_ids')
        if m.get('sub_all') is not None:
            self.sub_all = m.get('sub_all')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('is_append') is not None:
            self.is_append = m.get('is_append')
        return self


class BatchcreateUnifiedalarmSubResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteUnifiedalarmSubRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        alarm_sub: UnifiedAlarmSubDTO = None,
        rule_id: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 通知对象 可能为多个
        self.alarm_sub = alarm_sub
        # 规则id集合
        self.rule_id = rule_id
        # 工作区名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.alarm_sub, 'alarm_sub')
        if self.alarm_sub:
            self.alarm_sub.validate()
        self.validate_required(self.rule_id, 'rule_id')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.alarm_sub is not None:
            result['alarm_sub'] = self.alarm_sub.to_map()
        if self.rule_id is not None:
            result['rule_id'] = self.rule_id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('alarm_sub') is not None:
            temp_model = UnifiedAlarmSubDTO()
            self.alarm_sub = temp_model.from_map(m['alarm_sub'])
        if m.get('rule_id') is not None:
            self.rule_id = m.get('rule_id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class DeleteUnifiedalarmSubResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUnifiedalarmSubRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        subscriber: str = None,
        subscriber_type: str = None,
        only_me: bool = None,
        workspace_name: str = None,
        alarm_rule_id: int = None,
        alarm_tpl_id: int = None,
        current_page: int = None,
        page_size: int = None,
        subscriber_source: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 通知人
        self.subscriber = subscriber
        # 通知人的类型
        self.subscriber_type = subscriber_type
        # 是否包含我
        self.only_me = only_me
        # 工作区名
        self.workspace_name = workspace_name
        # 规则id
        self.alarm_rule_id = alarm_rule_id
        # 模板id
        self.alarm_tpl_id = alarm_tpl_id
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 订阅人来源
        self.subscriber_source = subscriber_source

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.subscriber is not None:
            result['subscriber'] = self.subscriber
        if self.subscriber_type is not None:
            result['subscriber_type'] = self.subscriber_type
        if self.only_me is not None:
            result['only_me'] = self.only_me
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.alarm_tpl_id is not None:
            result['alarm_tpl_id'] = self.alarm_tpl_id
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.subscriber_source is not None:
            result['subscriber_source'] = self.subscriber_source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('subscriber') is not None:
            self.subscriber = m.get('subscriber')
        if m.get('subscriber_type') is not None:
            self.subscriber_type = m.get('subscriber_type')
        if m.get('only_me') is not None:
            self.only_me = m.get('only_me')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('alarm_tpl_id') is not None:
            self.alarm_tpl_id = m.get('alarm_tpl_id')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('subscriber_source') is not None:
            self.subscriber_source = m.get('subscriber_source')
        return self


class QueryUnifiedalarmSubResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_subs: List[UnifiedAlarmSubVO] = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警订阅关系列表
        self.alarm_subs = alarm_subs
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 总记录数
        self.total_count = total_count

    def validate(self):
        if self.alarm_subs:
            for k in self.alarm_subs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_subs'] = []
        if self.alarm_subs is not None:
            for k in self.alarm_subs:
                result['alarm_subs'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_subs = []
        if m.get('alarm_subs') is not None:
            for k in m.get('alarm_subs'):
                temp_model = UnifiedAlarmSubVO()
                self.alarm_subs.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class CreateUnifiedalarmTplRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        category: str = None,
        rule_config: str = None,
        level: int = None,
        emergency: str = None,
        emergency_url: str = None,
        pending_hit: int = None,
        recovered_hit: int = None,
        step: int = None,
        channels: List[str] = None,
        alarm_subs: List[UnifiedAlarmSubDTO] = None,
        silence_time: int = None,
        notify_firing: int = None,
        notify_recovered: int = None,
        notify_nodata: int = None,
        notify_time_filter: TimeFilter = None,
        workspace_name: str = None,
        alarm_nodata: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 模板名称
        self.name = name
        # 区分自定义还是pql
        self.category = category
        # 规则配置
        self.rule_config = rule_config
        # 告警等级
        self.level = level
        # 应急处理人
        self.emergency = emergency
        # 应急处理链接
        self.emergency_url = emergency_url
        # 触发周期
        self.pending_hit = pending_hit
        # 恢复周期
        self.recovered_hit = recovered_hit
        # 检测频率
        self.step = step
        # 通知渠道
        self.channels = channels
        # 通知对象
        self.alarm_subs = alarm_subs
        # 静默期
        self.silence_time = silence_time
        # 告警触发时通知
        self.notify_firing = notify_firing
        # 告警恢复时通知
        self.notify_recovered = notify_recovered
        # 告警无数据时通知
        self.notify_nodata = notify_nodata
        # 通知时间
        self.notify_time_filter = notify_time_filter
        # 工作区名
        self.workspace_name = workspace_name
        # 指标无数据触发告警 这是个开关 1表示打开 0表示闭合
        self.alarm_nodata = alarm_nodata

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.category, 'category')
        self.validate_required(self.rule_config, 'rule_config')
        self.validate_required(self.level, 'level')
        self.validate_required(self.pending_hit, 'pending_hit')
        self.validate_required(self.recovered_hit, 'recovered_hit')
        self.validate_required(self.step, 'step')
        self.validate_required(self.channels, 'channels')
        if self.alarm_subs:
            for k in self.alarm_subs:
                if k:
                    k.validate()
        self.validate_required(self.silence_time, 'silence_time')
        self.validate_required(self.notify_firing, 'notify_firing')
        self.validate_required(self.notify_recovered, 'notify_recovered')
        self.validate_required(self.notify_nodata, 'notify_nodata')
        if self.notify_time_filter:
            self.notify_time_filter.validate()
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.alarm_nodata, 'alarm_nodata')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.category is not None:
            result['category'] = self.category
        if self.rule_config is not None:
            result['rule_config'] = self.rule_config
        if self.level is not None:
            result['level'] = self.level
        if self.emergency is not None:
            result['emergency'] = self.emergency
        if self.emergency_url is not None:
            result['emergency_url'] = self.emergency_url
        if self.pending_hit is not None:
            result['pending_hit'] = self.pending_hit
        if self.recovered_hit is not None:
            result['recovered_hit'] = self.recovered_hit
        if self.step is not None:
            result['step'] = self.step
        if self.channels is not None:
            result['channels'] = self.channels
        result['alarm_subs'] = []
        if self.alarm_subs is not None:
            for k in self.alarm_subs:
                result['alarm_subs'].append(k.to_map() if k else None)
        if self.silence_time is not None:
            result['silence_time'] = self.silence_time
        if self.notify_firing is not None:
            result['notify_firing'] = self.notify_firing
        if self.notify_recovered is not None:
            result['notify_recovered'] = self.notify_recovered
        if self.notify_nodata is not None:
            result['notify_nodata'] = self.notify_nodata
        if self.notify_time_filter is not None:
            result['notify_time_filter'] = self.notify_time_filter.to_map()
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.alarm_nodata is not None:
            result['alarm_nodata'] = self.alarm_nodata
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('rule_config') is not None:
            self.rule_config = m.get('rule_config')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('emergency') is not None:
            self.emergency = m.get('emergency')
        if m.get('emergency_url') is not None:
            self.emergency_url = m.get('emergency_url')
        if m.get('pending_hit') is not None:
            self.pending_hit = m.get('pending_hit')
        if m.get('recovered_hit') is not None:
            self.recovered_hit = m.get('recovered_hit')
        if m.get('step') is not None:
            self.step = m.get('step')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        self.alarm_subs = []
        if m.get('alarm_subs') is not None:
            for k in m.get('alarm_subs'):
                temp_model = UnifiedAlarmSubDTO()
                self.alarm_subs.append(temp_model.from_map(k))
        if m.get('silence_time') is not None:
            self.silence_time = m.get('silence_time')
        if m.get('notify_firing') is not None:
            self.notify_firing = m.get('notify_firing')
        if m.get('notify_recovered') is not None:
            self.notify_recovered = m.get('notify_recovered')
        if m.get('notify_nodata') is not None:
            self.notify_nodata = m.get('notify_nodata')
        if m.get('notify_time_filter') is not None:
            temp_model = TimeFilter()
            self.notify_time_filter = temp_model.from_map(m['notify_time_filter'])
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('alarm_nodata') is not None:
            self.alarm_nodata = m.get('alarm_nodata')
        return self


class CreateUnifiedalarmTplResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # true 成功 false 失败
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class UpdateUnifiedalarmTplRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        name: str = None,
        category: str = None,
        rule_config: str = None,
        level: int = None,
        emergency: str = None,
        emergency_url: str = None,
        pending_hit: int = None,
        recovered_hit: int = None,
        step: int = None,
        channels: List[str] = None,
        alarm_subs: List[UnifiedAlarmSubDTO] = None,
        silence_time: int = None,
        notify_firing: int = None,
        notify_recovered: int = None,
        notify_nodata: int = None,
        notify_time_filter: TimeFilter = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 主键
        self.id = id
        # 模板名称
        self.name = name
        # 区分自定义还是pql
        self.category = category
        # 规则配置
        self.rule_config = rule_config
        # 告警等级
        self.level = level
        # 应急处理人
        self.emergency = emergency
        # 应急处理链接
        self.emergency_url = emergency_url
        # 触发周期
        self.pending_hit = pending_hit
        # 恢复周期
        self.recovered_hit = recovered_hit
        # 检测频率
        self.step = step
        # 通知渠道
        self.channels = channels
        # 通知对象 可能有多个
        self.alarm_subs = alarm_subs
        # 静默期
        self.silence_time = silence_time
        # 告警触发时通知
        self.notify_firing = notify_firing
        # 告警恢复时通知
        self.notify_recovered = notify_recovered
        # 告警无数据时通知
        self.notify_nodata = notify_nodata
        # 通知时间
        self.notify_time_filter = notify_time_filter
        # 工作空间名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.category, 'category')
        self.validate_required(self.rule_config, 'rule_config')
        self.validate_required(self.level, 'level')
        self.validate_required(self.pending_hit, 'pending_hit')
        self.validate_required(self.recovered_hit, 'recovered_hit')
        self.validate_required(self.step, 'step')
        self.validate_required(self.channels, 'channels')
        if self.alarm_subs:
            for k in self.alarm_subs:
                if k:
                    k.validate()
        self.validate_required(self.silence_time, 'silence_time')
        self.validate_required(self.notify_firing, 'notify_firing')
        self.validate_required(self.notify_recovered, 'notify_recovered')
        self.validate_required(self.notify_nodata, 'notify_nodata')
        if self.notify_time_filter:
            self.notify_time_filter.validate()
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.category is not None:
            result['category'] = self.category
        if self.rule_config is not None:
            result['rule_config'] = self.rule_config
        if self.level is not None:
            result['level'] = self.level
        if self.emergency is not None:
            result['emergency'] = self.emergency
        if self.emergency_url is not None:
            result['emergency_url'] = self.emergency_url
        if self.pending_hit is not None:
            result['pending_hit'] = self.pending_hit
        if self.recovered_hit is not None:
            result['recovered_hit'] = self.recovered_hit
        if self.step is not None:
            result['step'] = self.step
        if self.channels is not None:
            result['channels'] = self.channels
        result['alarm_subs'] = []
        if self.alarm_subs is not None:
            for k in self.alarm_subs:
                result['alarm_subs'].append(k.to_map() if k else None)
        if self.silence_time is not None:
            result['silence_time'] = self.silence_time
        if self.notify_firing is not None:
            result['notify_firing'] = self.notify_firing
        if self.notify_recovered is not None:
            result['notify_recovered'] = self.notify_recovered
        if self.notify_nodata is not None:
            result['notify_nodata'] = self.notify_nodata
        if self.notify_time_filter is not None:
            result['notify_time_filter'] = self.notify_time_filter.to_map()
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('category') is not None:
            self.category = m.get('category')
        if m.get('rule_config') is not None:
            self.rule_config = m.get('rule_config')
        if m.get('level') is not None:
            self.level = m.get('level')
        if m.get('emergency') is not None:
            self.emergency = m.get('emergency')
        if m.get('emergency_url') is not None:
            self.emergency_url = m.get('emergency_url')
        if m.get('pending_hit') is not None:
            self.pending_hit = m.get('pending_hit')
        if m.get('recovered_hit') is not None:
            self.recovered_hit = m.get('recovered_hit')
        if m.get('step') is not None:
            self.step = m.get('step')
        if m.get('channels') is not None:
            self.channels = m.get('channels')
        self.alarm_subs = []
        if m.get('alarm_subs') is not None:
            for k in m.get('alarm_subs'):
                temp_model = UnifiedAlarmSubDTO()
                self.alarm_subs.append(temp_model.from_map(k))
        if m.get('silence_time') is not None:
            self.silence_time = m.get('silence_time')
        if m.get('notify_firing') is not None:
            self.notify_firing = m.get('notify_firing')
        if m.get('notify_recovered') is not None:
            self.notify_recovered = m.get('notify_recovered')
        if m.get('notify_nodata') is not None:
            self.notify_nodata = m.get('notify_nodata')
        if m.get('notify_time_filter') is not None:
            temp_model = TimeFilter()
            self.notify_time_filter = temp_model.from_map(m['notify_time_filter'])
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class UpdateUnifiedalarmTplResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUnifiedalarmTplRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        current_page: int = None,
        page_size: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 当前页
        # 
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 工作区名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryUnifiedalarmTplResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_tpls: List[UnifiedAlarmTplVO] = None,
        total_count: int = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警模板集合
        self.alarm_tpls = alarm_tpls
        # 总记录数
        self.total_count = total_count
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size

    def validate(self):
        if self.alarm_tpls:
            for k in self.alarm_tpls:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_tpls'] = []
        if self.alarm_tpls is not None:
            for k in self.alarm_tpls:
                result['alarm_tpls'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_tpls = []
        if m.get('alarm_tpls') is not None:
            for k in m.get('alarm_tpls'):
                temp_model = UnifiedAlarmTplVO()
                self.alarm_tpls.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class GetUnifiedalarmTplRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 主键
        self.id = id
        # 工作空间名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetUnifiedalarmTplResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_tpl: UnifiedAlarmTplVO = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警规则模板详情
        self.alarm_tpl = alarm_tpl

    def validate(self):
        if self.alarm_tpl:
            self.alarm_tpl.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.alarm_tpl is not None:
            result['alarm_tpl'] = self.alarm_tpl.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('alarm_tpl') is not None:
            temp_model = UnifiedAlarmTplVO()
            self.alarm_tpl = temp_model.from_map(m['alarm_tpl'])
        return self


class DeleteUnifiedalarmTplRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 主键
        self.id = id
        # 工作空间名
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class DeleteUnifiedalarmTplResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class SwitchUnifiedalarmRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        suspend_start_time: int = None,
        suspended_end_time: int = None,
        suspended_reason: str = None,
        status: int = None,
        workspace_name: str = None,
        ids: List[int] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 主键
        self.id = id
        # 告警开始时间
        self.suspend_start_time = suspend_start_time
        # 告警结束时间
        self.suspended_end_time = suspended_end_time
        # 告警暂停原因
        self.suspended_reason = suspended_reason
        # 启停状态
        self.status = status
        # 工作空间名
        self.workspace_name = workspace_name
        # 批量暂停与恢复
        self.ids = ids

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.status, 'status')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.suspend_start_time is not None:
            result['suspend_start_time'] = self.suspend_start_time
        if self.suspended_end_time is not None:
            result['suspended_end_time'] = self.suspended_end_time
        if self.suspended_reason is not None:
            result['suspended_reason'] = self.suspended_reason
        if self.status is not None:
            result['status'] = self.status
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.ids is not None:
            result['ids'] = self.ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('suspend_start_time') is not None:
            self.suspend_start_time = m.get('suspend_start_time')
        if m.get('suspended_end_time') is not None:
            self.suspended_end_time = m.get('suspended_end_time')
        if m.get('suspended_reason') is not None:
            self.suspended_reason = m.get('suspended_reason')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('ids') is not None:
            self.ids = m.get('ids')
        return self


class SwitchUnifiedalarmRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListAlarmSubscriptionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        resource_type: str = None,
        resource_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 资源类型
        self.resource_type = resource_type
        # 资源ID
        self.resource_id = resource_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.resource_type, 'resource_type')
        self.validate_required(self.resource_id, 'resource_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.resource_type is not None:
            result['resource_type'] = self.resource_type
        if self.resource_id is not None:
            result['resource_id'] = self.resource_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('resource_type') is not None:
            self.resource_type = m.get('resource_type')
        if m.get('resource_id') is not None:
            self.resource_id = m.get('resource_id')
        return self


class ListAlarmSubscriptionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_subs: List[AlarmSub] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警订阅列表
        self.alarm_subs = alarm_subs

    def validate(self):
        if self.alarm_subs:
            for k in self.alarm_subs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_subs'] = []
        if self.alarm_subs is not None:
            for k in self.alarm_subs:
                result['alarm_subs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_subs = []
        if m.get('alarm_subs') is not None:
            for k in m.get('alarm_subs'):
                temp_model = AlarmSub()
                self.alarm_subs.append(temp_model.from_map(k))
        return self


class UpdateAlarmSubscriptionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
        alarm_level: int = None,
        notify_reduce_switch: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 告警订阅主键 ID
        self.id = id
        # 告警级别
        self.alarm_level = alarm_level
        # 降频通知开关
        self.notify_reduce_switch = notify_reduce_switch

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')
        self.validate_required(self.alarm_level, 'alarm_level')
        self.validate_required(self.notify_reduce_switch, 'notify_reduce_switch')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.notify_reduce_switch is not None:
            result['notify_reduce_switch'] = self.notify_reduce_switch
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('notify_reduce_switch') is not None:
            self.notify_reduce_switch = m.get('notify_reduce_switch')
        return self


class UpdateAlarmSubscriptionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListCustompluginRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        plugin_type: str = None,
        filter_type: str = None,
        filter: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 插件类型
        self.plugin_type = plugin_type
        # 过滤类型
        self.filter_type = filter_type
        # 过滤条件，如app名称
        self.filter = filter

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.plugin_type is not None:
            result['plugin_type'] = self.plugin_type
        if self.filter_type is not None:
            result['filter_type'] = self.filter_type
        if self.filter is not None:
            result['filter'] = self.filter
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('plugin_type') is not None:
            self.plugin_type = m.get('plugin_type')
        if m.get('filter_type') is not None:
            self.filter_type = m.get('filter_type')
        if m.get('filter') is not None:
            self.filter = m.get('filter')
        return self


class ListCustompluginResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        custom_plugins: List[CustomPluginDO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 自定义指标监控配置列表
        self.custom_plugins = custom_plugins

    def validate(self):
        if self.custom_plugins:
            for k in self.custom_plugins:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['custom_plugins'] = []
        if self.custom_plugins is not None:
            for k in self.custom_plugins:
                result['custom_plugins'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.custom_plugins = []
        if m.get('custom_plugins') is not None:
            for k in m.get('custom_plugins'):
                temp_model = CustomPluginDO()
                self.custom_plugins.append(temp_model.from_map(k))
        return self


class QueryUnifiedalarmEventRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        current_page: int = None,
        page_size: int = None,
        alarm_level: int = None,
        status: int = None,
        alarm_target_type: str = None,
        keyword: str = None,
        start_time: int = None,
        end_time: int = None,
        alarm_rule_id: int = None,
        alarm_stack_info: AlarmStackInfo = None,
        fire_start_time: int = None,
        fire_end_time: int = None,
        recovered_start_time: int = None,
        recovered_end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作区
        self.workspace_name = workspace_name
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 告警等级
        self.alarm_level = alarm_level
        # 触发状态
        self.status = status
        # 告警对象类型
        self.alarm_target_type = alarm_target_type
        # 模糊查询字段
        self.keyword = keyword
        # 开始时间
        self.start_time = start_time
        # 结束时间
        self.end_time = end_time
        # 告警规则 ID
        self.alarm_rule_id = alarm_rule_id
        # 根据应用栈过滤
        self.alarm_stack_info = alarm_stack_info
        # 查询告警事件产生时间所在区间的开始时间
        self.fire_start_time = fire_start_time
        # 查询告警事件产生时间所在区间的结束时间
        self.fire_end_time = fire_end_time
        # 查询告警事件恢复时间所在区间的开始时间
        self.recovered_start_time = recovered_start_time
        # 查询告警事件恢复时间所在区间的结束时间
        self.recovered_end_time = recovered_end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        if self.alarm_stack_info:
            self.alarm_stack_info.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.status is not None:
            result['status'] = self.status
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.alarm_stack_info is not None:
            result['alarm_stack_info'] = self.alarm_stack_info.to_map()
        if self.fire_start_time is not None:
            result['fire_start_time'] = self.fire_start_time
        if self.fire_end_time is not None:
            result['fire_end_time'] = self.fire_end_time
        if self.recovered_start_time is not None:
            result['recovered_start_time'] = self.recovered_start_time
        if self.recovered_end_time is not None:
            result['recovered_end_time'] = self.recovered_end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('alarm_stack_info') is not None:
            temp_model = AlarmStackInfo()
            self.alarm_stack_info = temp_model.from_map(m['alarm_stack_info'])
        if m.get('fire_start_time') is not None:
            self.fire_start_time = m.get('fire_start_time')
        if m.get('fire_end_time') is not None:
            self.fire_end_time = m.get('fire_end_time')
        if m.get('recovered_start_time') is not None:
            self.recovered_start_time = m.get('recovered_start_time')
        if m.get('recovered_end_time') is not None:
            self.recovered_end_time = m.get('recovered_end_time')
        return self


class QueryUnifiedalarmEventResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        unified_alarm_event_list: List[UnifiedAlarmEventVO] = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警事件列表
        self.unified_alarm_event_list = unified_alarm_event_list
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 总记录数
        self.total_count = total_count

    def validate(self):
        if self.unified_alarm_event_list:
            for k in self.unified_alarm_event_list:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['unified_alarm_event_list'] = []
        if self.unified_alarm_event_list is not None:
            for k in self.unified_alarm_event_list:
                result['unified_alarm_event_list'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.unified_alarm_event_list = []
        if m.get('unified_alarm_event_list') is not None:
            for k in m.get('unified_alarm_event_list'):
                temp_model = UnifiedAlarmEventVO()
                self.unified_alarm_event_list.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class QueryUnifiedalarmMetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        rule_unique_identity: str = None,
        muid: str = None,
        tags: List[KeySet] = None,
        start: int = None,
        end: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 告警规则唯一标识
        self.rule_unique_identity = rule_unique_identity
        # metrics查询唯一id
        self.muid = muid
        # 维度筛选
        self.tags = tags
        # 开始时间
        self.start = start
        # 结束时间
        self.end = end
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.rule_unique_identity is not None:
            result['rule_unique_identity'] = self.rule_unique_identity
        if self.muid is not None:
            result['muid'] = self.muid
        result['tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['tags'].append(k.to_map() if k else None)
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('rule_unique_identity') is not None:
            self.rule_unique_identity = m.get('rule_unique_identity')
        if m.get('muid') is not None:
            self.muid = m.get('muid')
        self.tags = []
        if m.get('tags') is not None:
            for k in m.get('tags'):
                temp_model = KeySet()
                self.tags.append(temp_model.from_map(k))
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryUnifiedalarmMetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        results: List[UnifiedAlarmMetric] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 指标数据
        self.results = results

    def validate(self):
        if self.results:
            for k in self.results:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['results'] = []
        if self.results is not None:
            for k in self.results:
                result['results'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.results = []
        if m.get('results') is not None:
            for k in m.get('results'):
                temp_model = UnifiedAlarmMetric()
                self.results.append(temp_model.from_map(k))
        return self


class BatchcreateUnifiedalarmHistoryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        context: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # json格式上下文信息
        self.context = context

    def validate(self):
        self.validate_required(self.context, 'context')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.context is not None:
            result['context'] = self.context
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('context') is not None:
            self.context = m.get('context')
        return self


class BatchcreateUnifiedalarmHistoryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchcreateUnifiedalarmRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        tpl_id: int = None,
        alarm_targets: List[AlarmTarget] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 模板 ID
        self.tpl_id = tpl_id
        # 监控对象名称列表
        self.alarm_targets = alarm_targets

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.tpl_id, 'tpl_id')
        self.validate_required(self.alarm_targets, 'alarm_targets')
        if self.alarm_targets:
            for k in self.alarm_targets:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.tpl_id is not None:
            result['tpl_id'] = self.tpl_id
        result['alarm_targets'] = []
        if self.alarm_targets is not None:
            for k in self.alarm_targets:
                result['alarm_targets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('tpl_id') is not None:
            self.tpl_id = m.get('tpl_id')
        self.alarm_targets = []
        if m.get('alarm_targets') is not None:
            for k in m.get('alarm_targets'):
                temp_model = AlarmTarget()
                self.alarm_targets.append(temp_model.from_map(k))
        return self


class BatchcreateUnifiedalarmRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUnifiedalarmEventstatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        alarm_level: int = None,
        status: int = None,
        start_time: int = None,
        end_time: int = None,
        workspace_name: str = None,
        keyword: str = None,
        alarm_rule_id: int = None,
        alarm_target_type: str = None,
        alarm_stack_info: AlarmStackInfo = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 告警等级
        self.alarm_level = alarm_level
        # 触发状态
        self.status = status
        # 时间戳
        self.start_time = start_time
        # 时间戳
        self.end_time = end_time
        # 工作空间名
        self.workspace_name = workspace_name
        # 模糊查询告警内容
        self.keyword = keyword
        # 告警规则 ID
        self.alarm_rule_id = alarm_rule_id
        # alarm_target_type
        self.alarm_target_type = alarm_target_type
        # 根据应用过滤
        self.alarm_stack_info = alarm_stack_info

    def validate(self):
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')
        self.validate_required(self.workspace_name, 'workspace_name')
        if self.alarm_stack_info:
            self.alarm_stack_info.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.alarm_level is not None:
            result['alarm_level'] = self.alarm_level
        if self.status is not None:
            result['status'] = self.status
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.alarm_stack_info is not None:
            result['alarm_stack_info'] = self.alarm_stack_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('alarm_level') is not None:
            self.alarm_level = m.get('alarm_level')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('alarm_stack_info') is not None:
            temp_model = AlarmStackInfo()
            self.alarm_stack_info = temp_model.from_map(m['alarm_stack_info'])
        return self


class QueryUnifiedalarmEventstatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        alarm_history_list: List[EventStat] = None,
        time_slots: List[int] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 历史事件统计
        self.alarm_history_list = alarm_history_list
        # 时间分段
        self.time_slots = time_slots

    def validate(self):
        if self.alarm_history_list:
            for k in self.alarm_history_list:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['alarm_history_list'] = []
        if self.alarm_history_list is not None:
            for k in self.alarm_history_list:
                result['alarm_history_list'].append(k.to_map() if k else None)
        if self.time_slots is not None:
            result['time_slots'] = self.time_slots
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.alarm_history_list = []
        if m.get('alarm_history_list') is not None:
            for k in m.get('alarm_history_list'):
                temp_model = EventStat()
                self.alarm_history_list.append(temp_model.from_map(k))
        if m.get('time_slots') is not None:
            self.time_slots = m.get('time_slots')
        return self


class QueryUnifiedalarmNotifystatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        start_time: int = None,
        end_time: int = None,
        status: int = None,
        channel: str = None,
        keyword: str = None,
        workspace_name: str = None,
        alarm_rule_id: int = None,
        event_id: str = None,
        alarm_stack_info: AlarmStackInfo = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 开始时间
        self.start_time = start_time
        # 结束时间
        self.end_time = end_time
        # 发送状态
        self.status = status
        # 通知渠道
        self.channel = channel
        # 模糊查询通知内容
        self.keyword = keyword
        # 工作空间名称
        self.workspace_name = workspace_name
        # 告警规则 ID
        self.alarm_rule_id = alarm_rule_id
        # 事件ID
        self.event_id = event_id
        # 根据应用过滤
        self.alarm_stack_info = alarm_stack_info

    def validate(self):
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')
        self.validate_required(self.workspace_name, 'workspace_name')
        if self.alarm_stack_info:
            self.alarm_stack_info.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.status is not None:
            result['status'] = self.status
        if self.channel is not None:
            result['channel'] = self.channel
        if self.keyword is not None:
            result['keyword'] = self.keyword
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.event_id is not None:
            result['event_id'] = self.event_id
        if self.alarm_stack_info is not None:
            result['alarm_stack_info'] = self.alarm_stack_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('channel') is not None:
            self.channel = m.get('channel')
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('event_id') is not None:
            self.event_id = m.get('event_id')
        if m.get('alarm_stack_info') is not None:
            temp_model = AlarmStackInfo()
            self.alarm_stack_info = temp_model.from_map(m['alarm_stack_info'])
        return self


class QueryUnifiedalarmNotifystatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        notify_stat_list: List[EventStat] = None,
        time_slots: List[int] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 统计通知历史
        self.notify_stat_list = notify_stat_list
        # 时间分段
        self.time_slots = time_slots

    def validate(self):
        if self.notify_stat_list:
            for k in self.notify_stat_list:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['notify_stat_list'] = []
        if self.notify_stat_list is not None:
            for k in self.notify_stat_list:
                result['notify_stat_list'].append(k.to_map() if k else None)
        if self.time_slots is not None:
            result['time_slots'] = self.time_slots
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.notify_stat_list = []
        if m.get('notify_stat_list') is not None:
            for k in m.get('notify_stat_list'):
                temp_model = EventStat()
                self.notify_stat_list.append(temp_model.from_map(k))
        if m.get('time_slots') is not None:
            self.time_slots = m.get('time_slots')
        return self


class QueryMetaNodeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryMetaNodeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        mtm_ncs: List[MtmNc] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 物理机信息
        self.mtm_ncs = mtm_ncs

    def validate(self):
        if self.mtm_ncs:
            for k in self.mtm_ncs:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['mtm_ncs'] = []
        if self.mtm_ncs is not None:
            for k in self.mtm_ncs:
                result['mtm_ncs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.mtm_ncs = []
        if m.get('mtm_ncs') is not None:
            for k in m.get('mtm_ncs'):
                temp_model = MtmNc()
                self.mtm_ncs.append(temp_model.from_map(k))
        return self


class BatchdeleteUnifiedalarmRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        ids_repeat_list: List[int] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # id
        self.ids_repeat_list = ids_repeat_list

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.ids_repeat_list, 'ids_repeat_list')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.ids_repeat_list is not None:
            result['ids_repeat_list'] = self.ids_repeat_list
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('ids_repeat_list') is not None:
            self.ids_repeat_list = m.get('ids_repeat_list')
        return self


class BatchdeleteUnifiedalarmRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateXdashboardRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XDashboardCRULResponseCURequest = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace name
        self.workspace_name = workspace_name
        # request data
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XDashboardCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class CreateXdashboardResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XDashboardCRULResponseCURequest = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # response data
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XDashboardCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class UpdateXdashboardRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XDashboardCRULResponseCURequest = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # external workspace name
        self.workspace_name = workspace_name
        # update
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XDashboardCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class UpdateXdashboardResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XDashboardCRULResponseCURequest = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # dashboard body
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XDashboardCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXdashboardRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XDashboardQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XDashboardQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXdashboardResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XDashboardCRULResponseCURequest] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # dashboard body
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XDashboardCRULResponseCURequest()
                self.data.append(temp_model.from_map(k))
        return self


class ListXdashboardDirectoryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XResource = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # uuid必填
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XResource()
            self.data = temp_model.from_map(m['data'])
        return self


class ListXdashboardDirectoryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XDashboardCRULResponseCURequest] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # dashboard body list
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XDashboardCRULResponseCURequest()
                self.data.append(temp_model.from_map(k))
        return self


class DeleteXdashboardRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XResource = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 其中uuid和type必填
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XResource()
            self.data = temp_model.from_map(m['data'])
        return self


class DeleteXdashboardResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XResource] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 删除成功资源列表
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XResource()
                self.data.append(temp_model.from_map(k))
        return self


class QueryXmetricInstantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # time 必填
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricInstantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XMetricResponse = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XMetricResponse()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricRangeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # start end 必填
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricRangeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XMetricResponse = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XMetricResponse()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricdatasourceInstantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricdatasourceInstantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XMetricResponse = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XMetricResponse()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricdatasourceRangeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricdatasourceRangeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XTableResponse = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XTableResponse()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetrictagKeyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetrictagKeyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XMetricInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tag keys
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XMetricInfo()
                self.data.append(temp_model.from_map(k))
        return self


class QueryXmetrictagValueRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetrictagValueResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class ListLogserviceDesenstypesRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class ListLogserviceDesenstypesResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        desens_types: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 可配置的脱敏类型
        self.desens_types = desens_types

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.desens_types is not None:
            result['desens_types'] = self.desens_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('desens_types') is not None:
            self.desens_types = m.get('desens_types')
        return self


class GetLogserviceDesensconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetLogserviceDesensconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        desens_types: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 已配置的脱敏类型
        self.desens_types = desens_types

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.desens_types is not None:
            result['desens_types'] = self.desens_types
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('desens_types') is not None:
            self.desens_types = m.get('desens_types')
        return self


class UpdateLogserviceDesensconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        desens_types: List[str] = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 需配置的脱敏类型
        self.desens_types = desens_types
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.desens_types, 'desens_types')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.desens_types is not None:
            result['desens_types'] = self.desens_types
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('desens_types') is not None:
            self.desens_types = m.get('desens_types')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class UpdateLogserviceDesensconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DetailUserRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class DetailUserResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        auth_url: str = None,
        user: MonitorUser = None,
        nav_head: NavContent = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # auth_url
        self.auth_url = auth_url
        # user
        self.user = user
        # nav_head
        self.nav_head = nav_head

    def validate(self):
        if self.user:
            self.user.validate()
        if self.nav_head:
            self.nav_head.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.auth_url is not None:
            result['auth_url'] = self.auth_url
        if self.user is not None:
            result['user'] = self.user.to_map()
        if self.nav_head is not None:
            result['nav_head'] = self.nav_head.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('auth_url') is not None:
            self.auth_url = m.get('auth_url')
        if m.get('user') is not None:
            temp_model = MonitorUser()
            self.user = temp_model.from_map(m['user'])
        if m.get('nav_head') is not None:
            temp_model = NavContent()
            self.nav_head = temp_model.from_map(m['nav_head'])
        return self


class AuthUserRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        login_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace_name
        self.workspace_name = workspace_name
        # login_name
        self.login_name = login_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.login_name, 'login_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.login_name is not None:
            result['login_name'] = self.login_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('login_name') is not None:
            self.login_name = m.get('login_name')
        return self


class AuthUserResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        powers: List[LongListKeySet] = None,
        bd_powers: List[LongListKeySet] = None,
        w_powers: List[LongListKeySet] = None,
        t_powers: List[LongListKeySet] = None,
        super_admin: bool = None,
        super_view: bool = None,
        biz_domains: List[BizDomain] = None,
        auth_url: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # powers
        self.powers = powers
        # bd_powers
        self.bd_powers = bd_powers
        # w_powers
        self.w_powers = w_powers
        # t_powers
        self.t_powers = t_powers
        # super_admin
        self.super_admin = super_admin
        # super_view
        self.super_view = super_view
        # biz_domains
        self.biz_domains = biz_domains
        # auth_url
        self.auth_url = auth_url

    def validate(self):
        if self.powers:
            for k in self.powers:
                if k:
                    k.validate()
        if self.bd_powers:
            for k in self.bd_powers:
                if k:
                    k.validate()
        if self.w_powers:
            for k in self.w_powers:
                if k:
                    k.validate()
        if self.t_powers:
            for k in self.t_powers:
                if k:
                    k.validate()
        if self.biz_domains:
            for k in self.biz_domains:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['powers'] = []
        if self.powers is not None:
            for k in self.powers:
                result['powers'].append(k.to_map() if k else None)
        result['bd_powers'] = []
        if self.bd_powers is not None:
            for k in self.bd_powers:
                result['bd_powers'].append(k.to_map() if k else None)
        result['w_powers'] = []
        if self.w_powers is not None:
            for k in self.w_powers:
                result['w_powers'].append(k.to_map() if k else None)
        result['t_powers'] = []
        if self.t_powers is not None:
            for k in self.t_powers:
                result['t_powers'].append(k.to_map() if k else None)
        if self.super_admin is not None:
            result['super_admin'] = self.super_admin
        if self.super_view is not None:
            result['super_view'] = self.super_view
        result['biz_domains'] = []
        if self.biz_domains is not None:
            for k in self.biz_domains:
                result['biz_domains'].append(k.to_map() if k else None)
        if self.auth_url is not None:
            result['auth_url'] = self.auth_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.powers = []
        if m.get('powers') is not None:
            for k in m.get('powers'):
                temp_model = LongListKeySet()
                self.powers.append(temp_model.from_map(k))
        self.bd_powers = []
        if m.get('bd_powers') is not None:
            for k in m.get('bd_powers'):
                temp_model = LongListKeySet()
                self.bd_powers.append(temp_model.from_map(k))
        self.w_powers = []
        if m.get('w_powers') is not None:
            for k in m.get('w_powers'):
                temp_model = LongListKeySet()
                self.w_powers.append(temp_model.from_map(k))
        self.t_powers = []
        if m.get('t_powers') is not None:
            for k in m.get('t_powers'):
                temp_model = LongListKeySet()
                self.t_powers.append(temp_model.from_map(k))
        if m.get('super_admin') is not None:
            self.super_admin = m.get('super_admin')
        if m.get('super_view') is not None:
            self.super_view = m.get('super_view')
        self.biz_domains = []
        if m.get('biz_domains') is not None:
            for k in m.get('biz_domains'):
                temp_model = BizDomain()
                self.biz_domains.append(temp_model.from_map(k))
        if m.get('auth_url') is not None:
            self.auth_url = m.get('auth_url')
        return self


class QueryLogpathMetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        fullpath: str = None,
        workspace_name: str = None,
        start: int = None,
        end: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名
        self.app_name = app_name
        # 日志路径
        self.fullpath = fullpath
        # 工作空间名
        self.workspace_name = workspace_name
        # 监控数据起始时间
        self.start = start
        # 监控数据结束时间
        self.end = end

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.fullpath, 'fullpath')
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.fullpath is not None:
            result['fullpath'] = self.fullpath
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('fullpath') is not None:
            self.fullpath = m.get('fullpath')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        return self


class QueryLogpathMetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        results: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 返回数据
        self.results = results

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.results is not None:
            result['results'] = self.results
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('results') is not None:
            self.results = m.get('results')
        return self


class QueryXmetricNameRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricNameResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XMetricInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XMetricInfo()
                self.data.append(temp_model.from_map(k))
        return self


class CreateAlarmwebhookRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        name: str = None,
        url: str = None,
        http_method: str = None,
        headers: List[KeySet] = None,
        params: List[KeySet] = None,
        config: List[KeySet] = None,
        body_template: str = None,
        scope_global: bool = None,
        valid_scope: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作区名
        self.workspace_name = workspace_name
        # web hook 名称
        self.name = name
        # web hook http url
        self.url = url
        # web hook http method
        self.http_method = http_method
        # web hook http headers
        self.headers = headers
        # web hook http params
        self.params = params
        # 配置项（timeOut，retryCount）
        self.config = config
        # body_template
        self.body_template = body_template
        # scope_global
        self.scope_global = scope_global
        # 当前workspace有效，还是当前租户有效
        self.valid_scope = valid_scope

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.name, 'name')
        self.validate_required(self.url, 'url')
        self.validate_required(self.http_method, 'http_method')
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()
        if self.params:
            for k in self.params:
                if k:
                    k.validate()
        if self.config:
            for k in self.config:
                if k:
                    k.validate()
        self.validate_required(self.scope_global, 'scope_global')
        self.validate_required(self.valid_scope, 'valid_scope')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        if self.http_method is not None:
            result['http_method'] = self.http_method
        result['headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['headers'].append(k.to_map() if k else None)
        result['params'] = []
        if self.params is not None:
            for k in self.params:
                result['params'].append(k.to_map() if k else None)
        result['config'] = []
        if self.config is not None:
            for k in self.config:
                result['config'].append(k.to_map() if k else None)
        if self.body_template is not None:
            result['body_template'] = self.body_template
        if self.scope_global is not None:
            result['scope_global'] = self.scope_global
        if self.valid_scope is not None:
            result['valid_scope'] = self.valid_scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('http_method') is not None:
            self.http_method = m.get('http_method')
        self.headers = []
        if m.get('headers') is not None:
            for k in m.get('headers'):
                temp_model = KeySet()
                self.headers.append(temp_model.from_map(k))
        self.params = []
        if m.get('params') is not None:
            for k in m.get('params'):
                temp_model = KeySet()
                self.params.append(temp_model.from_map(k))
        self.config = []
        if m.get('config') is not None:
            for k in m.get('config'):
                temp_model = KeySet()
                self.config.append(temp_model.from_map(k))
        if m.get('body_template') is not None:
            self.body_template = m.get('body_template')
        if m.get('scope_global') is not None:
            self.scope_global = m.get('scope_global')
        if m.get('valid_scope') is not None:
            self.valid_scope = m.get('valid_scope')
        return self


class CreateAlarmwebhookResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateXdatasourceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XDatasourceCRULResponseCURequest = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XDatasourceCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class CreateXdatasourceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XDatasourceCRULResponseCURequest = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XDatasourceCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class UpdateXdatasourceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XDatasourceCRULResponseCURequest = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XDatasourceCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class UpdateXdatasourceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XDatasourceCRULResponseCURequest = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XDatasourceCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class GetXdatasourceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XResource = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XResource()
            self.data = temp_model.from_map(m['data'])
        return self


class GetXdatasourceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XDatasourceCRULResponseCURequest = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XDatasourceCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class DeleteXdatasourceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XResource = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XResource()
            self.data = temp_model.from_map(m['data'])
        return self


class DeleteXdatasourceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XResource] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XResource()
                self.data.append(temp_model.from_map(k))
        return self


class ListXdatasourceDirectoryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XResource = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XResource()
            self.data = temp_model.from_map(m['data'])
        return self


class ListXdatasourceDirectoryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XDatasourceCRULResponseCURequest] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XDatasourceCRULResponseCURequest()
                self.data.append(temp_model.from_map(k))
        return self


class UpdateAlarmwebhookRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
        name: str = None,
        url: str = None,
        http_method: str = None,
        headers: List[KeySet] = None,
        params: List[KeySet] = None,
        config: List[KeySet] = None,
        body_template: str = None,
        scope_global: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace_name
        self.workspace_name = workspace_name
        # id
        self.id = id
        # name
        self.name = name
        # web hook http url
        self.url = url
        # web hook http method
        self.http_method = http_method
        # headers
        self.headers = headers
        # params
        self.params = params
        # config
        self.config = config
        # body_template
        self.body_template = body_template
        # scope_global
        self.scope_global = scope_global

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.url, 'url')
        self.validate_required(self.http_method, 'http_method')
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()
        if self.params:
            for k in self.params:
                if k:
                    k.validate()
        if self.config:
            for k in self.config:
                if k:
                    k.validate()
        self.validate_required(self.scope_global, 'scope_global')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.url is not None:
            result['url'] = self.url
        if self.http_method is not None:
            result['http_method'] = self.http_method
        result['headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['headers'].append(k.to_map() if k else None)
        result['params'] = []
        if self.params is not None:
            for k in self.params:
                result['params'].append(k.to_map() if k else None)
        result['config'] = []
        if self.config is not None:
            for k in self.config:
                result['config'].append(k.to_map() if k else None)
        if self.body_template is not None:
            result['body_template'] = self.body_template
        if self.scope_global is not None:
            result['scope_global'] = self.scope_global
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('http_method') is not None:
            self.http_method = m.get('http_method')
        self.headers = []
        if m.get('headers') is not None:
            for k in m.get('headers'):
                temp_model = KeySet()
                self.headers.append(temp_model.from_map(k))
        self.params = []
        if m.get('params') is not None:
            for k in m.get('params'):
                temp_model = KeySet()
                self.params.append(temp_model.from_map(k))
        self.config = []
        if m.get('config') is not None:
            for k in m.get('config'):
                temp_model = KeySet()
                self.config.append(temp_model.from_map(k))
        if m.get('body_template') is not None:
            self.body_template = m.get('body_template')
        if m.get('scope_global') is not None:
            self.scope_global = m.get('scope_global')
        return self


class UpdateAlarmwebhookResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteAlarmwebhookRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace_name
        self.workspace_name = workspace_name
        # id
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.id, 'id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteAlarmwebhookResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryXdatasourceTableRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXdatasourceTableResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XMetricQuery = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class GetAlarmOverviewRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        end_time: int = None,
        alarm_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        # 工作空间
        self.workspace_name = workspace_name
        # end_time
        self.end_time = end_time
        # alarm_type
        self.alarm_type = alarm_type

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.end_time, 'end_time')
        self.validate_required(self.alarm_type, 'alarm_type')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.alarm_type is not None:
            result['alarm_type'] = self.alarm_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('alarm_type') is not None:
            self.alarm_type = m.get('alarm_type')
        return self


class GetAlarmOverviewResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: AlarmOverviewDTO = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # AlarmOverviewDTO
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = AlarmOverviewDTO()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryAppAlarmstatsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        end_time: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # end_time
        self.end_time = end_time
        # 工作空间名称
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.end_time, 'end_time')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryAppAlarmstatsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[AppAlarmStats] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = AppAlarmStats()
                self.data.append(temp_model.from_map(k))
        return self


class QueryAlarmhistoryAlarmtrendsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        alarm_type: str = None,
        group_by: str = None,
        from_: int = None,
        to: int = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # alarm_type
        self.alarm_type = alarm_type
        # group_by
        self.group_by = group_by
        # from
        self.from_ = from_
        # to
        self.to = to
        # 工作空间名称
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.alarm_type, 'alarm_type')
        self.validate_required(self.group_by, 'group_by')
        self.validate_required(self.from_, 'from_')
        self.validate_required(self.to, 'to')
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.alarm_type is not None:
            result['alarm_type'] = self.alarm_type
        if self.group_by is not None:
            result['group_by'] = self.group_by
        if self.from_ is not None:
            result['from'] = self.from_
        if self.to is not None:
            result['to'] = self.to
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('alarm_type') is not None:
            self.alarm_type = m.get('alarm_type')
        if m.get('group_by') is not None:
            self.group_by = m.get('group_by')
        if m.get('from') is not None:
            self.from_ = m.get('from')
        if m.get('to') is not None:
            self.to = m.get('to')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryAlarmhistoryAlarmtrendsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: AlarmHistoryStatsVO = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = AlarmHistoryStatsVO()
            self.data = temp_model.from_map(m['data'])
        return self


class GetWorkspaceConfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetWorkspaceConfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        has_kubeconfig: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 是否拥有kubeconfig
        self.has_kubeconfig = has_kubeconfig

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.has_kubeconfig is not None:
            result['has_kubeconfig'] = self.has_kubeconfig
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('has_kubeconfig') is not None:
            self.has_kubeconfig = m.get('has_kubeconfig')
        return self


class SetAgentVersionstrategyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        type: int = None,
        scope: str = None,
        agent_url: str = None,
        agent_version: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 0 容器，1经典
        self.type = type
        # TENANT、WORKSPACE
        self.scope = scope
        # agent 地址，容器为镜像地址，经典为 OSS 地址
        self.agent_url = agent_url
        # 版本号
        self.agent_version = agent_version

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.type, 'type')
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.agent_url, 'agent_url')
        self.validate_required(self.agent_version, 'agent_version')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.type is not None:
            result['type'] = self.type
        if self.scope is not None:
            result['scope'] = self.scope
        if self.agent_url is not None:
            result['agent_url'] = self.agent_url
        if self.agent_version is not None:
            result['agent_version'] = self.agent_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('agent_url') is not None:
            self.agent_url = m.get('agent_url')
        if m.get('agent_version') is not None:
            self.agent_version = m.get('agent_version')
        return self


class SetAgentVersionstrategyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetAgentVersionstrategyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        type: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 0 容器，1经典
        self.type = type

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.type, 'type')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class GetAgentVersionstrategyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        agent_version_strategy: AgentVersionStrategy = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # agent 版本策略
        self.agent_version_strategy = agent_version_strategy

    def validate(self):
        if self.agent_version_strategy:
            self.agent_version_strategy.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.agent_version_strategy is not None:
            result['agent_version_strategy'] = self.agent_version_strategy.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('agent_version_strategy') is not None:
            temp_model = AgentVersionStrategy()
            self.agent_version_strategy = temp_model.from_map(m['agent_version_strategy'])
        return self


class GetSystemTimeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class GetSystemTimeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        time: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 服务器系统时间
        self.time = time

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.time is not None:
            result['time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('time') is not None:
            self.time = m.get('time')
        return self


class ExecXdatasourceMoveRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: List[XResource] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XResource()
                self.data.append(temp_model.from_map(k))
        return self


class ExecXdatasourceMoveResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XResource] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XResource()
                self.data.append(temp_model.from_map(k))
        return self


class QueryXmetadataTagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XTarget = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XTarget()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetadataTagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XRule = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XRule()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXdatasourceSearchRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        name: str = None,
        enabled: bool = None,
        target_resource_kind: str = None,
        target_resource_name: str = None,
        rule_type: str = None,
        created_by: str = None,
        parent_uuid: str = None,
        datasource_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.name = name
        # 
        self.enabled = enabled
        # 
        self.target_resource_kind = target_resource_kind
        # 
        self.target_resource_name = target_resource_name
        # 
        self.rule_type = rule_type
        # 
        self.created_by = created_by
        # 
        self.parent_uuid = parent_uuid
        # 
        self.datasource_type = datasource_type

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.name is not None:
            result['name'] = self.name
        if self.enabled is not None:
            result['enabled'] = self.enabled
        if self.target_resource_kind is not None:
            result['target_resource_kind'] = self.target_resource_kind
        if self.target_resource_name is not None:
            result['target_resource_name'] = self.target_resource_name
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.created_by is not None:
            result['created_by'] = self.created_by
        if self.parent_uuid is not None:
            result['parent_uuid'] = self.parent_uuid
        if self.datasource_type is not None:
            result['datasource_type'] = self.datasource_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('enabled') is not None:
            self.enabled = m.get('enabled')
        if m.get('target_resource_kind') is not None:
            self.target_resource_kind = m.get('target_resource_kind')
        if m.get('target_resource_name') is not None:
            self.target_resource_name = m.get('target_resource_name')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('created_by') is not None:
            self.created_by = m.get('created_by')
        if m.get('parent_uuid') is not None:
            self.parent_uuid = m.get('parent_uuid')
        if m.get('datasource_type') is not None:
            self.datasource_type = m.get('datasource_type')
        return self


class QueryXdatasourceSearchResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XDatasourceCRULResponseCURequest] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XDatasourceCRULResponseCURequest()
                self.data.append(temp_model.from_map(k))
        return self


class QuerySetupConfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        key: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.key = key

    def validate(self):
        self.validate_required(self.key, 'key')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.key is not None:
            result['key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('key') is not None:
            self.key = m.get('key')
        return self


class QuerySetupConfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XKeyJson = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # key jsonString
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XKeyJson()
            self.data = temp_model.from_map(m['data'])
        return self


class UpdateSetupConfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XKeyJson = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XKeyJson()
            self.data = temp_model.from_map(m['data'])
        return self


class UpdateSetupConfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XKeyJson = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XKeyJson()
            self.data = temp_model.from_map(m['data'])
        return self


class DeleteSetupConfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        key: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.key = key

    def validate(self):
        self.validate_required(self.key, 'key')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.key is not None:
            result['key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('key') is not None:
            self.key = m.get('key')
        return self


class DeleteSetupConfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XKeyJson = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XKeyJson()
            self.data = temp_model.from_map(m['data'])
        return self


class UpdateWorkspaceSettingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        workspace_setting_detail: WorkspaceSettingDetail = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace_name
        self.workspace_name = workspace_name
        # workspace_setting_detail
        self.workspace_setting_detail = workspace_setting_detail

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.workspace_setting_detail, 'workspace_setting_detail')
        if self.workspace_setting_detail:
            self.workspace_setting_detail.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.workspace_setting_detail is not None:
            result['workspace_setting_detail'] = self.workspace_setting_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('workspace_setting_detail') is not None:
            temp_model = WorkspaceSettingDetail()
            self.workspace_setting_detail = temp_model.from_map(m['workspace_setting_detail'])
        return self


class UpdateWorkspaceSettingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ExportXsiteConfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XSiteExport = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XSiteExport()
            self.data = temp_model.from_map(m['data'])
        return self


class ExportXsiteConfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XSiteExportData = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XSiteExportData()
            self.data = temp_model.from_map(m['data'])
        return self


class ImportXsiteConfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XSiteExportData = None,
        origin: str = None,
        replaced: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data
        # 替换前的字符串
        self.origin = origin
        # 替换后的字符串
        self.replaced = replaced

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.origin is not None:
            result['origin'] = self.origin
        if self.replaced is not None:
            result['replaced'] = self.replaced
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XSiteExportData()
            self.data = temp_model.from_map(m['data'])
        if m.get('origin') is not None:
            self.origin = m.get('origin')
        if m.get('replaced') is not None:
            self.replaced = m.get('replaced')
        return self


class ImportXsiteConfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XResource] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XResource()
                self.data.append(temp_model.from_map(k))
        return self


class QueryXdatasourceTreeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XDatasourceQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XDatasourceQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXdatasourceTreeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XDatasourceCRULResponseCURequest] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XDatasourceCRULResponseCURequest()
                self.data.append(temp_model.from_map(k))
        return self


class QueryXdashboardTreeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XDashboardQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XDashboardQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXdashboardTreeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[XDashboardCRULResponseCURequest] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = XDashboardCRULResponseCURequest()
                self.data.append(temp_model.from_map(k))
        return self


class GetXdashboardRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XResource = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XResource()
            self.data = temp_model.from_map(m['data'])
        return self


class GetXdashboardResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XDashboardCRULResponseCURequest = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XDashboardCRULResponseCURequest()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXdatasourcePrometheusRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XPrometheusQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XPrometheusQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXdatasourcePrometheusResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XPrometheusData = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XPrometheusData()
            self.data = temp_model.from_map(m['data'])
        return self


class GetNodeOverviewRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 查询开始时间，unix timestamp in ms
        self.start_time = start_time
        # 
        # 查询截止时间，unix timestamp in ms
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class GetNodeOverviewResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: NodeOverviewDTO = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 返回结果
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = NodeOverviewDTO()
            self.data = temp_model.from_map(m['data'])
        return self


class GetConfigOverviewRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetConfigOverviewResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: ConfigOverviewDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 总览页配置统计信息
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = ConfigOverviewDto()
            self.data = temp_model.from_map(m['data'])
        return self


class GetWorkspaceSettingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetWorkspaceSettingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_setting_detail: WorkspaceSettingDetail = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 工作空间配置
        self.workspace_setting_detail = workspace_setting_detail

    def validate(self):
        if self.workspace_setting_detail:
            self.workspace_setting_detail.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace_setting_detail is not None:
            result['workspace_setting_detail'] = self.workspace_setting_detail.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace_setting_detail') is not None:
            temp_model = WorkspaceSettingDetail()
            self.workspace_setting_detail = temp_model.from_map(m['workspace_setting_detail'])
        return self


class ListTraceWorkspacesettingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间，用来鉴权
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class ListTraceWorkspacesettingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        trace_workspace_settings: List[TraceWorkspaceSetting] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 工作空间配置
        self.trace_workspace_settings = trace_workspace_settings

    def validate(self):
        if self.trace_workspace_settings:
            for k in self.trace_workspace_settings:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['trace_workspace_settings'] = []
        if self.trace_workspace_settings is not None:
            for k in self.trace_workspace_settings:
                result['trace_workspace_settings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.trace_workspace_settings = []
        if m.get('trace_workspace_settings') is not None:
            for k in m.get('trace_workspace_settings'):
                temp_model = TraceWorkspaceSetting()
                self.trace_workspace_settings.append(temp_model.from_map(k))
        return self


class UpdateTraceWorkspacesettingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        trace_workspace_settings: List[TraceWorkspaceSetting] = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间配置
        self.trace_workspace_settings = trace_workspace_settings
        # 工作空间，用来鉴权
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.trace_workspace_settings, 'trace_workspace_settings')
        if self.trace_workspace_settings:
            for k in self.trace_workspace_settings:
                if k:
                    k.validate()
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['trace_workspace_settings'] = []
        if self.trace_workspace_settings is not None:
            for k in self.trace_workspace_settings:
                result['trace_workspace_settings'].append(k.to_map() if k else None)
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.trace_workspace_settings = []
        if m.get('trace_workspace_settings') is not None:
            for k in m.get('trace_workspace_settings'):
                temp_model = TraceWorkspaceSetting()
                self.trace_workspace_settings.append(temp_model.from_map(k))
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class UpdateTraceWorkspacesettingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListAppSettingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class ListAppSettingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_settings: List[AppSetting] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # APP配置列表
        self.app_settings = app_settings

    def validate(self):
        if self.app_settings:
            for k in self.app_settings:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_settings'] = []
        if self.app_settings is not None:
            for k in self.app_settings:
                result['app_settings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_settings = []
        if m.get('app_settings') is not None:
            for k in m.get('app_settings'):
                temp_model = AppSetting()
                self.app_settings.append(temp_model.from_map(k))
        return self


class UpdateAppSettingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        collect_enable: bool = None,
        workspace_name: str = None,
        setting: str = None,
        app_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 是否开启应用监控采集
        self.collect_enable = collect_enable
        # 工作空间名称
        self.workspace_name = workspace_name
        # 配置信息
        self.setting = setting
        # 应用名称
        self.app_name = app_name

    def validate(self):
        self.validate_required(self.collect_enable, 'collect_enable')
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.collect_enable is not None:
            result['collect_enable'] = self.collect_enable
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.setting is not None:
            result['setting'] = self.setting
        if self.app_name is not None:
            result['app_name'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('collect_enable') is not None:
            self.collect_enable = m.get('collect_enable')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('setting') is not None:
            self.setting = m.get('setting')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        return self


class UpdateAppSettingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetAppSettingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 应用名称
        self.app_name = app_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        return self


class GetAppSettingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_setting: AppSetting = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # APP配置
        self.app_setting = app_setting

    def validate(self):
        if self.app_setting:
            self.app_setting.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_setting is not None:
            result['app_setting'] = self.app_setting.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_setting') is not None:
            temp_model = AppSetting()
            self.app_setting = temp_model.from_map(m['app_setting'])
        return self


class QueryUnifiedalarmEventdetailRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        event_id: str = None,
        alarm_rule_id: int = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作区名
        self.workspace_name = workspace_name
        # event id
        self.event_id = event_id
        # 告警规则 ID
        self.alarm_rule_id = alarm_rule_id
        # 当前页
        self.current_page = current_page
        # 按page_size做记录切分。
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.event_id, 'event_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.event_id is not None:
            result['event_id'] = self.event_id
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('event_id') is not None:
            self.event_id = m.get('event_id')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryUnifiedalarmEventdetailResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        current_page: int = None,
        total_count: int = None,
        page_size: int = None,
        alarm_history_list: List[UnifiedAlarmHistoryVO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 当前页
        self.current_page = current_page
        # 总记录数
        self.total_count = total_count
        # 页面尺寸
        self.page_size = page_size
        # 告警消息列表
        self.alarm_history_list = alarm_history_list

    def validate(self):
        if self.alarm_history_list:
            for k in self.alarm_history_list:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.page_size is not None:
            result['page_size'] = self.page_size
        result['alarm_history_list'] = []
        if self.alarm_history_list is not None:
            for k in self.alarm_history_list:
                result['alarm_history_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        self.alarm_history_list = []
        if m.get('alarm_history_list') is not None:
            for k in m.get('alarm_history_list'):
                temp_model = UnifiedAlarmHistoryVO()
                self.alarm_history_list.append(temp_model.from_map(k))
        return self


class QueryUnifiedalarmMonitorlistRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        tenant_id: int = None,
        app_name: str = None,
        stack_id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 租户名称
        self.tenant_id = tenant_id
        # 应用名称
        self.app_name = app_name
        # 查询哪个技术栈下的告警指标。
        self.stack_id = stack_id

    def validate(self):
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.stack_id, 'stack_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.stack_id is not None:
            result['stack_id'] = self.stack_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('stack_id') is not None:
            self.stack_id = m.get('stack_id')
        return self


class QueryUnifiedalarmMonitorlistResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        stack_monitor_list: List[StackMonitorItem] = None,
        custom_plugin_list: List[CustomPluginDO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 缺省的监控指标。
        self.stack_monitor_list = stack_monitor_list
        # 用户定制的告警项。
        self.custom_plugin_list = custom_plugin_list

    def validate(self):
        if self.stack_monitor_list:
            for k in self.stack_monitor_list:
                if k:
                    k.validate()
        if self.custom_plugin_list:
            for k in self.custom_plugin_list:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['stack_monitor_list'] = []
        if self.stack_monitor_list is not None:
            for k in self.stack_monitor_list:
                result['stack_monitor_list'].append(k.to_map() if k else None)
        result['custom_plugin_list'] = []
        if self.custom_plugin_list is not None:
            for k in self.custom_plugin_list:
                result['custom_plugin_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.stack_monitor_list = []
        if m.get('stack_monitor_list') is not None:
            for k in m.get('stack_monitor_list'):
                temp_model = StackMonitorItem()
                self.stack_monitor_list.append(temp_model.from_map(k))
        self.custom_plugin_list = []
        if m.get('custom_plugin_list') is not None:
            for k in m.get('custom_plugin_list'):
                temp_model = CustomPluginDO()
                self.custom_plugin_list.append(temp_model.from_map(k))
        return self


class QueryXmetricTableRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        data: XMetricQuery = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 
        self.workspace_name = workspace_name
        # 
        self.data = data

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('data') is not None:
            temp_model = XMetricQuery()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryXmetricTableResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: XTableResponse = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = XTableResponse()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryTraceAppsqlmetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceAppsqlmetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceAppsqlstatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceAppsqlstatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class QueryTraceAppnosqlmetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceAppnosqlmetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceAppmqconsumemetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceAppmqconsumemetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceApprpcclientmetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceApprpcclientmetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceApprpcservermetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceApprpcservermetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceApphttpclientmetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceApphttpclientmetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceApphttpservermetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceApphttpservermetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceAppnosqlstatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceAppnosqlstatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class QueryTraceAppmqconsumestatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceAppmqconsumestatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class QueryTraceApphttpclientstatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceApphttpclientstatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class QueryTraceApphttpserverstatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceApphttpserverstatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class QueryTraceApprpcclientstatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceApprpcclientstatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class QueryTraceApprpcserverstatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceApprpcserverstatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class GetTraceWorkspacesettingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetTraceWorkspacesettingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        trace_workspace_setting: TraceWorkspaceSetting = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 工作空间配置
        self.trace_workspace_setting = trace_workspace_setting

    def validate(self):
        if self.trace_workspace_setting:
            self.trace_workspace_setting.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.trace_workspace_setting is not None:
            result['trace_workspace_setting'] = self.trace_workspace_setting.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('trace_workspace_setting') is not None:
            temp_model = TraceWorkspaceSetting()
            self.trace_workspace_setting = temp_model.from_map(m['trace_workspace_setting'])
        return self


class QueryTraceAppmqproducemetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceAppmqproducemetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceAppmqproducestatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceAppmqproducestatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class GetMeasurementStatusRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class GetMeasurementStatusResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        measurement_enable: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 计量计费是否开启
        self.measurement_enable = measurement_enable

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.measurement_enable is not None:
            result['measurement_enable'] = self.measurement_enable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('measurement_enable') is not None:
            self.measurement_enable = m.get('measurement_enable')
        return self


class QueryLogserviceAppsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 命名空间
        self.workspace_name = workspace_name
        # 租户名称
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.tenant_name, 'tenant_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class QueryLogserviceAppsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_id: int = None,
        tenant_id: int = None,
        total_count: int = None,
        result: List[AppMeta] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace id
        self.workspace_id = workspace_id
        # tenant_id
        self.tenant_id = tenant_id
        # 总量
        self.total_count = total_count
        # 应用详情列表
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.total_count is not None:
            result['total_count'] = self.total_count
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = AppMeta()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceApphttpserverstatusmetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceApphttpserverstatusmetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryAppAlarmrulesRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        stack_id: int = None,
        app_name: str = None,
        all: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 指标栈ID
        self.stack_id = stack_id
        # 应用名称
        self.app_name = app_name
        # 查询所有，还是查询当前设置的告警指标。
        self.all = all

    def validate(self):
        self.validate_required(self.stack_id, 'stack_id')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.all, 'all')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.stack_id is not None:
            result['stack_id'] = self.stack_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.all is not None:
            result['all'] = self.all
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('stack_id') is not None:
            self.stack_id = m.get('stack_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('all') is not None:
            self.all = m.get('all')
        return self


class QueryAppAlarmrulesResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        stack_metrics: List[StackMonitorItem] = None,
        custom_plugins: List[CustomPluginDO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 技术栈指标
        self.stack_metrics = stack_metrics
        # 应用自定义指标
        self.custom_plugins = custom_plugins

    def validate(self):
        if self.stack_metrics:
            for k in self.stack_metrics:
                if k:
                    k.validate()
        if self.custom_plugins:
            for k in self.custom_plugins:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['stack_metrics'] = []
        if self.stack_metrics is not None:
            for k in self.stack_metrics:
                result['stack_metrics'].append(k.to_map() if k else None)
        result['custom_plugins'] = []
        if self.custom_plugins is not None:
            for k in self.custom_plugins:
                result['custom_plugins'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.stack_metrics = []
        if m.get('stack_metrics') is not None:
            for k in m.get('stack_metrics'):
                temp_model = StackMonitorItem()
                self.stack_metrics.append(temp_model.from_map(k))
        self.custom_plugins = []
        if m.get('custom_plugins') is not None:
            for k in m.get('custom_plugins'):
                temp_model = CustomPluginDO()
                self.custom_plugins.append(temp_model.from_map(k))
        return self


class QueryTraceCompactdetailRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        trace_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # traceId
        self.trace_id = trace_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.trace_id, 'trace_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        return self


class QueryTraceCompactdetailResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        items: List[TraceCompactTreeItem] = None,
        attributes: List[KeySet] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 节点
        self.items = items
        # 描述整体链路的额外信息，比span总数，应用总数之类的
        self.attributes = attributes

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()
        if self.attributes:
            for k in self.attributes:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        result['attributes'] = []
        if self.attributes is not None:
            for k in self.attributes:
                result['attributes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = TraceCompactTreeItem()
                self.items.append(temp_model.from_map(k))
        self.attributes = []
        if m.get('attributes') is not None:
            for k in m.get('attributes'):
                temp_model = KeySet()
                self.attributes.append(temp_model.from_map(k))
        return self


class QueryTraceAppexceptionmetricsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryTraceAppexceptionmetricsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        return self


class QueryTraceAppexceptionstatRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app_name: str = None,
        start_time: int = None,
        end_time: int = None,
        sort_by: str = None,
        sort_reverse: bool = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 应用名
        self.app_name = app_name
        # 开始毫秒时间戳
        self.start_time = start_time
        # 结束毫秒时间戳
        self.end_time = end_time
        # 排序字段
        self.sort_by = sort_by
        # 排序是否逆序
        self.sort_reverse = sort_reverse
        # 分页页数
        self.page_number = page_number
        # 每页记录条数
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.start_time, 'start_time')
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.sort_by is not None:
            result['sort_by'] = self.sort_by
        if self.sort_reverse is not None:
            result['sort_reverse'] = self.sort_reverse
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('sort_by') is not None:
            self.sort_by = m.get('sort_by')
        if m.get('sort_reverse') is not None:
            self.sort_reverse = m.get('sort_reverse')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryTraceAppexceptionstatResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: List[TimeSeriesMetrics] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
        total_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 分页号
        self.current_page = current_page
        # 分页大小
        self.page_size = page_size
        # 查询总数
        self.total_size = total_size
        # 查询总页数
        self.total_page = total_page

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['result'] = []
        if self.result is not None:
            for k in self.result:
                result['result'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.total_page is not None:
            result['total_page'] = self.total_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.result = []
        if m.get('result') is not None:
            for k in m.get('result'):
                temp_model = TimeSeriesMetrics()
                self.result.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('total_page') is not None:
            self.total_page = m.get('total_page')
        return self


class QueryUnifiedalarmRulebindingRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        alarm_target_type: str = None,
        alarm_target_identity: str = None,
        alarm_rule_id: int = None,
        datasource: str = None,
        datasource_type: str = None,
        url: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 告警对象类型：APP应用，HOST主机
        self.alarm_target_type = alarm_target_type
        # 告警对象名称
        self.alarm_target_identity = alarm_target_identity
        # 告警规则ID
        self.alarm_rule_id = alarm_rule_id
        # 数据源 ID
        self.datasource = datasource
        # 数据源类型：CUSTOM自定义监控，STACK技术栈监控
        self.datasource_type = datasource_type
        # 监控指标 URL
        self.url = url

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.alarm_target_identity is not None:
            result['alarm_target_identity'] = self.alarm_target_identity
        if self.alarm_rule_id is not None:
            result['alarm_rule_id'] = self.alarm_rule_id
        if self.datasource is not None:
            result['datasource'] = self.datasource
        if self.datasource_type is not None:
            result['datasource_type'] = self.datasource_type
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('alarm_target_identity') is not None:
            self.alarm_target_identity = m.get('alarm_target_identity')
        if m.get('alarm_rule_id') is not None:
            self.alarm_rule_id = m.get('alarm_rule_id')
        if m.get('datasource') is not None:
            self.datasource = m.get('datasource')
        if m.get('datasource_type') is not None:
            self.datasource_type = m.get('datasource_type')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class QueryUnifiedalarmRulebindingResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        rule_bindings: List[UnifiedAlarmRuleBindingVO] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 告警规则绑定列表
        self.rule_bindings = rule_bindings

    def validate(self):
        if self.rule_bindings:
            for k in self.rule_bindings:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['rule_bindings'] = []
        if self.rule_bindings is not None:
            for k in self.rule_bindings:
                result['rule_bindings'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.rule_bindings = []
        if m.get('rule_bindings') is not None:
            for k in m.get('rule_bindings'):
                temp_model = UnifiedAlarmRuleBindingVO()
                self.rule_bindings.append(temp_model.from_map(k))
        return self


class QueryOpsCheckRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        current_page: int = None,
        page_size: int = None,
        app: str = None,
        app_status: int = None,
        custom_status: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 当前页
        self.current_page = current_page
        # 
        # 页面大小
        self.page_size = page_size
        # 应用名
        self.app = app
        # 应用监控指标状态 0：异常 1：正常 不传：全部
        self.app_status = app_status
        # 自定义监控指标状态 0：异常 1：正常 不传：全部
        self.custom_status = custom_status

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.app is not None:
            result['app'] = self.app
        if self.app_status is not None:
            result['app_status'] = self.app_status
        if self.custom_status is not None:
            result['custom_status'] = self.custom_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('app_status') is not None:
            self.app_status = m.get('app_status')
        if m.get('custom_status') is not None:
            self.custom_status = m.get('custom_status')
        return self


class QueryOpsCheckResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        ops_check_results: List[OpsCheckResult] = None,
        total_count: int = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # ops_check_results
        self.ops_check_results = ops_check_results
        # total_count
        self.total_count = total_count
        # current_page
        self.current_page = current_page
        # 页面大小
        self.page_size = page_size

    def validate(self):
        if self.ops_check_results:
            for k in self.ops_check_results:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['ops_check_results'] = []
        if self.ops_check_results is not None:
            for k in self.ops_check_results:
                result['ops_check_results'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.ops_check_results = []
        if m.get('ops_check_results') is not None:
            for k in m.get('ops_check_results'):
                temp_model = OpsCheckResult()
                self.ops_check_results.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryOpsAppcheckRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        app: str = None,
        status: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name
        # 应用名称
        self.app = app
        # 0：异常 1：正常
        self.status = status

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.app, 'app')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app is not None:
            result['app'] = self.app
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class QueryOpsAppcheckResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        ops_data_checks: List[OpsDataCheck] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 应用诊断
        self.ops_data_checks = ops_data_checks

    def validate(self):
        if self.ops_data_checks:
            for k in self.ops_data_checks:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['ops_data_checks'] = []
        if self.ops_data_checks is not None:
            for k in self.ops_data_checks:
                result['ops_data_checks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.ops_data_checks = []
        if m.get('ops_data_checks') is not None:
            for k in m.get('ops_data_checks'):
                temp_model = OpsDataCheck()
                self.ops_data_checks.append(temp_model.from_map(k))
        return self


class CreateAlarmDingdingrobotRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        robots: List[DingDingRobot] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作区名
        self.workspace_name = workspace_name
        # 钉钉机器人列表
        self.robots = robots

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.robots, 'robots')
        if self.robots:
            for k in self.robots:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        result['robots'] = []
        if self.robots is not None:
            for k in self.robots:
                result['robots'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        self.robots = []
        if m.get('robots') is not None:
            for k in m.get('robots'):
                temp_model = DingDingRobot()
                self.robots.append(temp_model.from_map(k))
        return self


class CreateAlarmDingdingrobotResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryAlarmDingdingrobotRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        only_current_staff: bool = None,
        current_page: int = None,
        page_size: int = None,
        name: str = None,
        token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作区名
        self.workspace_name = workspace_name
        # 只看当前用户创建的钉钉机器人
        self.only_current_staff = only_current_staff
        # 当前页
        self.current_page = current_page
        # 页面尺寸
        self.page_size = page_size
        # 机器人名称
        self.name = name
        # 根据token过滤
        self.token = token

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.only_current_staff is not None:
            result['only_current_staff'] = self.only_current_staff
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.name is not None:
            result['name'] = self.name
        if self.token is not None:
            result['token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('only_current_staff') is not None:
            self.only_current_staff = m.get('only_current_staff')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('token') is not None:
            self.token = m.get('token')
        return self


class QueryAlarmDingdingrobotResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        robots: List[DingDingRobot] = None,
        current_page: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 钉钉机器人列表
        self.robots = robots
        # 当前页
        self.current_page = current_page
        # 页大小
        self.page_size = page_size
        # 总记录数
        self.total_count = total_count

    def validate(self):
        if self.robots:
            for k in self.robots:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['robots'] = []
        if self.robots is not None:
            for k in self.robots:
                result['robots'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.robots = []
        if m.get('robots') is not None:
            for k in m.get('robots'):
                temp_model = DingDingRobot()
                self.robots.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class DeleteAlarmDingdingrobotRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        robots: List[DingDingRobot] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作区名
        self.workspace_name = workspace_name
        # 要删除的机器人列表
        self.robots = robots

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.robots, 'robots')
        if self.robots:
            for k in self.robots:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        result['robots'] = []
        if self.robots is not None:
            for k in self.robots:
                result['robots'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        self.robots = []
        if m.get('robots') is not None:
            for k in m.get('robots'):
                temp_model = DingDingRobot()
                self.robots.append(temp_model.from_map(k))
        return self


class DeleteAlarmDingdingrobotResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateAlarmDingdingrobotRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        robots: List[DingDingRobot] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作区名
        self.workspace_name = workspace_name
        # 更新的机器人清单
        self.robots = robots

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.robots, 'robots')
        if self.robots:
            for k in self.robots:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        result['robots'] = []
        if self.robots is not None:
            for k in self.robots:
                result['robots'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        self.robots = []
        if m.get('robots') is not None:
            for k in m.get('robots'):
                temp_model = DingDingRobot()
                self.robots.append(temp_model.from_map(k))
        return self


class UpdateAlarmDingdingrobotResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryAppsAlarmrulecountRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        apps: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 查询app清单
        self.apps = apps

    def validate(self):
        self.validate_required(self.apps, 'apps')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.apps is not None:
            result['apps'] = self.apps
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('apps') is not None:
            self.apps = m.get('apps')
        return self


class QueryAppsAlarmrulecountResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_alarm_rule_counts: List[AppAlarmRuleCount] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 应用告警规则数清单
        self.app_alarm_rule_counts = app_alarm_rule_counts

    def validate(self):
        if self.app_alarm_rule_counts:
            for k in self.app_alarm_rule_counts:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_alarm_rule_counts'] = []
        if self.app_alarm_rule_counts is not None:
            for k in self.app_alarm_rule_counts:
                result['app_alarm_rule_counts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_alarm_rule_counts = []
        if m.get('app_alarm_rule_counts') is not None:
            for k in m.get('app_alarm_rule_counts'):
                temp_model = AppAlarmRuleCount()
                self.app_alarm_rule_counts.append(temp_model.from_map(k))
        return self


class QueryAppsUnifiedalarmstatsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        start_time: int = None,
        end_time: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 告警开始时间
        self.start_time = start_time
        # 告警结束时间
        self.end_time = end_time

    def validate(self):
        self.validate_required(self.end_time, 'end_time')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        return self


class QueryAppsUnifiedalarmstatsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_alarm_status: List[AppAlarmStats] = None,
        total_app_count: int = None,
        alarm_app_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 正在告警的所有应用状态
        self.app_alarm_status = app_alarm_status
        # 总应用数
        self.total_app_count = total_app_count
        # 正在告警的应用数
        self.alarm_app_count = alarm_app_count

    def validate(self):
        if self.app_alarm_status:
            for k in self.app_alarm_status:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_alarm_status'] = []
        if self.app_alarm_status is not None:
            for k in self.app_alarm_status:
                result['app_alarm_status'].append(k.to_map() if k else None)
        if self.total_app_count is not None:
            result['total_app_count'] = self.total_app_count
        if self.alarm_app_count is not None:
            result['alarm_app_count'] = self.alarm_app_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_alarm_status = []
        if m.get('app_alarm_status') is not None:
            for k in m.get('app_alarm_status'):
                temp_model = AppAlarmStats()
                self.app_alarm_status.append(temp_model.from_map(k))
        if m.get('total_app_count') is not None:
            self.total_app_count = m.get('total_app_count')
        if m.get('alarm_app_count') is not None:
            self.alarm_app_count = m.get('alarm_app_count')
        return self


class SwitchOpsAlarmRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        alarm_target_type: str = None,
        status: int = None,
        alarm_target_identity: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # DATA_OPS： 诊断告警
        # AGENT：agent告警
        # 
        self.alarm_target_type = alarm_target_type
        # 1：开启告警
        # 0：暂停告警
        self.status = status
        # 应用
        self.alarm_target_identity = alarm_target_identity

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.alarm_target_type, 'alarm_target_type')
        self.validate_required(self.status, 'status')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.alarm_target_type is not None:
            result['alarm_target_type'] = self.alarm_target_type
        if self.status is not None:
            result['status'] = self.status
        if self.alarm_target_identity is not None:
            result['alarm_target_identity'] = self.alarm_target_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('alarm_target_type') is not None:
            self.alarm_target_type = m.get('alarm_target_type')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('alarm_target_identity') is not None:
            self.alarm_target_identity = m.get('alarm_target_identity')
        return self


class SwitchOpsAlarmResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class AllTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenants: List[TraasTenantDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenants
        self.tenants = tenants

    def validate(self):
        if self.tenants:
            for k in self.tenants:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['tenants'] = []
        if self.tenants is not None:
            for k in self.tenants:
                result['tenants'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.tenants = []
        if m.get('tenants') is not None:
            for k in m.get('tenants'):
                temp_model = TraasTenantDto()
                self.tenants.append(temp_model.from_map(k))
        return self


class AllTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        regions: List[TraasRegionDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # regions
        self.regions = regions

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['regions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.regions = []
        if m.get('regions') is not None:
            for k in m.get('regions'):
                temp_model = TraasRegionDto()
                self.regions.append(temp_model.from_map(k))
        return self


class PagequeryTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        return self


class PagequeryTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenants: List[TraasTenantDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenants
        self.tenants = tenants
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.tenants:
            for k in self.tenants:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['tenants'] = []
        if self.tenants is not None:
            for k in self.tenants:
                result['tenants'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.tenants = []
        if m.get('tenants') is not None:
            for k in m.get('tenants'):
                temp_model = TraasTenantDto()
                self.tenants.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class GetTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenant: TraasTenantDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenant
        self.tenant = tenant

    def validate(self):
        if self.tenant:
            self.tenant.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.tenant is not None:
            result['tenant'] = self.tenant.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('tenant') is not None:
            temp_model = TraasTenantDto()
            self.tenant = temp_model.from_map(m['tenant'])
        return self


class QueryTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        search: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # 是否是模糊搜索，默认为false
        self.search = search

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        return self


class QueryTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenants: List[TraasTenantDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenants
        self.tenants = tenants

    def validate(self):
        if self.tenants:
            for k in self.tenants:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['tenants'] = []
        if self.tenants is not None:
            for k in self.tenants:
                result['tenants'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.tenants = []
        if m.get('tenants') is not None:
            for k in m.get('tenants'):
                temp_model = TraasTenantDto()
                self.tenants.append(temp_model.from_map(k))
        return self


class BatchqueryTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        names: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid数组
        self.uuids = uuids
        # names
        self.names = names

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.names is not None:
            result['names'] = self.names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('names') is not None:
            self.names = m.get('names')
        return self


class BatchqueryTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenants: List[TraasTenantDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenants
        self.tenants = tenants

    def validate(self):
        if self.tenants:
            for k in self.tenants:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['tenants'] = []
        if self.tenants is not None:
            for k in self.tenants:
                result['tenants'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.tenants = []
        if m.get('tenants') is not None:
            for k in m.get('tenants'):
                temp_model = TraasTenantDto()
                self.tenants.append(temp_model.from_map(k))
        return self


class CreateTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # tenant name
        self.name = name
        # display_name
        self.display_name = display_name
        # outsideId
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from

    def validate(self):
        self.validate_required(self.name, 'name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        return self


class CreateTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenant: TraasTenantDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenant
        self.tenant = tenant

    def validate(self):
        if self.tenant:
            self.tenant.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.tenant is not None:
            result['tenant'] = self.tenant.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('tenant') is not None:
            temp_model = TraasTenantDto()
            self.tenant = temp_model.from_map(m['tenant'])
        return self


class BatchcreateTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        tenants: List[TraasTenantDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 租户列表
        self.tenants = tenants

    def validate(self):
        self.validate_required(self.tenants, 'tenants')
        if self.tenants:
            for k in self.tenants:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['tenants'] = []
        if self.tenants is not None:
            for k in self.tenants:
                result['tenants'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.tenants = []
        if m.get('tenants') is not None:
            for k in m.get('tenants'):
                temp_model = TraasTenantDto()
                self.tenants.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenants: List[TraasTenantDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenants
        self.tenants = tenants

    def validate(self):
        if self.tenants:
            for k in self.tenants:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['tenants'] = []
        if self.tenants is not None:
            for k in self.tenants:
                result['tenants'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.tenants = []
        if m.get('tenants') is not None:
            for k in m.get('tenants'):
                temp_model = TraasTenantDto()
                self.tenants.append(temp_model.from_map(k))
        return self


class UpdateTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        display_name: str = None,
        outside_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id

    def validate(self):
        self.validate_required(self.uuid, 'uuid')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.outside_id, 'outside_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        return self


class UpdateTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenant: TraasTenantDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenant
        self.tenant = tenant

    def validate(self):
        if self.tenant:
            self.tenant.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.tenant is not None:
            result['tenant'] = self.tenant.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('tenant') is not None:
            temp_model = TraasTenantDto()
            self.tenant = temp_model.from_map(m['tenant'])
        return self


class DeleteTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteTraasmetaTenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaTenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class GetTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        region: TraasRegionDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # traasregiondto
        self.region = region

    def validate(self):
        if self.region:
            self.region.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.region is not None:
            result['region'] = self.region.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('region') is not None:
            temp_model = TraasRegionDto()
            self.region = temp_model.from_map(m['region'])
        return self


class AllTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zones: List[TraasZoneDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zones
        self.zones = zones

    def validate(self):
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = TraasZoneDto()
                self.zones.append(temp_model.from_map(k))
        return self


class GetTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class GetTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zone: TraasZoneDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zone
        self.zone = zone

    def validate(self):
        if self.zone:
            self.zone.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.zone is not None:
            result['zone'] = self.zone.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('zone') is not None:
            temp_model = TraasZoneDto()
            self.zone = temp_model.from_map(m['zone'])
        return self


class CreateTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class CreateTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        region: TraasRegionDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # region
        self.region = region

    def validate(self):
        if self.region:
            self.region.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.region is not None:
            result['region'] = self.region.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('region') is not None:
            temp_model = TraasRegionDto()
            self.region = temp_model.from_map(m['region'])
        return self


class UpdateAgentLabelRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        collect_ids: List[str] = None,
        label: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 唯一标识数组
        self.collect_ids = collect_ids
        # 标记是否开启告警
        # 1：开启告警
        # 0：关闭告警
        self.label = label

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.collect_ids, 'collect_ids')
        self.validate_required(self.label, 'label')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.collect_ids is not None:
            result['collect_ids'] = self.collect_ids
        if self.label is not None:
            result['label'] = self.label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('collect_ids') is not None:
            self.collect_ids = m.get('collect_ids')
        if m.get('label') is not None:
            self.label = m.get('label')
        return self


class UpdateAgentLabelResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        region_uuid: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # region_uuid
        self.region_uuid = region_uuid
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')
        self.validate_required(self.region_uuid, 'region_uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.region_uuid is not None:
            result['region_uuid'] = self.region_uuid
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('region_uuid') is not None:
            self.region_uuid = m.get('region_uuid')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class CreateTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zone: TraasZoneDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zone
        self.zone = zone

    def validate(self):
        if self.zone:
            self.zone.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.zone is not None:
            result['zone'] = self.zone.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('zone') is not None:
            temp_model = TraasZoneDto()
            self.zone = temp_model.from_map(m['zone'])
        return self


class DeleteTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        display_name: str = None,
        outside_id: str = None,
        extension: str = None,
        name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # extension
        self.extension = extension
        # name
        self.name = name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.extension is not None:
            result['extension'] = self.extension
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class UpdateTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        region: TraasRegionDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # region
        self.region = region

    def validate(self):
        if self.region:
            self.region.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.region is not None:
            result['region'] = self.region.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('region') is not None:
            temp_model = TraasRegionDto()
            self.region = temp_model.from_map(m['region'])
        return self


class UpdateTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        extension: str = None,
        region_uuid: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # extension
        self.extension = extension
        # region_uuid
        self.region_uuid = region_uuid
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.extension is not None:
            result['extension'] = self.extension
        if self.region_uuid is not None:
            result['region_uuid'] = self.region_uuid
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('region_uuid') is not None:
            self.region_uuid = m.get('region_uuid')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class UpdateTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zone: TraasZoneDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zone
        self.zone = zone

    def validate(self):
        if self.zone:
            self.zone.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.zone is not None:
            result['zone'] = self.zone.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('zone') is not None:
            temp_model = TraasZoneDto()
            self.zone = temp_model.from_map(m['zone'])
        return self


class QueryTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class QueryTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        regions: List[TraasRegionDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # regions
        # 
        self.regions = regions

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['regions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.regions = []
        if m.get('regions') is not None:
            for k in m.get('regions'):
                temp_model = TraasRegionDto()
                self.regions.append(temp_model.from_map(k))
        return self


class QueryTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class QueryTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zones: List[TraasZoneDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zones
        # 
        self.zones = zones

    def validate(self):
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = TraasZoneDto()
                self.zones.append(temp_model.from_map(k))
        return self


class PagequeryTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        search: bool = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 
        # 当前页
        self.current_page = current_page
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # 是否是模糊搜索，默认为false
        self.search = search
        # name
        self.name = name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.search is not None:
            result['search'] = self.search
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class PagequeryTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        regions: List[TraasRegionDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # regions
        self.regions = regions
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['regions'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.regions = []
        if m.get('regions') is not None:
            for k in m.get('regions'):
                temp_model = TraasRegionDto()
                self.regions.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class PagequeryTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        search: bool = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # 是否是模糊搜索，默认为false
        self.search = search
        # name
        self.name = name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.search is not None:
            result['search'] = self.search
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class PagequeryTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zones: List[TraasZoneDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zones
        self.zones = zones
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = TraasZoneDto()
                self.zones.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class BatchqueryTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        names: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # names
        self.names = names
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.names is not None:
            result['names'] = self.names
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('names') is not None:
            self.names = m.get('names')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class BatchqueryTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        regions: List[TraasRegionDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # regions
        self.regions = regions

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['regions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.regions = []
        if m.get('regions') is not None:
            for k in m.get('regions'):
                temp_model = TraasRegionDto()
                self.regions.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        regions: List[TraasRegionDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # regions
        self.regions = regions

    def validate(self):
        self.validate_required(self.regions, 'regions')
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['regions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.regions = []
        if m.get('regions') is not None:
            for k in m.get('regions'):
                temp_model = TraasRegionDto()
                self.regions.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        regions: List[TraasRegionDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # regions
        self.regions = regions

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['regions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.regions = []
        if m.get('regions') is not None:
            for k in m.get('regions'):
                temp_model = TraasRegionDto()
                self.regions.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        zones: List[TraasZoneDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # zones
        self.zones = zones

    def validate(self):
        self.validate_required(self.zones, 'zones')
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = TraasZoneDto()
                self.zones.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zones: List[TraasZoneDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zones
        self.zones = zones

    def validate(self):
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = TraasZoneDto()
                self.zones.append(temp_model.from_map(k))
        return self


class BatchqueryTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        names: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # names
        self.names = names
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.names is not None:
            result['names'] = self.names
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('names') is not None:
            self.names = m.get('names')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class BatchqueryTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zones: List[TraasZoneDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zones
        self.zones = zones

    def validate(self):
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = TraasZoneDto()
                self.zones.append(temp_model.from_map(k))
        return self


class BatchdeleteTraasmetaRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteTraasmetaZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class AllTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        apps: List[TraasAppDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # appdto
        self.apps = apps

    def validate(self):
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['apps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.apps = []
        if m.get('apps') is not None:
            for k in m.get('apps'):
                temp_model = TraasAppDto()
                self.apps.append(temp_model.from_map(k))
        return self


class AllTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_groups: List[TraasAppGroupDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # appgroupsdto
        self.app_groups = app_groups

    def validate(self):
        if self.app_groups:
            for k in self.app_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_groups'] = []
        if self.app_groups is not None:
            for k in self.app_groups:
                result['app_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_groups = []
        if m.get('app_groups') is not None:
            for k in m.get('app_groups'):
                temp_model = TraasAppGroupDto()
                self.app_groups.append(temp_model.from_map(k))
        return self


class AllTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_servers: List[TraasAppServerDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_servers
        self.app_servers = app_servers

    def validate(self):
        if self.app_servers:
            for k in self.app_servers:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_servers'] = []
        if self.app_servers is not None:
            for k in self.app_servers:
                result['app_servers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_servers = []
        if m.get('app_servers') is not None:
            for k in m.get('app_servers'):
                temp_model = TraasAppServerDto()
                self.app_servers.append(temp_model.from_map(k))
        return self


class AllTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_tags: List[TraasAppTagDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_tags
        self.app_tags = app_tags

    def validate(self):
        if self.app_tags:
            for k in self.app_tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_tags'] = []
        if self.app_tags is not None:
            for k in self.app_tags:
                result['app_tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_tags = []
        if m.get('app_tags') is not None:
            for k in m.get('app_tags'):
                temp_model = TraasAppTagDto()
                self.app_tags.append(temp_model.from_map(k))
        return self


class AllTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspaces: List[TraasWorkspaceDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspaces
        self.workspaces = workspaces

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = TraasWorkspaceDto()
                self.workspaces.append(temp_model.from_map(k))
        return self


class AllTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_groups: List[TraasWorkspaceGroupDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace_groups
        self.workspace_groups = workspace_groups

    def validate(self):
        if self.workspace_groups:
            for k in self.workspace_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspace_groups'] = []
        if self.workspace_groups is not None:
            for k in self.workspace_groups:
                result['workspace_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspace_groups = []
        if m.get('workspace_groups') is not None:
            for k in m.get('workspace_groups'):
                temp_model = TraasWorkspaceGroupDto()
                self.workspace_groups.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_groups: List[TraasWorkspaceGroupDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace_groups
        self.workspace_groups = workspace_groups

    def validate(self):
        self.validate_required(self.workspace_groups, 'workspace_groups')
        if self.workspace_groups:
            for k in self.workspace_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['workspace_groups'] = []
        if self.workspace_groups is not None:
            for k in self.workspace_groups:
                result['workspace_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.workspace_groups = []
        if m.get('workspace_groups') is not None:
            for k in m.get('workspace_groups'):
                temp_model = TraasWorkspaceGroupDto()
                self.workspace_groups.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_groups: List[TraasWorkspaceGroupDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace_groups
        self.workspace_groups = workspace_groups

    def validate(self):
        if self.workspace_groups:
            for k in self.workspace_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspace_groups'] = []
        if self.workspace_groups is not None:
            for k in self.workspace_groups:
                result['workspace_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspace_groups = []
        if m.get('workspace_groups') is not None:
            for k in m.get('workspace_groups'):
                temp_model = TraasWorkspaceGroupDto()
                self.workspace_groups.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        apps: List[TraasAppDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # apps
        self.apps = apps

    def validate(self):
        self.validate_required(self.apps, 'apps')
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['apps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.apps = []
        if m.get('apps') is not None:
            for k in m.get('apps'):
                temp_model = TraasAppDto()
                self.apps.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        apps: List[TraasAppDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # apps
        self.apps = apps

    def validate(self):
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['apps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.apps = []
        if m.get('apps') is not None:
            for k in m.get('apps'):
                temp_model = TraasAppDto()
                self.apps.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_groups: List[TraasAppGroupDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app_groups
        self.app_groups = app_groups

    def validate(self):
        self.validate_required(self.app_groups, 'app_groups')
        if self.app_groups:
            for k in self.app_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['app_groups'] = []
        if self.app_groups is not None:
            for k in self.app_groups:
                result['app_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.app_groups = []
        if m.get('app_groups') is not None:
            for k in m.get('app_groups'):
                temp_model = TraasAppGroupDto()
                self.app_groups.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_groups: List[TraasAppGroupDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_groups
        self.app_groups = app_groups

    def validate(self):
        if self.app_groups:
            for k in self.app_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_groups'] = []
        if self.app_groups is not None:
            for k in self.app_groups:
                result['app_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_groups = []
        if m.get('app_groups') is not None:
            for k in m.get('app_groups'):
                temp_model = TraasAppGroupDto()
                self.app_groups.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_servers: List[TraasAppServerDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app_servers
        self.app_servers = app_servers

    def validate(self):
        self.validate_required(self.app_servers, 'app_servers')
        if self.app_servers:
            for k in self.app_servers:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['app_servers'] = []
        if self.app_servers is not None:
            for k in self.app_servers:
                result['app_servers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.app_servers = []
        if m.get('app_servers') is not None:
            for k in m.get('app_servers'):
                temp_model = TraasAppServerDto()
                self.app_servers.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_servers: List[TraasAppServerDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_servers
        self.app_servers = app_servers

    def validate(self):
        if self.app_servers:
            for k in self.app_servers:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_servers'] = []
        if self.app_servers is not None:
            for k in self.app_servers:
                result['app_servers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_servers = []
        if m.get('app_servers') is not None:
            for k in m.get('app_servers'):
                temp_model = TraasAppServerDto()
                self.app_servers.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_tags: List[TraasAppTagDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app_tags
        self.app_tags = app_tags

    def validate(self):
        self.validate_required(self.app_tags, 'app_tags')
        if self.app_tags:
            for k in self.app_tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['app_tags'] = []
        if self.app_tags is not None:
            for k in self.app_tags:
                result['app_tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.app_tags = []
        if m.get('app_tags') is not None:
            for k in m.get('app_tags'):
                temp_model = TraasAppTagDto()
                self.app_tags.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_tags: List[TraasAppTagDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_tags
        self.app_tags = app_tags

    def validate(self):
        if self.app_tags:
            for k in self.app_tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_tags'] = []
        if self.app_tags is not None:
            for k in self.app_tags:
                result['app_tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_tags = []
        if m.get('app_tags') is not None:
            for k in m.get('app_tags'):
                temp_model = TraasAppTagDto()
                self.app_tags.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspaces: List[TraasWorkspaceDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspaces
        self.workspaces = workspaces

    def validate(self):
        self.validate_required(self.workspaces, 'workspaces')
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = TraasWorkspaceDto()
                self.workspaces.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspaces: List[TraasWorkspaceDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspaces
        self.workspaces = workspaces

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = TraasWorkspaceDto()
                self.workspaces.append(temp_model.from_map(k))
        return self


class BatchdeleteTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchqueryTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        names: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # names
        self.names = names
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.names is not None:
            result['names'] = self.names
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('names') is not None:
            self.names = m.get('names')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class BatchqueryTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_groups: List[TraasWorkspaceGroupDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace_groups
        self.workspace_groups = workspace_groups

    def validate(self):
        if self.workspace_groups:
            for k in self.workspace_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspace_groups'] = []
        if self.workspace_groups is not None:
            for k in self.workspace_groups:
                result['workspace_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspace_groups = []
        if m.get('workspace_groups') is not None:
            for k in m.get('workspace_groups'):
                temp_model = TraasWorkspaceGroupDto()
                self.workspace_groups.append(temp_model.from_map(k))
        return self


class BatchqueryTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        names: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # names
        self.names = names
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.names is not None:
            result['names'] = self.names
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('names') is not None:
            self.names = m.get('names')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class BatchqueryTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspaces: List[TraasWorkspaceDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspaces
        self.workspaces = workspaces

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = TraasWorkspaceDto()
                self.workspaces.append(temp_model.from_map(k))
        return self


class BatchqueryTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        app_names: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        tag_keys: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # app_names
        self.app_names = app_names
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # tag_keys
        self.tag_keys = tag_keys

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.app_names is not None:
            result['app_names'] = self.app_names
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.tag_keys is not None:
            result['tag_keys'] = self.tag_keys
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('app_names') is not None:
            self.app_names = m.get('app_names')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('tag_keys') is not None:
            self.tag_keys = m.get('tag_keys')
        return self


class BatchqueryTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_tags: List[TraasAppTagDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_tags
        self.app_tags = app_tags

    def validate(self):
        if self.app_tags:
            for k in self.app_tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_tags'] = []
        if self.app_tags is not None:
            for k in self.app_tags:
                result['app_tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_tags = []
        if m.get('app_tags') is not None:
            for k in m.get('app_tags'):
                temp_model = TraasAppTagDto()
                self.app_tags.append(temp_model.from_map(k))
        return self


class BatchqueryTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        hostnames: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        ips: List[str] = None,
        app_names: List[str] = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # hostnames
        self.hostnames = hostnames
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # ips
        self.ips = ips
        # app_names
        self.app_names = app_names
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.hostnames is not None:
            result['hostnames'] = self.hostnames
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.ips is not None:
            result['ips'] = self.ips
        if self.app_names is not None:
            result['app_names'] = self.app_names
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('hostnames') is not None:
            self.hostnames = m.get('hostnames')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('ips') is not None:
            self.ips = m.get('ips')
        if m.get('app_names') is not None:
            self.app_names = m.get('app_names')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class BatchqueryTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_servers: List[TraasAppServerDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_servers
        self.app_servers = app_servers

    def validate(self):
        if self.app_servers:
            for k in self.app_servers:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_servers'] = []
        if self.app_servers is not None:
            for k in self.app_servers:
                result['app_servers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_servers = []
        if m.get('app_servers') is not None:
            for k in m.get('app_servers'):
                temp_model = TraasAppServerDto()
                self.app_servers.append(temp_model.from_map(k))
        return self


class BatchqueryTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        names: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # names
        self.names = names
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.names is not None:
            result['names'] = self.names
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('names') is not None:
            self.names = m.get('names')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class BatchqueryTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_groups: List[TraasAppGroupDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_groups
        self.app_groups = app_groups

    def validate(self):
        if self.app_groups:
            for k in self.app_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_groups'] = []
        if self.app_groups is not None:
            for k in self.app_groups:
                result['app_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_groups = []
        if m.get('app_groups') is not None:
            for k in m.get('app_groups'):
                temp_model = TraasAppGroupDto()
                self.app_groups.append(temp_model.from_map(k))
        return self


class BatchqueryTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        names: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # names
        self.names = names
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.names is not None:
            result['names'] = self.names
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('names') is not None:
            self.names = m.get('names')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class BatchqueryTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        apps: List[TraasAppDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # apps
        self.apps = apps

    def validate(self):
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['apps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.apps = []
        if m.get('apps') is not None:
            for k in m.get('apps'):
                temp_model = TraasAppDto()
                self.apps.append(temp_model.from_map(k))
        return self


class DeleteTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class GetTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app: TraasAppDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app
        self.app = app

    def validate(self):
        if self.app:
            self.app.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app is not None:
            result['app'] = self.app.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app') is not None:
            temp_model = TraasAppDto()
            self.app = temp_model.from_map(m['app'])
        return self


class GetTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class GetTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_group: TraasAppGroupDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_group
        self.app_group = app_group

    def validate(self):
        if self.app_group:
            self.app_group.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_group is not None:
            result['app_group'] = self.app_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_group') is not None:
            temp_model = TraasAppGroupDto()
            self.app_group = temp_model.from_map(m['app_group'])
        return self


class GetTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        ip: str = None,
        app_name: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # ip
        self.ip = ip
        # app_name
        self.app_name = app_name
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.ip is not None:
            result['ip'] = self.ip
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_server: TraasAppServerDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_server
        self.app_server = app_server

    def validate(self):
        if self.app_server:
            self.app_server.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_server is not None:
            result['app_server'] = self.app_server.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_server') is not None:
            temp_model = TraasAppServerDto()
            self.app_server = temp_model.from_map(m['app_server'])
        return self


class GetTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        app_name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        tag_key: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # app_name
        self.app_name = app_name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # tag_key
        self.tag_key = tag_key

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.tag_key is not None:
            result['tag_key'] = self.tag_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('tag_key') is not None:
            self.tag_key = m.get('tag_key')
        return self


class GetTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_tag: TraasAppTagDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_tag
        self.app_tag = app_tag

    def validate(self):
        if self.app_tag:
            self.app_tag.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_tag is not None:
            result['app_tag'] = self.app_tag.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_tag') is not None:
            temp_model = TraasAppTagDto()
            self.app_tag = temp_model.from_map(m['app_tag'])
        return self


class GetTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class GetTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace: TraasWorkspaceDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace') is not None:
            temp_model = TraasWorkspaceDto()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class GetTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class GetTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_group: TraasWorkspaceGroupDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace_group
        self.workspace_group = workspace_group

    def validate(self):
        if self.workspace_group:
            self.workspace_group.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace_group') is not None:
            temp_model = TraasWorkspaceGroupDto()
            self.workspace_group = temp_model.from_map(m['workspace_group'])
        return self


class PagequeryTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        search: bool = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        # 
        self.tenant_name = tenant_name
        # 是否是模糊搜索，默认为false
        self.search = search
        # name
        self.name = name

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.current_page, 'current_page')
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.search is not None:
            result['search'] = self.search
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class PagequeryTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_groups: List[TraasWorkspaceGroupDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace_groups
        self.workspace_groups = workspace_groups
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.workspace_groups:
            for k in self.workspace_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspace_groups'] = []
        if self.workspace_groups is not None:
            for k in self.workspace_groups:
                result['workspace_groups'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspace_groups = []
        if m.get('workspace_groups') is not None:
            for k in m.get('workspace_groups'):
                temp_model = TraasWorkspaceGroupDto()
                self.workspace_groups.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class PagequeryTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        search: bool = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        # 
        self.tenant_name = tenant_name
        # 是否是模糊搜索，默认为false
        self.search = search
        # name
        self.name = name

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.current_page, 'current_page')
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.search is not None:
            result['search'] = self.search
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class PagequeryTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspaces: List[TraasWorkspaceDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspaces
        self.workspaces = workspaces
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = TraasWorkspaceDto()
                self.workspaces.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class PagequeryTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        app_name: str = None,
        search: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # app_name
        self.app_name = app_name
        # 是否是模糊搜索，默认为false
        self.search = search

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.current_page, 'current_page')
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.search is not None:
            result['search'] = self.search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('search') is not None:
            self.search = m.get('search')
        return self


class PagequeryTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_tags: List[TraasAppTagDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_tags
        self.app_tags = app_tags
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.app_tags:
            for k in self.app_tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_tags'] = []
        if self.app_tags is not None:
            for k in self.app_tags:
                result['app_tags'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_tags = []
        if m.get('app_tags') is not None:
            for k in m.get('app_tags'):
                temp_model = TraasAppTagDto()
                self.app_tags.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class PagequeryTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_name: str = None,
        host_ip: str = None,
        app_name: str = None,
        ip: str = None,
        hotsname: str = None,
        search: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        # 
        self.tenant_name = tenant_name
        # workspace_name
        self.workspace_name = workspace_name
        # host_ip
        self.host_ip = host_ip
        # app_name
        self.app_name = app_name
        # ip
        self.ip = ip
        # hotsname
        self.hotsname = hotsname
        # 是否是模糊搜索，默认为false
        self.search = search

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.current_page, 'current_page')
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.host_ip is not None:
            result['host_ip'] = self.host_ip
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.ip is not None:
            result['ip'] = self.ip
        if self.hotsname is not None:
            result['hotsname'] = self.hotsname
        if self.search is not None:
            result['search'] = self.search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('host_ip') is not None:
            self.host_ip = m.get('host_ip')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('hotsname') is not None:
            self.hotsname = m.get('hotsname')
        if m.get('search') is not None:
            self.search = m.get('search')
        return self


class PagequeryTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_servers: List[TraasAppServerDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_servers
        self.app_servers = app_servers
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.app_servers:
            for k in self.app_servers:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_servers'] = []
        if self.app_servers is not None:
            for k in self.app_servers:
                result['app_servers'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_servers = []
        if m.get('app_servers') is not None:
            for k in m.get('app_servers'):
                temp_model = TraasAppServerDto()
                self.app_servers.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class PagequeryTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        name: str = None,
        search: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        # 
        self.tenant_name = tenant_name
        # name
        self.name = name
        # 是否是模糊搜索，默认为false
        self.search = search

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.current_page, 'current_page')
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        return self


class PagequeryTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_groups: List[TraasAppGroupDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_groups
        self.app_groups = app_groups
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.app_groups:
            for k in self.app_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_groups'] = []
        if self.app_groups is not None:
            for k in self.app_groups:
                result['app_groups'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_groups = []
        if m.get('app_groups') is not None:
            for k in m.get('app_groups'):
                temp_model = TraasAppGroupDto()
                self.app_groups.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class PagequeryTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        search: bool = None,
        name: str = None,
        app_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        # 
        self.tenant_name = tenant_name
        # 是否是模糊搜索，默认为false
        self.search = search
        # name
        # 
        self.name = name
        # app_group_name
        self.app_group_name = app_group_name

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.current_page, 'current_page')
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.search is not None:
            result['search'] = self.search
        if self.name is not None:
            result['name'] = self.name
        if self.app_group_name is not None:
            result['app_group_name'] = self.app_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('app_group_name') is not None:
            self.app_group_name = m.get('app_group_name')
        return self


class PagequeryTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        apps: List[TraasAppDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # apps
        self.apps = apps
        # 每页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page
        # 
        # 总量
        self.total_count = total_count

    def validate(self):
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['apps'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.apps = []
        if m.get('apps') is not None:
            for k in m.get('apps'):
                temp_model = TraasAppDto()
                self.apps.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class QueryTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class QueryTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_groups: List[TraasWorkspaceGroupDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace_groups
        self.workspace_groups = workspace_groups

    def validate(self):
        if self.workspace_groups:
            for k in self.workspace_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspace_groups'] = []
        if self.workspace_groups is not None:
            for k in self.workspace_groups:
                result['workspace_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspace_groups = []
        if m.get('workspace_groups') is not None:
            for k in m.get('workspace_groups'):
                temp_model = TraasWorkspaceGroupDto()
                self.workspace_groups.append(temp_model.from_map(k))
        return self


class QueryTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class QueryTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspaces: List[TraasWorkspaceDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspaces
        self.workspaces = workspaces

    def validate(self):
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = TraasWorkspaceDto()
                self.workspaces.append(temp_model.from_map(k))
        return self


class QueryTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        app_name: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        tag_key: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # app_name
        self.app_name = app_name
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # tag_key
        self.tag_key = tag_key

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.tag_key is not None:
            result['tag_key'] = self.tag_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('tag_key') is not None:
            self.tag_key = m.get('tag_key')
        return self


class QueryTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_tags: List[TraasAppTagDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_tags
        self.app_tags = app_tags

    def validate(self):
        if self.app_tags:
            for k in self.app_tags:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_tags'] = []
        if self.app_tags is not None:
            for k in self.app_tags:
                result['app_tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_tags = []
        if m.get('app_tags') is not None:
            for k in m.get('app_tags'):
                temp_model = TraasAppTagDto()
                self.app_tags.append(temp_model.from_map(k))
        return self


class QueryTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        hostname: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_name: str = None,
        app_name: str = None,
        ip: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # hostname
        self.hostname = hostname
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_name
        self.workspace_name = workspace_name
        # app_name
        self.app_name = app_name
        # ip
        self.ip = ip

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.ip is not None:
            result['ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        return self


class QueryTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_servers: List[TraasAppServerDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_servers
        self.app_servers = app_servers

    def validate(self):
        if self.app_servers:
            for k in self.app_servers:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_servers'] = []
        if self.app_servers is not None:
            for k in self.app_servers:
                result['app_servers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_servers = []
        if m.get('app_servers') is not None:
            for k in m.get('app_servers'):
                temp_model = TraasAppServerDto()
                self.app_servers.append(temp_model.from_map(k))
        return self


class QueryTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class QueryTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_groups: List[TraasAppGroupDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_groups
        self.app_groups = app_groups

    def validate(self):
        if self.app_groups:
            for k in self.app_groups:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_groups'] = []
        if self.app_groups is not None:
            for k in self.app_groups:
                result['app_groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_groups = []
        if m.get('app_groups') is not None:
            for k in m.get('app_groups'):
                temp_model = TraasAppGroupDto()
                self.app_groups.append(temp_model.from_map(k))
        return self


class QueryTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class QueryTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        apps: List[TraasAppDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # apps
        self.apps = apps

    def validate(self):
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['apps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.apps = []
        if m.get('apps') is not None:
            for k in m.get('apps'):
                temp_model = TraasAppDto()
                self.apps.append(temp_model.from_map(k))
        return self


class UpdateTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class UpdateTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app: TraasAppDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app
        self.app = app

    def validate(self):
        if self.app:
            self.app.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app is not None:
            result['app'] = self.app.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app') is not None:
            temp_model = TraasAppDto()
            self.app = temp_model.from_map(m['app'])
        return self


class CreateTraasmetaAppRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class CreateTraasmetaAppResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app: TraasAppDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app
        self.app = app

    def validate(self):
        if self.app:
            self.app.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app is not None:
            result['app'] = self.app.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app') is not None:
            temp_model = TraasAppDto()
            self.app = temp_model.from_map(m['app'])
        return self


class UpdateTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class UpdateTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_group: TraasWorkspaceGroupDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # tenant_name
        self.workspace_group = workspace_group

    def validate(self):
        if self.workspace_group:
            self.workspace_group.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace_group') is not None:
            temp_model = TraasWorkspaceGroupDto()
            self.workspace_group = temp_model.from_map(m['workspace_group'])
        return self


class UpdateTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        parent_uuid: str = None,
        layer: int = None,
        outside_parent_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # parent_uuid
        self.parent_uuid = parent_uuid
        # layer
        self.layer = layer
        # outside_parent_id
        self.outside_parent_id = outside_parent_id

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.parent_uuid is not None:
            result['parent_uuid'] = self.parent_uuid
        if self.layer is not None:
            result['layer'] = self.layer
        if self.outside_parent_id is not None:
            result['outside_parent_id'] = self.outside_parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('parent_uuid') is not None:
            self.parent_uuid = m.get('parent_uuid')
        if m.get('layer') is not None:
            self.layer = m.get('layer')
        if m.get('outside_parent_id') is not None:
            self.outside_parent_id = m.get('outside_parent_id')
        return self


class UpdateTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_group: TraasAppGroupDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_group
        self.app_group = app_group

    def validate(self):
        if self.app_group:
            self.app_group.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_group is not None:
            result['app_group'] = self.app_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_group') is not None:
            temp_model = TraasAppGroupDto()
            self.app_group = temp_model.from_map(m['app_group'])
        return self


class CreateTraasmetaAppgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        parent_uuid: str = None,
        layer: int = None,
        outside_parent_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # parent_uuid
        self.parent_uuid = parent_uuid
        # layer
        self.layer = layer
        # outside_parent_id
        self.outside_parent_id = outside_parent_id

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.parent_uuid is not None:
            result['parent_uuid'] = self.parent_uuid
        if self.layer is not None:
            result['layer'] = self.layer
        if self.outside_parent_id is not None:
            result['outside_parent_id'] = self.outside_parent_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('parent_uuid') is not None:
            self.parent_uuid = m.get('parent_uuid')
        if m.get('layer') is not None:
            self.layer = m.get('layer')
        if m.get('outside_parent_id') is not None:
            self.outside_parent_id = m.get('outside_parent_id')
        return self


class CreateTraasmetaAppgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_group: TraasAppGroupDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_group
        self.app_group = app_group

    def validate(self):
        if self.app_group:
            self.app_group.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_group is not None:
            result['app_group'] = self.app_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_group') is not None:
            temp_model = TraasAppGroupDto()
            self.app_group = temp_model.from_map(m['app_group'])
        return self


class CreateTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_group_uuid: str = None,
        region_uuid: str = None,
        zone_uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_group_uuid
        self.workspace_group_uuid = workspace_group_uuid
        # region_uuid
        self.region_uuid = region_uuid
        # zone_uuid
        self.zone_uuid = zone_uuid

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_group_uuid is not None:
            result['workspace_group_uuid'] = self.workspace_group_uuid
        if self.region_uuid is not None:
            result['region_uuid'] = self.region_uuid
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_group_uuid') is not None:
            self.workspace_group_uuid = m.get('workspace_group_uuid')
        if m.get('region_uuid') is not None:
            self.region_uuid = m.get('region_uuid')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        return self


class CreateTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace: TraasWorkspaceDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zone_uuid
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace') is not None:
            temp_model = TraasWorkspaceDto()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class UpdateTraasmetaWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_group_uuid: str = None,
        region_uuid: str = None,
        zone_uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_group_uuid
        self.workspace_group_uuid = workspace_group_uuid
        # region_uuid
        self.region_uuid = region_uuid
        # zone_uuid
        self.zone_uuid = zone_uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_group_uuid is not None:
            result['workspace_group_uuid'] = self.workspace_group_uuid
        if self.region_uuid is not None:
            result['region_uuid'] = self.region_uuid
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_group_uuid') is not None:
            self.workspace_group_uuid = m.get('workspace_group_uuid')
        if m.get('region_uuid') is not None:
            self.region_uuid = m.get('region_uuid')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        return self


class UpdateTraasmetaWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace: TraasWorkspaceDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zone_uuid
        self.workspace = workspace

    def validate(self):
        if self.workspace:
            self.workspace.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace is not None:
            result['workspace'] = self.workspace.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace') is not None:
            temp_model = TraasWorkspaceDto()
            self.workspace = temp_model.from_map(m['workspace'])
        return self


class UpdateTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        tag_key: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        app_uuid: str = None,
        app_name: str = None,
        tag_value: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # tag_key
        self.tag_key = tag_key
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # app_uuid
        self.app_uuid = app_uuid
        # app_name
        self.app_name = app_name
        # tag_value
        self.tag_value = tag_value

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.tag_key is not None:
            result['tag_key'] = self.tag_key
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.app_uuid is not None:
            result['app_uuid'] = self.app_uuid
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.tag_value is not None:
            result['tag_value'] = self.tag_value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('tag_key') is not None:
            self.tag_key = m.get('tag_key')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('app_uuid') is not None:
            self.app_uuid = m.get('app_uuid')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('tag_value') is not None:
            self.tag_value = m.get('tag_value')
        return self


class UpdateTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_tag: TraasAppTagDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_tag
        self.app_tag = app_tag

    def validate(self):
        if self.app_tag:
            self.app_tag.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_tag is not None:
            result['app_tag'] = self.app_tag.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_tag') is not None:
            temp_model = TraasAppTagDto()
            self.app_tag = temp_model.from_map(m['app_tag'])
        return self


class CreateTraasmetaApptagRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        tag_key: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        tag_value: str = None,
        app_uuid: str = None,
        app_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # tag_key
        self.tag_key = tag_key
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # tag_value
        self.tag_value = tag_value
        # app_uuid
        self.app_uuid = app_uuid
        # app_name
        self.app_name = app_name

    def validate(self):
        self.validate_required(self.tag_key, 'tag_key')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.tag_key is not None:
            result['tag_key'] = self.tag_key
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.tag_value is not None:
            result['tag_value'] = self.tag_value
        if self.app_uuid is not None:
            result['app_uuid'] = self.app_uuid
        if self.app_name is not None:
            result['app_name'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('tag_key') is not None:
            self.tag_key = m.get('tag_key')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('tag_value') is not None:
            self.tag_value = m.get('tag_value')
        if m.get('app_uuid') is not None:
            self.app_uuid = m.get('app_uuid')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        return self


class CreateTraasmetaApptagResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_tag: TraasAppTagDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_tag
        self.app_tag = app_tag

    def validate(self):
        if self.app_tag:
            self.app_tag.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_tag is not None:
            result['app_tag'] = self.app_tag.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_tag') is not None:
            temp_model = TraasAppTagDto()
            self.app_tag = temp_model.from_map(m['app_tag'])
        return self


class CreateTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        hostname: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        ip: str = None,
        host_ip: str = None,
        collect_id: str = None,
        status: bool = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        cell_uuid: str = None,
        zone_uuid: str = None,
        app_uuid: str = None,
        app_name: str = None,
        app_service_uuid: str = None,
        vm_uuid: str = None,
        pod_uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # hostname
        self.hostname = hostname
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # ip
        self.ip = ip
        # host_ip
        self.host_ip = host_ip
        # collect_id
        self.collect_id = collect_id
        # status
        self.status = status
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # cell_uuid
        self.cell_uuid = cell_uuid
        # zone_uuid
        self.zone_uuid = zone_uuid
        # app_uuid
        self.app_uuid = app_uuid
        # app_name
        self.app_name = app_name
        # app_service_uuid
        self.app_service_uuid = app_service_uuid
        # vm_uuid
        self.vm_uuid = vm_uuid
        # pod_uuid
        self.pod_uuid = pod_uuid

    def validate(self):
        self.validate_required(self.hostname, 'hostname')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.ip is not None:
            result['ip'] = self.ip
        if self.host_ip is not None:
            result['host_ip'] = self.host_ip
        if self.collect_id is not None:
            result['collect_id'] = self.collect_id
        if self.status is not None:
            result['status'] = self.status
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.cell_uuid is not None:
            result['cell_uuid'] = self.cell_uuid
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.app_uuid is not None:
            result['app_uuid'] = self.app_uuid
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.app_service_uuid is not None:
            result['app_service_uuid'] = self.app_service_uuid
        if self.vm_uuid is not None:
            result['vm_uuid'] = self.vm_uuid
        if self.pod_uuid is not None:
            result['pod_uuid'] = self.pod_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('host_ip') is not None:
            self.host_ip = m.get('host_ip')
        if m.get('collect_id') is not None:
            self.collect_id = m.get('collect_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('cell_uuid') is not None:
            self.cell_uuid = m.get('cell_uuid')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('app_uuid') is not None:
            self.app_uuid = m.get('app_uuid')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('app_service_uuid') is not None:
            self.app_service_uuid = m.get('app_service_uuid')
        if m.get('vm_uuid') is not None:
            self.vm_uuid = m.get('vm_uuid')
        if m.get('pod_uuid') is not None:
            self.pod_uuid = m.get('pod_uuid')
        return self


class CreateTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_server: TraasAppServerDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_server
        self.app_server = app_server

    def validate(self):
        if self.app_server:
            self.app_server.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_server is not None:
            result['app_server'] = self.app_server.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_server') is not None:
            temp_model = TraasAppServerDto()
            self.app_server = temp_model.from_map(m['app_server'])
        return self


class UpdateTraasmetaAppserverRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        hostname: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        ip: str = None,
        host_ip: str = None,
        collect_id: str = None,
        status: bool = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        cell_uuid: str = None,
        zone_uuid: str = None,
        app_uuid: str = None,
        app_name: str = None,
        app_service_uuid: str = None,
        vm_uuid: str = None,
        pod_uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # hostname
        self.hostname = hostname
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # ip
        self.ip = ip
        # host_ip
        self.host_ip = host_ip
        # collect_id
        self.collect_id = collect_id
        # status
        self.status = status
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # cell_uuid
        self.cell_uuid = cell_uuid
        # zone_uuid
        self.zone_uuid = zone_uuid
        # app_uuid
        self.app_uuid = app_uuid
        # app_name
        self.app_name = app_name
        # app_service_uuid
        self.app_service_uuid = app_service_uuid
        # vm_uuid
        self.vm_uuid = vm_uuid
        # pod_uuid
        self.pod_uuid = pod_uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.ip is not None:
            result['ip'] = self.ip
        if self.host_ip is not None:
            result['host_ip'] = self.host_ip
        if self.collect_id is not None:
            result['collect_id'] = self.collect_id
        if self.status is not None:
            result['status'] = self.status
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.cell_uuid is not None:
            result['cell_uuid'] = self.cell_uuid
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.app_uuid is not None:
            result['app_uuid'] = self.app_uuid
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.app_service_uuid is not None:
            result['app_service_uuid'] = self.app_service_uuid
        if self.vm_uuid is not None:
            result['vm_uuid'] = self.vm_uuid
        if self.pod_uuid is not None:
            result['pod_uuid'] = self.pod_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('host_ip') is not None:
            self.host_ip = m.get('host_ip')
        if m.get('collect_id') is not None:
            self.collect_id = m.get('collect_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('cell_uuid') is not None:
            self.cell_uuid = m.get('cell_uuid')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('app_uuid') is not None:
            self.app_uuid = m.get('app_uuid')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('app_service_uuid') is not None:
            self.app_service_uuid = m.get('app_service_uuid')
        if m.get('vm_uuid') is not None:
            self.vm_uuid = m.get('vm_uuid')
        if m.get('pod_uuid') is not None:
            self.pod_uuid = m.get('pod_uuid')
        return self


class UpdateTraasmetaAppserverResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_server: TraasAppServerDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # app_server
        self.app_server = app_server

    def validate(self):
        if self.app_server:
            self.app_server.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_server is not None:
            result['app_server'] = self.app_server.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_server') is not None:
            temp_model = TraasAppServerDto()
            self.app_server = temp_model.from_map(m['app_server'])
        return self


class GetSetupModelRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间名称
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class GetSetupModelResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        beta_plugin: bool = None,
        show_biz_domain: bool = None,
        site_drms: List[SiteWithDrm] = None,
        tenant_use_ws_overview: bool = None,
        iaas_monitor: bool = None,
        app_stack: str = None,
        app_stack_entity: str = None,
        site_env: str = None,
        use_new_alarm_config: bool = None,
        goc_push_open: bool = None,
        adv_custom_pluin_open: bool = None,
        nav_auth: bool = None,
        un_focus_page_shut_fresh: bool = None,
        line_chart_incre_fresh: bool = None,
        show_ws: bool = None,
        show_tenant: bool = None,
        search_eagle_eye: bool = None,
        sys_metric_interval: str = None,
        uuid_with_workspace: bool = None,
        block_change: bool = None,
        biz_editors: List[str] = None,
        use_fiber_data_tenants: List[str] = None,
        platform_monitor_stack_names: List[str] = None,
        menu_config: MenuConfig = None,
        second_monitor_enable: bool = None,
        show_app_group: bool = None,
        disable_old_alarm: bool = None,
        front_datasource: str = None,
        front_dashboard: str = None,
        show_all_chart_type: str = None,
        show_import_replace: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 主站试点的产品是否打开
        self.beta_plugin = beta_plugin
        # showBizDomain
        self.show_biz_domain = show_biz_domain
        # drm 推送的地址列表, 如果为空，前端默认主站，如果不为空，按照配置来渲染
        self.site_drms = site_drms
        # 是不是租户总览用空间总览
        self.tenant_use_ws_overview = tenant_use_ws_overview
        # iaas监控开关
        self.iaas_monitor = iaas_monitor
        # 应用监控的技术栈
        self.app_stack = app_stack
        # 应用监控的技术栈实体
        self.app_stack_entity = app_stack_entity
        # 站点
        self.site_env = site_env
        # useNewAlarmConfig
        self.use_new_alarm_config = use_new_alarm_config
        # goc推送开关
        self.goc_push_open = goc_push_open
        # 是否打开高级产品配置，脚本、联合计算等
        self.adv_custom_pluin_open = adv_custom_pluin_open
        # 导航是否鉴权
        self.nav_auth = nav_auth
        # unFocusPageShutFresh
        self.un_focus_page_shut_fresh = un_focus_page_shut_fresh
        # lineChartIncreFresh
        self.line_chart_incre_fresh = line_chart_incre_fresh
        # ws开关
        self.show_ws = show_ws
        # Tenant开关
        self.show_tenant = show_tenant
        # searchEagleEye
        self.search_eagle_eye = search_eagle_eye
        # 系统指标默认显示的周期
        self.sys_metric_interval = sys_metric_interval
        # uuidWithWorkspace
        self.uuid_with_workspace = uuid_with_workspace
        # 封网变更标志
        self.block_change = block_change
        # bizEditors
        self.biz_editors = biz_editors
        # 数据接口还使用fiber接口的租户
        self.use_fiber_data_tenants = use_fiber_data_tenants
        # 平台运维技术栈（前端利用这个值来判断将哪些技术栈展示在平台运维版块）
        self.platform_monitor_stack_names = platform_monitor_stack_names
        # 菜单配置
        self.menu_config = menu_config
        # 是否开启秒级监控配置，默认关闭
        self.second_monitor_enable = second_monitor_enable
        # 是否允许前端显示应用分组
        self.show_app_group = show_app_group
        # 是否禁用老版告警
        self.disable_old_alarm = disable_old_alarm
        # frontDatasource
        self.front_datasource = front_datasource
        # frontDashboard
        self.front_dashboard = front_dashboard
        # showAllChartType
        self.show_all_chart_type = show_all_chart_type
        # showImportReplace
        self.show_import_replace = show_import_replace

    def validate(self):
        if self.site_drms:
            for k in self.site_drms:
                if k:
                    k.validate()
        if self.menu_config:
            self.menu_config.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.beta_plugin is not None:
            result['beta_plugin'] = self.beta_plugin
        if self.show_biz_domain is not None:
            result['show_biz_domain'] = self.show_biz_domain
        result['site_drms'] = []
        if self.site_drms is not None:
            for k in self.site_drms:
                result['site_drms'].append(k.to_map() if k else None)
        if self.tenant_use_ws_overview is not None:
            result['tenant_use_ws_overview'] = self.tenant_use_ws_overview
        if self.iaas_monitor is not None:
            result['iaas_monitor'] = self.iaas_monitor
        if self.app_stack is not None:
            result['app_stack'] = self.app_stack
        if self.app_stack_entity is not None:
            result['app_stack_entity'] = self.app_stack_entity
        if self.site_env is not None:
            result['site_env'] = self.site_env
        if self.use_new_alarm_config is not None:
            result['use_new_alarm_config'] = self.use_new_alarm_config
        if self.goc_push_open is not None:
            result['goc_push_open'] = self.goc_push_open
        if self.adv_custom_pluin_open is not None:
            result['adv_custom_pluin_open'] = self.adv_custom_pluin_open
        if self.nav_auth is not None:
            result['nav_auth'] = self.nav_auth
        if self.un_focus_page_shut_fresh is not None:
            result['un_focus_page_shut_fresh'] = self.un_focus_page_shut_fresh
        if self.line_chart_incre_fresh is not None:
            result['line_chart_incre_fresh'] = self.line_chart_incre_fresh
        if self.show_ws is not None:
            result['show_ws'] = self.show_ws
        if self.show_tenant is not None:
            result['show_tenant'] = self.show_tenant
        if self.search_eagle_eye is not None:
            result['search_eagle_eye'] = self.search_eagle_eye
        if self.sys_metric_interval is not None:
            result['sys_metric_interval'] = self.sys_metric_interval
        if self.uuid_with_workspace is not None:
            result['uuid_with_workspace'] = self.uuid_with_workspace
        if self.block_change is not None:
            result['block_change'] = self.block_change
        if self.biz_editors is not None:
            result['biz_editors'] = self.biz_editors
        if self.use_fiber_data_tenants is not None:
            result['use_fiber_data_tenants'] = self.use_fiber_data_tenants
        if self.platform_monitor_stack_names is not None:
            result['platform_monitor_stack_names'] = self.platform_monitor_stack_names
        if self.menu_config is not None:
            result['menu_config'] = self.menu_config.to_map()
        if self.second_monitor_enable is not None:
            result['second_monitor_enable'] = self.second_monitor_enable
        if self.show_app_group is not None:
            result['show_app_group'] = self.show_app_group
        if self.disable_old_alarm is not None:
            result['disable_old_alarm'] = self.disable_old_alarm
        if self.front_datasource is not None:
            result['front_datasource'] = self.front_datasource
        if self.front_dashboard is not None:
            result['front_dashboard'] = self.front_dashboard
        if self.show_all_chart_type is not None:
            result['show_all_chart_type'] = self.show_all_chart_type
        if self.show_import_replace is not None:
            result['show_import_replace'] = self.show_import_replace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('beta_plugin') is not None:
            self.beta_plugin = m.get('beta_plugin')
        if m.get('show_biz_domain') is not None:
            self.show_biz_domain = m.get('show_biz_domain')
        self.site_drms = []
        if m.get('site_drms') is not None:
            for k in m.get('site_drms'):
                temp_model = SiteWithDrm()
                self.site_drms.append(temp_model.from_map(k))
        if m.get('tenant_use_ws_overview') is not None:
            self.tenant_use_ws_overview = m.get('tenant_use_ws_overview')
        if m.get('iaas_monitor') is not None:
            self.iaas_monitor = m.get('iaas_monitor')
        if m.get('app_stack') is not None:
            self.app_stack = m.get('app_stack')
        if m.get('app_stack_entity') is not None:
            self.app_stack_entity = m.get('app_stack_entity')
        if m.get('site_env') is not None:
            self.site_env = m.get('site_env')
        if m.get('use_new_alarm_config') is not None:
            self.use_new_alarm_config = m.get('use_new_alarm_config')
        if m.get('goc_push_open') is not None:
            self.goc_push_open = m.get('goc_push_open')
        if m.get('adv_custom_pluin_open') is not None:
            self.adv_custom_pluin_open = m.get('adv_custom_pluin_open')
        if m.get('nav_auth') is not None:
            self.nav_auth = m.get('nav_auth')
        if m.get('un_focus_page_shut_fresh') is not None:
            self.un_focus_page_shut_fresh = m.get('un_focus_page_shut_fresh')
        if m.get('line_chart_incre_fresh') is not None:
            self.line_chart_incre_fresh = m.get('line_chart_incre_fresh')
        if m.get('show_ws') is not None:
            self.show_ws = m.get('show_ws')
        if m.get('show_tenant') is not None:
            self.show_tenant = m.get('show_tenant')
        if m.get('search_eagle_eye') is not None:
            self.search_eagle_eye = m.get('search_eagle_eye')
        if m.get('sys_metric_interval') is not None:
            self.sys_metric_interval = m.get('sys_metric_interval')
        if m.get('uuid_with_workspace') is not None:
            self.uuid_with_workspace = m.get('uuid_with_workspace')
        if m.get('block_change') is not None:
            self.block_change = m.get('block_change')
        if m.get('biz_editors') is not None:
            self.biz_editors = m.get('biz_editors')
        if m.get('use_fiber_data_tenants') is not None:
            self.use_fiber_data_tenants = m.get('use_fiber_data_tenants')
        if m.get('platform_monitor_stack_names') is not None:
            self.platform_monitor_stack_names = m.get('platform_monitor_stack_names')
        if m.get('menu_config') is not None:
            temp_model = MenuConfig()
            self.menu_config = temp_model.from_map(m['menu_config'])
        if m.get('second_monitor_enable') is not None:
            self.second_monitor_enable = m.get('second_monitor_enable')
        if m.get('show_app_group') is not None:
            self.show_app_group = m.get('show_app_group')
        if m.get('disable_old_alarm') is not None:
            self.disable_old_alarm = m.get('disable_old_alarm')
        if m.get('front_datasource') is not None:
            self.front_datasource = m.get('front_datasource')
        if m.get('front_dashboard') is not None:
            self.front_dashboard = m.get('front_dashboard')
        if m.get('show_all_chart_type') is not None:
            self.show_all_chart_type = m.get('show_all_chart_type')
        if m.get('show_import_replace') is not None:
            self.show_import_replace = m.get('show_import_replace')
        return self


class CreateTraasmetaWorkspacegroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class CreateTraasmetaWorkspacegroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_group: TraasWorkspaceGroupDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # workspace_group
        self.workspace_group = workspace_group

    def validate(self):
        if self.workspace_group:
            self.workspace_group.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace_group') is not None:
            temp_model = TraasWorkspaceGroupDto()
            self.workspace_group = temp_model.from_map(m['workspace_group'])
        return self


class GetTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        workspace_name: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # workspace_name
        self.workspace_name = workspace_name
        # name
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell: TraasCellDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cell
        self.cell = cell

    def validate(self):
        if self.cell:
            self.cell.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cell is not None:
            result['cell'] = self.cell.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cell') is not None:
            temp_model = TraasCellDto()
            self.cell = temp_model.from_map(m['cell'])
        return self


class PagequeryTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        name: str = None,
        workspace_name: str = None,
        workspace_uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # page_size
        self.page_size = page_size
        # current_page
        self.current_page = current_page
        # cell name
        self.name = name
        # workspace name
        self.workspace_name = workspace_name
        # workspace uuid
        self.workspace_uuid = workspace_uuid

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.current_page, 'current_page')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        return self


class PagequeryTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cells: List[TraasCellDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cells
        self.cells = cells
        # page size
        self.page_size = page_size
        # current page
        self.current_page = current_page
        # total count
        self.total_count = total_count

    def validate(self):
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = TraasCellDto()
                self.cells.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class GetTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        workspace_name: str = None,
        ip: str = None,
        workspace_uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # workspace_name
        self.workspace_name = workspace_name
        # ip
        self.ip = ip
        # workspace_uuid
        self.workspace_uuid = workspace_uuid

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.ip is not None:
            result['ip'] = self.ip
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        return self


class GetTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        host_machine: TraasHostMachineDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # host_machine
        self.host_machine = host_machine

    def validate(self):
        if self.host_machine:
            self.host_machine.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.host_machine is not None:
            result['host_machine'] = self.host_machine.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('host_machine') is not None:
            temp_model = TraasHostMachineDto()
            self.host_machine = temp_model.from_map(m['host_machine'])
        return self


class PagequeryTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_size: int = None,
        current_page: int = None,
        workspace_name: str = None,
        workspace_uuid: str = None,
        hostname: str = None,
        ip: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # page_size
        self.page_size = page_size
        # currentPage
        self.current_page = current_page
        # workspace_name
        self.workspace_name = workspace_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # hostname
        self.hostname = hostname
        # ip
        self.ip = ip

    def validate(self):
        self.validate_required(self.page_size, 'page_size')
        self.validate_required(self.current_page, 'current_page')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.ip is not None:
            result['ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        return self


class PagequeryTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        host_machines: List[TraasHostMachineDto] = None,
        page_size: int = None,
        current_page: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # host_machines
        self.host_machines = host_machines
        # page_size
        self.page_size = page_size
        # current_page
        self.current_page = current_page
        # total_count
        self.total_count = total_count

    def validate(self):
        if self.host_machines:
            for k in self.host_machines:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['host_machines'] = []
        if self.host_machines is not None:
            for k in self.host_machines:
                result['host_machines'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.host_machines = []
        if m.get('host_machines') is not None:
            for k in m.get('host_machines'):
                temp_model = TraasHostMachineDto()
                self.host_machines.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class QueryTraceDetailtopologyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        trace_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # trace_id
        self.trace_id = trace_id

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.trace_id, 'trace_id')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.trace_id is not None:
            result['trace_id'] = self.trace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('trace_id') is not None:
            self.trace_id = m.get('trace_id')
        return self


class QueryTraceDetailtopologyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        items: List[TraceDetailTopologyItem] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 拓扑节点
        self.items = items

    def validate(self):
        if self.items:
            for k in self.items:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['items'] = []
        if self.items is not None:
            for k in self.items:
                result['items'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.items = []
        if m.get('items') is not None:
            for k in m.get('items'):
                temp_model = TraceDetailTopologyItem()
                self.items.append(temp_model.from_map(k))
        return self


class SaveTenantconfigSpiRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        entity_name: str = None,
        end_point: str = None,
        field_naming_strategy: str = None,
        cloud_vendor_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # configKey参数名称
        self.entity_name = entity_name
        # end_point
        self.end_point = end_point
        # 默认为CamelCase
        self.field_naming_strategy = field_naming_strategy
        # 云厂商类型
        self.cloud_vendor_type = cloud_vendor_type

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.entity_name, 'entity_name')
        self.validate_required(self.end_point, 'end_point')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        if self.end_point is not None:
            result['end_point'] = self.end_point
        if self.field_naming_strategy is not None:
            result['field_naming_strategy'] = self.field_naming_strategy
        if self.cloud_vendor_type is not None:
            result['cloud_vendor_type'] = self.cloud_vendor_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        if m.get('end_point') is not None:
            self.end_point = m.get('end_point')
        if m.get('field_naming_strategy') is not None:
            self.field_naming_strategy = m.get('field_naming_strategy')
        if m.get('cloud_vendor_type') is not None:
            self.cloud_vendor_type = m.get('cloud_vendor_type')
        return self


class SaveTenantconfigSpiResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryTenantconfigSpiRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        entity_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 模块名称
        self.entity_name = entity_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.entity_name, 'entity_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        return self


class QueryTenantconfigSpiResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        entity_name: str = None,
        config_value: SpiConfig = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # entity_name
        self.entity_name = entity_name
        # spi_config
        self.config_value = config_value

    def validate(self):
        if self.config_value:
            self.config_value.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        if self.config_value is not None:
            result['config_value'] = self.config_value.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        if m.get('config_value') is not None:
            temp_model = SpiConfig()
            self.config_value = temp_model.from_map(m['config_value'])
        return self


class ListOneconsoleWorkspaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class ListOneconsoleWorkspaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[OneConsoleRegion] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # data
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = OneConsoleRegion()
                self.data.append(temp_model.from_map(k))
        return self


class DeleteTenantconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        entity_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # 模块名称
        self.entity_name = entity_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.entity_name, 'entity_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        return self


class DeleteTenantconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryTenantconfigTokenRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        entity_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # configKey对应值
        self.entity_name = entity_name

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.entity_name, 'entity_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        return self


class QueryTenantconfigTokenResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        config_value: TokenConfig = None,
        entity_name: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # token_config
        self.config_value = config_value
        # entity_name
        self.entity_name = entity_name

    def validate(self):
        if self.config_value:
            self.config_value.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.config_value is not None:
            result['config_value'] = self.config_value.to_map()
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('config_value') is not None:
            temp_model = TokenConfig()
            self.config_value = temp_model.from_map(m['config_value'])
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        return self


class SaveTenantconfigTokenRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_name: str = None,
        entity_name: str = None,
        token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间
        self.workspace_name = workspace_name
        # configKey对应值
        self.entity_name = entity_name
        # token值
        self.token = token

    def validate(self):
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.entity_name, 'entity_name')
        self.validate_required(self.token, 'token')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        if self.token is not None:
            result['token'] = self.token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        if m.get('token') is not None:
            self.token = m.get('token')
        return self


class SaveTenantconfigTokenResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryTraasmetaEntityRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        entity_name: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # entity_name
        self.entity_name = entity_name
        # 工作空间名称
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.entity_name, 'entity_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryTraasmetaEntityResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        name: str = None,
        display_name: str = None,
        group_name: str = None,
        group_display_name: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 实体名称
        self.name = name
        # 展示名称
        self.display_name = display_name
        # 实体所属分组名称
        self.group_name = group_name
        # 实例所属分组展示名称
        self.group_display_name = group_display_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.group_name is not None:
            result['group_name'] = self.group_name
        if self.group_display_name is not None:
            result['group_display_name'] = self.group_display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('group_name') is not None:
            self.group_name = m.get('group_name')
        if m.get('group_display_name') is not None:
            self.group_display_name = m.get('group_display_name')
        return self


class ListTraasmetaEntityfieldRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        entity_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 实体名称
        self.entity_name = entity_name

    def validate(self):
        self.validate_required(self.entity_name, 'entity_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        return self


class ListTraasmetaEntityfieldResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        fields: List[TraasEntityFieldDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # fields
        self.fields = fields

    def validate(self):
        if self.fields:
            for k in self.fields:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['fields'] = []
        if self.fields is not None:
            for k in self.fields:
                result['fields'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.fields = []
        if m.get('fields') is not None:
            for k in m.get('fields'):
                temp_model = TraasEntityFieldDto()
                self.fields.append(temp_model.from_map(k))
        return self


class QueryTraasmetaEntitytopoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        entity_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # entity_name
        self.entity_name = entity_name

    def validate(self):
        self.validate_required(self.entity_name, 'entity_name')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.entity_name is not None:
            result['entity_name'] = self.entity_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('entity_name') is not None:
            self.entity_name = m.get('entity_name')
        return self


class QueryTraasmetaEntitytopoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        edges: List[TraasEntityTopoEdge] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # edges
        self.edges = edges

    def validate(self):
        if self.edges:
            for k in self.edges:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['edges'] = []
        if self.edges is not None:
            for k in self.edges:
                result['edges'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.edges = []
        if m.get('edges') is not None:
            for k in m.get('edges'):
                temp_model = TraasEntityTopoEdge()
                self.edges.append(temp_model.from_map(k))
        return self


class AllTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        hosts: List[TraasHostMachineDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # hosts
        self.hosts = hosts

    def validate(self):
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['hosts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.hosts = []
        if m.get('hosts') is not None:
            for k in m.get('hosts'):
                temp_model = TraasHostMachineDto()
                self.hosts.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        hosts: List[TraasHostMachineDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # hosts
        self.hosts = hosts

    def validate(self):
        self.validate_required(self.hosts, 'hosts')
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['hosts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.hosts = []
        if m.get('hosts') is not None:
            for k in m.get('hosts'):
                temp_model = TraasHostMachineDto()
                self.hosts.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        hosts: List[TraasHostMachineDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # hosts
        self.hosts = hosts

    def validate(self):
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['hosts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.hosts = []
        if m.get('hosts') is not None:
            for k in m.get('hosts'):
                temp_model = TraasHostMachineDto()
                self.hosts.append(temp_model.from_map(k))
        return self


class BatchdeleteTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchqueryTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        ips: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # ips
        self.ips = ips
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.ips is not None:
            result['ips'] = self.ips
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('ips') is not None:
            self.ips = m.get('ips')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class BatchqueryTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        hosts: List[TraasHostMachineDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # hosts
        self.hosts = hosts

    def validate(self):
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['hosts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.hosts = []
        if m.get('hosts') is not None:
            for k in m.get('hosts'):
                temp_model = TraasHostMachineDto()
                self.hosts.append(temp_model.from_map(k))
        return self


class CreateTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        hostname: str = None,
        ip: str = None,
        collect_id: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        zone_uuid: str = None,
        zone_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # hostname
        self.hostname = hostname
        # ip
        self.ip = ip
        # collect_id
        self.collect_id = collect_id
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # zone_uuid
        self.zone_uuid = zone_uuid
        # zone_name
        self.zone_name = zone_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension

    def validate(self):
        self.validate_required(self.hostname, 'hostname')
        self.validate_required(self.ip, 'ip')
        self.validate_required(self.collect_id, 'collect_id')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.ip is not None:
            result['ip'] = self.ip
        if self.collect_id is not None:
            result['collect_id'] = self.collect_id
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('collect_id') is not None:
            self.collect_id = m.get('collect_id')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        return self


class CreateTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        host: TraasHostMachineDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # host
        self.host = host

    def validate(self):
        if self.host:
            self.host.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.host is not None:
            result['host'] = self.host.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('host') is not None:
            temp_model = TraasHostMachineDto()
            self.host = temp_model.from_map(m['host'])
        return self


class DeleteTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        ip: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # ip
        self.ip = ip
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.ip is not None:
            result['ip'] = self.ip
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        hosts: List[TraasHostMachineDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # hosts
        self.hosts = hosts

    def validate(self):
        if self.hosts:
            for k in self.hosts:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['hosts'] = []
        if self.hosts is not None:
            for k in self.hosts:
                result['hosts'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.hosts = []
        if m.get('hosts') is not None:
            for k in m.get('hosts'):
                temp_model = TraasHostMachineDto()
                self.hosts.append(temp_model.from_map(k))
        return self


class UpdateTraasmetaHostmachineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        hostname: str = None,
        collect_id: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        zone_uuid: str = None,
        zone_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
        ip: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # hostname
        self.hostname = hostname
        # collect_id
        self.collect_id = collect_id
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # zone_uuid
        self.zone_uuid = zone_uuid
        # zone_name
        self.zone_name = zone_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension
        # ip
        self.ip = ip

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.collect_id is not None:
            result['collect_id'] = self.collect_id
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        if self.ip is not None:
            result['ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('collect_id') is not None:
            self.collect_id = m.get('collect_id')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        return self


class UpdateTraasmetaHostmachineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        host: TraasHostMachineDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # host
        self.host = host

    def validate(self):
        if self.host:
            self.host.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.host is not None:
            result['host'] = self.host.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('host') is not None:
            temp_model = TraasHostMachineDto()
            self.host = temp_model.from_map(m['host'])
        return self


class BatchcreateTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cells: List[TraasCellDto] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cells
        self.cells = cells

    def validate(self):
        self.validate_required(self.cells, 'cells')
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = TraasCellDto()
                self.cells.append(temp_model.from_map(k))
        return self


class BatchcreateTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cells: List[TraasCellDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cells
        self.cells = cells

    def validate(self):
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = TraasCellDto()
                self.cells.append(temp_model.from_map(k))
        return self


class BatchdeleteTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids

    def validate(self):
        self.validate_required(self.uuids, 'uuids')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        return self


class BatchdeleteTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchqueryTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuids: List[str] = None,
        names: List[str] = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuids
        self.uuids = uuids
        # names
        self.names = names
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuids is not None:
            result['uuids'] = self.uuids
        if self.names is not None:
            result['names'] = self.names
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuids') is not None:
            self.uuids = m.get('uuids')
        if m.get('names') is not None:
            self.names = m.get('names')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class BatchqueryTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cells: List[TraasCellDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cells
        self.cells = cells

    def validate(self):
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = TraasCellDto()
                self.cells.append(temp_model.from_map(k))
        return self


class UpdateTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        display_name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        zone_uuid: str = None,
        zone_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # zone_uuid
        self.zone_uuid = zone_uuid
        # zone_name
        self.zone_name = zone_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        return self


class UpdateTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell: TraasCellDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cell
        self.cell = cell

    def validate(self):
        if self.cell:
            self.cell.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cell is not None:
            result['cell'] = self.cell.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cell') is not None:
            temp_model = TraasCellDto()
            self.cell = temp_model.from_map(m['cell'])
        return self


class CreateTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
        zone_uuid: str = None,
        zone_name: str = None,
        outside_id: str = None,
        source_from: str = None,
        extension: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # name
        self.name = name
        # display_name
        self.display_name = display_name
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name
        # zone_uuid
        self.zone_uuid = zone_uuid
        # zone_name
        self.zone_name = zone_name
        # outside_id
        self.outside_id = outside_id
        # source_from
        self.source_from = source_from
        # extension
        self.extension = extension

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.source_from, 'source_from')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.zone_uuid is not None:
            result['zone_uuid'] = self.zone_uuid
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        if self.outside_id is not None:
            result['outside_id'] = self.outside_id
        if self.source_from is not None:
            result['source_from'] = self.source_from
        if self.extension is not None:
            result['extension'] = self.extension
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('zone_uuid') is not None:
            self.zone_uuid = m.get('zone_uuid')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        if m.get('outside_id') is not None:
            self.outside_id = m.get('outside_id')
        if m.get('source_from') is not None:
            self.source_from = m.get('source_from')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        return self


class CreateTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell: TraasCellDto = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cell
        self.cell = cell

    def validate(self):
        if self.cell:
            self.cell.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cell is not None:
            result['cell'] = self.cell.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cell') is not None:
            temp_model = TraasCellDto()
            self.cell = temp_model.from_map(m['cell'])
        return self


class DeleteTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid

    def validate(self):
        self.validate_required(self.uuid, 'uuid')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        return self


class DeleteTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class AllTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class AllTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cells: List[TraasCellDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cells
        self.cells = cells

    def validate(self):
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = TraasCellDto()
                self.cells.append(temp_model.from_map(k))
        return self


class QueryTraasmetaCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        uuid: str = None,
        name: str = None,
        search: bool = None,
        tenant_uuid: str = None,
        tenant_name: str = None,
        workspace_uuid: str = None,
        workspace_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # uuid
        self.uuid = uuid
        # name
        self.name = name
        # 
        # 是否是模糊搜索，默认为false
        self.search = search
        # tenant_uuid
        self.tenant_uuid = tenant_uuid
        # tenant_name
        self.tenant_name = tenant_name
        # workspace_uuid
        self.workspace_uuid = workspace_uuid
        # workspace_name
        self.workspace_name = workspace_name

    def validate(self):
        self.validate_required(self.search, 'search')

    def to_map(self):
        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.uuid is not None:
            result['uuid'] = self.uuid
        if self.name is not None:
            result['name'] = self.name
        if self.search is not None:
            result['search'] = self.search
        if self.tenant_uuid is not None:
            result['tenant_uuid'] = self.tenant_uuid
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_uuid is not None:
            result['workspace_uuid'] = self.workspace_uuid
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('uuid') is not None:
            self.uuid = m.get('uuid')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('search') is not None:
            self.search = m.get('search')
        if m.get('tenant_uuid') is not None:
            self.tenant_uuid = m.get('tenant_uuid')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_uuid') is not None:
            self.workspace_uuid = m.get('workspace_uuid')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        return self


class QueryTraasmetaCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cells: List[TraasCellDto] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cells
        self.cells = cells

    def validate(self):
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()

    def to_map(self):
        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = TraasCellDto()
                self.cells.append(temp_model.from_map(k))
        return self


