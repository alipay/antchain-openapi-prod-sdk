import AntchainUtil;
import Util;
import RPCUtil;

type @endpoint = string
type @regionId = string
type @accessKeyId = string
type @accessKeySecret = string
type @protocol = string
type @userAgent = string
type @readTimeout = number
type @connectTimeout = number
type @httpProxy = string
type @httpsProxy = string
type @socks5Proxy = string
type @socks5NetWork = string
type @noProxy = string
type @maxIdleConns = number
type @securityToken = string
type @maxIdleTimeMillis = number
type @keepAliveDurationMillis = number
type @maxRequests = number
type @maxRequestsPerHost = number

/**
 * Model for initing client
 */
model Config {
  accessKeyId?: string(description='accesskey id',default=''),
  accessKeySecret?: string(description='accesskey secret',default=''),
  securityToken?: string(description='security token',default=''),
  protocol?: string(description='http protocol',example='http',default='http'),
  readTimeout?: number(description='read timeout',example='10',default=''),
  connectTimeout?: number(description='connect timeout',example='10',default=''),
  httpProxy?: string(description='http proxy',example='http://localhost',default=''),
  httpsProxy?: string(description='https proxy',example='https://localhost',default=''),
  endpoint?: string(description='endpoint',example='cs.aliyuncs.com',default=''),
  noProxy?: string(description='proxy white list',example='http://localhost',default=''),
  maxIdleConns?: number(description='max idle conns',example='3',default=''),
  userAgent?: string(description='user agent',example='Alibabacloud/1',default=''),
  socks5Proxy?: string(description='socks5 proxy',default=''),
  socks5NetWork?: string(description='socks5 network',example='TCP',default=''),
  maxIdleTimeMillis?: number(description='长链接最大空闲时长',default='60 * 1000L'),
  keepAliveDurationMillis?: number(description='长链接最大连接时长',default='5000'),
  maxRequests?: number(description='最大连接数（长链接最大总数）',default='100'),
  maxRequestsPerHost?: number(description='每个目标主机的最大连接数（分主机域名的长链接最大总数',default='100'),
}

/**
 * Init client with Config
 * @param config config contains the necessary information to create a client
 */
init(config: Config) {
  if (Util.isUnset(config)) {
    throw {
      code = 'ParameterMissing',
      message = '\'config\' can not be unset'
    };
  }

  @accessKeyId = config.accessKeyId;
  @accessKeySecret = config.accessKeySecret;
  @securityToken = config.securityToken;
  @endpoint = config.endpoint;
  @protocol = config.protocol;
  @userAgent = config.userAgent;
  @readTimeout = Util.defaultNumber(config.readTimeout, 20000);
  @connectTimeout = Util.defaultNumber(config.connectTimeout, 20000);
  @httpProxy = config.httpProxy;
  @httpsProxy = config.httpsProxy;
  @noProxy = config.noProxy;
  @socks5Proxy = config.socks5Proxy;
  @socks5NetWork = config.socks5NetWork;
  @maxIdleConns = Util.defaultNumber(config.maxIdleConns, 60000);
  @maxIdleTimeMillis = Util.defaultNumber(config.maxIdleTimeMillis, 5);
  @keepAliveDurationMillis = Util.defaultNumber(config.keepAliveDurationMillis, 5000);
  @maxRequests = Util.defaultNumber(config.maxRequests, 100);
  @maxRequestsPerHost = Util.defaultNumber(config.maxRequestsPerHost, 100);
}

/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param protocol http or https
 * @param method e.g. GET
 * @param pathname pathname of every api
 * @param request which contains request params
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doRequest(version: string, action: string, protocol: string, method: string, pathname: string, request: object, headers: map[string]string, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = pathname;
  __request.query = {
    method = action,
    version = version,
    sign_type = 'HmacSHA1',
    req_time = AntchainUtil.getTimestamp(),
    req_msg_id = AntchainUtil.getNonce(),
    access_key = @accessKeyId,
    base_sdk_version = 'TeaSDK-2.0',
    sdk_version = '1.0.7',
    _prod_code = 'WEBTTS',
    _prod_channel = 'default'
  };

  if (!Util.empty(@securityToken)) {
    __request.query.security_token = @securityToken;
  }

  __request.headers = {
    host = Util.defaultString(@endpoint, 'openapi.antchain.antgroup.com'),
    user-agent = Util.getUserAgent(@userAgent),
    ...headers
  };

  var tmp = Util.anyifyMapValue(RPCUtil.query(request));
  __request.body = Util.toFormString(tmp);
  __request.headers.content-type = 'application/x-www-form-urlencoded';

  var signedParam = {
    ...__request.query,
    ...RPCUtil.query(request)
  };
  __request.query.sign = AntchainUtil.getSignature(signedParam, @accessKeySecret);
} returns {
  var raw = Util.readAsString(__response.body);
  var obj = Util.parseJSON(raw);
  var res = Util.assertAsMap(obj);
  var resp = Util.assertAsMap(res.response);

  if (AntchainUtil.hasError(raw, @accessKeySecret)) {
    throw {
      message = resp.result_msg,
      data = resp,
      code = resp.result_code
    };
  }
  return resp;
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  maxIdleTimeMillis = @maxIdleTimeMillis,
  keepAliveDuration = @keepAliveDurationMillis,
  maxRequests = @maxRequests,
  maxRequestsPerHost = @maxRequestsPerHost,
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL
}

// 区块链response
model QueryBlockchainResponse {
  // 链名称
  blockchain: string(name='blockchain', example='Ethereum'),
  // 链类型
  chainType: string(name='chain_type', example='EVM'),
}

// WithdrawalOrderDetail
// 
model WithdrawalOrderDetail {
  // withdrawalAmount
  withdrawalAmount: string(name='withdrawal_amount', example='1.00'),
}

// 查询白名单详细信息响应体
model QueryWhitelistAddressResponse {
  // 白名单地址
  whitelistAddress: string(name='whitelist_address', example='0xf5be944e4829aa055957e45bdf1b41175744f0a2'),
  // 区块链列表信息
  blockchainList: [ QueryBlockchainResponse ](name='blockchain_list', example='[]'),
}

// 币种response
model QueryTokenSymbolResponse {
  // 链名称
  blockchain: string(name='blockchain', example='Ethereum'),
  // 币种
  tokenSymbol: string(name='token_symbol', example='USDC'),
}

// 查询deposit订单响应体
model QueryDepositOrderInfoResponse {
  // 订单id
  orderId: string(name='order_id', example='202512301338236627142T870720'),
  // 订单类型
  orderType: string(name='order_type', example='DEPOSIT'),
  // 区块链名称
  blockchain: string(name='blockchain', example='Ethereum'),
  // 代币名称
  tokenSymbol: string(name='token_symbol', example='USDC'),
  // deposit数量
  amount: string(name='amount', example='100.001'),
  // deposit交易hash
  txHash: string(name='tx_hash', example='0xa95311ca68c47ceac58cfa63581ffe60d492e6daa5b1726758103cdc52e85095'),
  // 交易发起地址，为白名单地址
  fromAddress: string(name='from_address', example='0xf5be944e4829aa055957e45bdf1b41175744f0a2'),
  // 交易接收地址，为托管钱包地址
  toAddress: string(name='to_address', example='0xf5be944e4829aa055957e45bdf1b41175744f0a2'),
  // 订单创建时间
  createTime: string(pattern='\\\\d{4}[-]\\\\d{1,2}[-]\\\\d{1,2}[T]\\\\d{2}:\\\\d{2}:\\\\d{2}([Z]|([\\\\.]\\\\d{1,9})?[\\\\+]\\\\d{2}[\\\\:]?\\\\d{2})', name='create_time', example='2018-10-10T10:10:00Z'),
  // 订单状态
  orderStatus: string(name='order_status', example='SUCCESS'),
  // 订单备注
  remark: string(name='remark', example='test'),
}

// WithdrawalOrderDTO
model WithdrawalOrderDTO {
  // orderId
  orderId: string(name='order_id', example='2011'),
  // orderDesc
  orderDesc: string(name='order_desc', example='order description test'),
  // orderType
  orderType: string(name='order_type', example='WITHDRAWAL'),
  // orderStatus:INIT PENDING_CONFIRMATION PENDING_DEPOSIT RUNNING SUCCESS FAILED EXPIRED_CLOSED REFUND REJECTED
  orderStatus: string(name='order_status', example='PENDING'),
  // withdrawal Amount
  withdrawalAmount: string(name='withdrawal_amount', example='1.01'),
}

model WithdrawDacVaultRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // customerId of The DAC System
  externalCustomerId: string(name='external_customer_id'),
  // blockchain:Ethereum Ploygen
  blockchain: string(name='blockchain'),
  // Token Token Token identification
  tokenSymbol: string(name='token_symbol'),
  // withdrawal token amount
  withdrawalAmount: string(name='withdrawal_amount'),
  // description of requisition and withdrawal application
  withdrawTokenDesc?: string(name='withdraw_token_desc'),
  // the address on the wallet chain of the user_s money withdrawal.
  withdrawalWhitelistAddress: string(name='withdrawal_whitelist_address'),
}

model WithdrawDacVaultResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // withdrawal order detail
  withdrawalOrderDetail?: WithdrawalOrderDetail(name='withdrawal_order_detail'),
}

/**
 * Description: Withdraw Token
 * Summary: Withdraw Token
 */
async function withdrawDacVault(request: WithdrawDacVaultRequest): WithdrawDacVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return withdrawDacVaultEx(request, headers, runtime);
}

/**
 * Description: Withdraw Token
 * Summary: Withdraw Token
 */
async function withdrawDacVaultEx(request: WithdrawDacVaultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): WithdrawDacVaultResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.vault.withdraw', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model OpenActivateRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 地址
  address: string(name='address'),
  // 外部客户id
  externalCustomerId: string(name='external_customer_id'),
  // 客户性别
  sex: string(name='sex'),
  // 用户名
  username: string(name='username'),
  // 出生日期
  birthDate: long(name='birth_date'),
}

model OpenActivateResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 表单id
  applyFormId?: string(name='apply_form_id'),
}

/**
 * Description: 开通托管服务
 * Summary: 开通托管服务
 */
async function openActivate(request: OpenActivateRequest): OpenActivateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return openActivateEx(request, headers, runtime);
}

/**
 * Description: 开通托管服务
 * Summary: 开通托管服务
 */
async function openActivateEx(request: OpenActivateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): OpenActivateResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.activate.open', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model StopActivateRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 外部客户id
  externalCustomerId: string(name='external_customer_id'),
  // 备注
  remark: string(name='remark'),
}

model StopActivateResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 表单id
  applyFormId?: string(name='apply_form_id'),
}

/**
 * Description: 关闭托管服务
 * Summary: 关闭托管服务
 */
async function stopActivate(request: StopActivateRequest): StopActivateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return stopActivateEx(request, headers, runtime);
}

/**
 * Description: 关闭托管服务
 * Summary: 关闭托管服务
 */
async function stopActivateEx(request: StopActivateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopActivateResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.activate.stop', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model PagequeryDacBlockchainRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 当前页
  current: long(name='current'),
  // 每页大小
  pageSize: long(name='page_size'),
}

model PagequeryDacBlockchainResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 当前页
  current?: string(name='current'),
  // 每页大小
  pageSize?: string(name='page_size'),
  // 总数
  total?: long(name='total'),
  // 链信息
  list?: [ QueryBlockchainResponse ](name='list'),
}

/**
 * Description: 分页查询支持的区块链
 * Summary: 分页查询支持的区块链
 */
async function pagequeryDacBlockchain(request: PagequeryDacBlockchainRequest): PagequeryDacBlockchainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return pagequeryDacBlockchainEx(request, headers, runtime);
}

/**
 * Description: 分页查询支持的区块链
 * Summary: 分页查询支持的区块链
 */
async function pagequeryDacBlockchainEx(request: PagequeryDacBlockchainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PagequeryDacBlockchainResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.blockchain.pagequery', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model PagequeryDacTokenRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 当前页
  current: long(name='current'),
  // 每页大小
  pageSize: long(name='page_size'),
  // 链名称
  blockchain?: string(name='blockchain'),
}

model PagequeryDacTokenResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 当前页
  current?: long(name='current'),
  // 每页大小
  pageSize?: long(name='page_size'),
  // 总数
  total?: long(name='total'),
  // 币种信息
  list?: [ QueryTokenSymbolResponse ](name='list'),
}

/**
 * Description: 分页查询支持的币种
 * Summary: 分页查询支持的币种
 */
async function pagequeryDacToken(request: PagequeryDacTokenRequest): PagequeryDacTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return pagequeryDacTokenEx(request, headers, runtime);
}

/**
 * Description: 分页查询支持的币种
 * Summary: 分页查询支持的币种
 */
async function pagequeryDacTokenEx(request: PagequeryDacTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PagequeryDacTokenResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.token.pagequery', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model AddDacWhitelistRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 外部客户id
  externalCustId: string(name='external_cust_id'),
  // 外部客户名称
  externalCustName: string(name='external_cust_name'),
  // 白名单地址
  address: string(name='address'),
  // 区块链网络列表
  blockchainList: [ string ](name='blockchain_list'),
}

model AddDacWhitelistResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 添加白名单服务
 * Summary: 添加白名单服务
 */
async function addDacWhitelist(request: AddDacWhitelistRequest): AddDacWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return addDacWhitelistEx(request, headers, runtime);
}

/**
 * Description: 添加白名单服务
 * Summary: 添加白名单服务
 */
async function addDacWhitelistEx(request: AddDacWhitelistRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddDacWhitelistResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.whitelist.add', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model CheckDacWhitelistRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 公钥地址
  address: string(name='address'),
}

model CheckDacWhitelistResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 公钥地址
  address?: string(name='address'),
  // 支持的链列表
  blockchainList?: [ string ](name='blockchain_list'),
  // 检查结果类型
  checkResultType?: string(name='check_result_type'),
}

/**
 * Description: 白名单地址检查
 * Summary: 白名单地址检查
 */
async function checkDacWhitelist(request: CheckDacWhitelistRequest): CheckDacWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return checkDacWhitelistEx(request, headers, runtime);
}

/**
 * Description: 白名单地址检查
 * Summary: 白名单地址检查
 */
async function checkDacWhitelistEx(request: CheckDacWhitelistRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckDacWhitelistResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.whitelist.check', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryDacQuotaRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // your company external customer id
  externalCustomerId: string(name='external_customer_id'),
  // blockchain:Ethereum,Polygon,etc
  blockchain: string(name='blockchain'),
  // token symbol:USDC,USDT,etc
  tokenSymbol: string(name='token_symbol'),
  // quotaType:DEPOSIT/WITHDRAWAL
  quotaType: string(name='quota_type'),
}

model QueryDacQuotaResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // quotaType:DEPOSIT/WITHDRAWAL
  quotaType?: string(name='quota_type'),
  // quotaAmount
  quotaAmount?: string(name='quota_amount'),
}

/**
 * Description: Query customer quota and return the comparative balance between customer quota and customer balance
查询提现最大金额，会对比个人提现额度和自有余额，取最小值。
 * Summary: 查询提现最大金额
 */
async function queryDacQuota(request: QueryDacQuotaRequest): QueryDacQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryDacQuotaEx(request, headers, runtime);
}

/**
 * Description: Query customer quota and return the comparative balance between customer quota and customer balance
查询提现最大金额，会对比个人提现额度和自有余额，取最小值。
 * Summary: 查询提现最大金额
 */
async function queryDacQuotaEx(request: QueryDacQuotaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryDacQuotaResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.quota.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryDacCustodyaddressRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 区块链名称
  blockchain: string(name='blockchain'),
  // 外部客户唯一id
  externalCustomerId: string(name='external_customer_id'),
}

model QueryDacCustodyaddressResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 用户特定区块链的托管钱包地址，用于deposit转账使用
  custodyAddress?: string(name='custody_address'),
}

/**
 * Description: 查询指定用户和区块链的托管钱包地址
 * Summary: 查询托管地址
 */
async function queryDacCustodyaddress(request: QueryDacCustodyaddressRequest): QueryDacCustodyaddressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryDacCustodyaddressEx(request, headers, runtime);
}

/**
 * Description: 查询指定用户和区块链的托管钱包地址
 * Summary: 查询托管地址
 */
async function queryDacCustodyaddressEx(request: QueryDacCustodyaddressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryDacCustodyaddressResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.custodyaddress.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model CreateDacDepositRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 白名单地址为交易from的地址，用于发起转账操作
  whitelistAddress: string(name='whitelist_address'),
  // 存入的金额，可以为整数，或者携带小数位，除以精度之后的值
  depositAmount: string(name='deposit_amount'),
  // 区块链名称
  blockchain: string(name='blockchain'),
  // token名称
  tokenSymbol: string(name='token_symbol'),
  // 外部客户唯一id
  externalCustomerId: string(name='external_customer_id'),
}

model CreateDacDepositResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 订单id，订单创建失败时这个值为空
  orderId?: string(name='order_id'),
}

/**
 * Description: 创建deposit订单
 * Summary: 创建deposit订单
 */
async function createDacDeposit(request: CreateDacDepositRequest): CreateDacDepositResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return createDacDepositEx(request, headers, runtime);
}

/**
 * Description: 创建deposit订单
 * Summary: 创建deposit订单
 */
async function createDacDepositEx(request: CreateDacDepositRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDacDepositResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.deposit.create', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model PagequeryDacDepositRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 查询第几页，从1开始
  current: long(name='current'),
  // 每页展示多少条，默认10
  pageSize: long(name='page_size'),
  // 外部用户唯一id
  externalCustomerId: string(name='external_customer_id'),
}

model PagequeryDacDepositResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 当前第几页，为请求的参数值
  current?: long(name='current'),
  // 默认每页展示多少条，为请求的参数值
  pageSize?: long(name='page_size'),
  // 一共列表有多少条数据
  total?: long(name='total'),
  // deposit订单信息列表
  list?: [ QueryDepositOrderInfoResponse ](name='list'),
}

/**
 * Description: 分页查询deposit订单列表
 * Summary: 分页查询deposit订单列表
 */
async function pagequeryDacDeposit(request: PagequeryDacDepositRequest): PagequeryDacDepositResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return pagequeryDacDepositEx(request, headers, runtime);
}

/**
 * Description: 分页查询deposit订单列表
 * Summary: 分页查询deposit订单列表
 */
async function pagequeryDacDepositEx(request: PagequeryDacDepositRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PagequeryDacDepositResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.deposit.pagequery', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryDacDepositlimitsRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 外部用户唯一id
  externalCustomerId: string(name='external_customer_id'),
  // 代币名称
  tokenSymbol: string(name='token_symbol'),
}

model QueryDacDepositlimitsResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 可以deposit的最大金额
  depositMaxAmount?: string(name='deposit_max_amount'),
  // 可以deposit的最小金额
  depositMinAmount?: string(name='deposit_min_amount'),
}

/**
 * Description: 查询最大/最小可以deposit的数量
 * Summary: 查询最大/最小可以deposit的数量
 */
async function queryDacDepositlimits(request: QueryDacDepositlimitsRequest): QueryDacDepositlimitsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryDacDepositlimitsEx(request, headers, runtime);
}

/**
 * Description: 查询最大/最小可以deposit的数量
 * Summary: 查询最大/最小可以deposit的数量
 */
async function queryDacDepositlimitsEx(request: QueryDacDepositlimitsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryDacDepositlimitsResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.depositlimits.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model PagequeryDacWhitelistRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 当前第几个分页，默认为1
  current: long(name='current'),
  // 每页展示条数，默认为10
  pageSize: long(name='page_size'),
  // 外部用户唯一id
  externalCustomerId: string(name='external_customer_id'),
}

model PagequeryDacWhitelistResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 当前第几页，为前端的请求值
  current?: long(name='current'),
  // 每页展示多少条，为前端的请求值
  pageSize?: long(name='page_size'),
  // 总共有多少条数据
  total?: long(name='total'),
  // 返回白名单列表
  list?: [ QueryWhitelistAddressResponse ](name='list'),
}

/**
 * Description: 白名单分页列表查询
 * Summary: 白名单分页列表查询
 */
async function pagequeryDacWhitelist(request: PagequeryDacWhitelistRequest): PagequeryDacWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return pagequeryDacWhitelistEx(request, headers, runtime);
}

/**
 * Description: 白名单分页列表查询
 * Summary: 白名单分页列表查询
 */
async function pagequeryDacWhitelistEx(request: PagequeryDacWhitelistRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PagequeryDacWhitelistResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antdigital.webtts.dac.whitelist.pagequery', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

