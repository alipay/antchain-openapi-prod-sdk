import AntchainUtil;
import Util;
import RPCUtil;

type @endpoint = string
type @regionId = string
type @accessKeyId = string
type @accessKeySecret = string
type @protocol = string
type @userAgent = string
type @readTimeout = number
type @connectTimeout = number
type @httpProxy = string
type @httpsProxy = string
type @socks5Proxy = string
type @socks5NetWork = string
type @noProxy = string
type @maxIdleConns = number
type @securityToken = string
type @maxIdleTimeMillis = number
type @keepAliveDurationMillis = number
type @maxRequests = number
type @maxRequestsPerHost = number

/**
 * Model for initing client
 */
model Config {
  accessKeyId?: string(description='accesskey id',default=''),
  accessKeySecret?: string(description='accesskey secret',default=''),
  securityToken?: string(description='security token',default=''),
  protocol?: string(description='http protocol',example='http',default='http'),
  readTimeout?: number(description='read timeout',example='10',default=''),
  connectTimeout?: number(description='connect timeout',example='10',default=''),
  httpProxy?: string(description='http proxy',example='http://localhost',default=''),
  httpsProxy?: string(description='https proxy',example='https://localhost',default=''),
  endpoint?: string(description='endpoint',example='cs.aliyuncs.com',default=''),
  noProxy?: string(description='proxy white list',example='http://localhost',default=''),
  maxIdleConns?: number(description='max idle conns',example='3',default=''),
  userAgent?: string(description='user agent',example='Alibabacloud/1',default=''),
  socks5Proxy?: string(description='socks5 proxy',default=''),
  socks5NetWork?: string(description='socks5 network',example='TCP',default=''),
  maxIdleTimeMillis?: number(description='长链接最大空闲时长',default='60 * 1000L'),
  keepAliveDurationMillis?: number(description='长链接最大连接时长',default='5000'),
  maxRequests?: number(description='最大连接数（长链接最大总数）',default='100'),
  maxRequestsPerHost?: number(description='每个目标主机的最大连接数（分主机域名的长链接最大总数',default='100'),
}

/**
 * Init client with Config
 * @param config config contains the necessary information to create a client
 */
init(config: Config) {
  if (Util.isUnset(config)) {
    throw {
      code = 'ParameterMissing',
      message = '\'config\' can not be unset'
    };
  }

  @accessKeyId = config.accessKeyId;
  @accessKeySecret = config.accessKeySecret;
  @securityToken = config.securityToken;
  @endpoint = config.endpoint;
  @protocol = config.protocol;
  @userAgent = config.userAgent;
  @readTimeout = Util.defaultNumber(config.readTimeout, 20000);
  @connectTimeout = Util.defaultNumber(config.connectTimeout, 20000);
  @httpProxy = config.httpProxy;
  @httpsProxy = config.httpsProxy;
  @noProxy = config.noProxy;
  @socks5Proxy = config.socks5Proxy;
  @socks5NetWork = config.socks5NetWork;
  @maxIdleConns = Util.defaultNumber(config.maxIdleConns, 60000);
  @maxIdleTimeMillis = Util.defaultNumber(config.maxIdleTimeMillis, 5);
  @keepAliveDurationMillis = Util.defaultNumber(config.keepAliveDurationMillis, 5000);
  @maxRequests = Util.defaultNumber(config.maxRequests, 100);
  @maxRequestsPerHost = Util.defaultNumber(config.maxRequestsPerHost, 100);
}

/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param protocol http or https
 * @param method e.g. GET
 * @param pathname pathname of every api
 * @param request which contains request params
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doRequest(version: string, action: string, protocol: string, method: string, pathname: string, request: object, headers: map[string]string, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = pathname;
  __request.query = {
    method = action,
    version = version,
    sign_type = 'HmacSHA1',
    req_time = AntchainUtil.getTimestamp(),
    req_msg_id = AntchainUtil.getNonce(),
    access_key = @accessKeyId,
    base_sdk_version = 'TeaSDK-2.0',
    sdk_version = '1.4.0',
  };

  if (!Util.empty(@securityToken)) {
    __request.query.security_token = @securityToken;
  }

  __request.headers = {
    host = Util.defaultString(@endpoint, 'openapi.antchain.antgroup.com'),
    user-agent = Util.getUserAgent(@userAgent),
    ...headers
  };

  var tmp = Util.anyifyMapValue(RPCUtil.query(request));
  __request.body = Util.toFormString(tmp);
  __request.headers.content-type = 'application/x-www-form-urlencoded';

  var signedParam = {
    ...__request.query,
    ...RPCUtil.query(request)
  };
  __request.query.sign = AntchainUtil.getSignature(signedParam, @accessKeySecret);
} returns {
  var raw = Util.readAsString(__response.body);
  var obj = Util.parseJSON(raw);
  var res = Util.assertAsMap(obj);
  var resp = Util.assertAsMap(res.response);

  if (AntchainUtil.hasError(raw, @accessKeySecret)) {
    throw {
      message = resp.result_msg,
      data = resp,
      code = resp.result_code
    };
  }
  return resp;
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  maxIdleTimeMillis = @maxIdleTimeMillis,
  keepAliveDurationMillis = @keepAliveDurationMillis,
  maxRequests = @maxRequests,
  maxRequestsPerHost = @maxRequestsPerHost,
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL
}

// 逻辑
model Logic {
  // 操作符
  //  equal = _equal_, // 相等比较
  //   notEqual = _notEqual_, // 不相等比较
  //   AND = _AND_, // 与逻辑
  //   OR = _OR_, // 或逻辑
  op: string(name='op', example='equal'),
  //  只有 op 是 AND 或者 OR 才是可选，其他情况为必选
  key: string(name='key', example='sss'),
  // 只有 op 是 AND 或者 OR 才是可选，其他情况为必选
  value: string(name='value', example='d d d'),
  // 只有 op 是 AND 或者 OR 才需要这个字段
  // [{op: _AND_, // 与逻辑
  //         children: [
  //           {
  //             op: _equal_, // 相等比较
  //             key: _validationMethod_, // 表示：验证方式
  //             value: _smsCode_  // 表示：短信验证码
  //           },
  //           { // 判断登录信息的值不为 null
  //             op: _notEqual_, // 不相等比较
  //             key: _username_,  // 表示：登录信息
  //             value: null
  //           }]}]
  children: string(name='children', example='[]'),
}

// 规则
model Rule {
  // 字段值的类型，常见有 string | number| boolean | _array_
  type: string(name='type', example='string'),
  // type 为 string 类型时，表示字符串长度；number 类型时表示确定数字； array 类型时表示数组长度
  len: long(name='len', example='11'),
  // type 为 string 类型时，表示字符串最大长度；number 类型时表示最大值；array 类型时表示数组最大长度
  max: long(name='max', example='13'),
  // type 为 string 类型时，表示字符串最小长度；number 类型时表示最小值；array 类型时表示数组最小长度
  min: long(name='min', example='4'),
  // 校验出错时显示的错误消息
  message: string(name='message', example='重新输入'),
  // 是否必填
  required: boolean(name='required', example='true, false'),
  // 正则表达式,
  regPattern: string(name='reg_pattern', example='d'),
}

// 忘记密码
model ForgetMeta {
  // 字段名称
  label: string(name='label', example='字段名称 例如：密码'),
  // 忘记密码的链接地址，供重置用
  link: string(name='link', example='www.baidu.com'),
}

// 选择组件
model SelectOption {
  // 选项名称
  lable: string(name='lable', example='选项名称'),
  // 选项的值，一般是 id 之类的唯一标识符，给后端传这个
  value: string(name='value', example='zhangsan'),
}

// 组件
model Key {
  // 名称（key的中文名称）
  key: string(name='key', example='test'),
  // id
  id: string(name='id', example='123232423'),
  // input, // 普通输入框
  // dropdownSelect, // 下拉选择
  // cardSelect, // 平铺选择
  // password, // 密码输入框，这个类型会包含忘记密码按钮
  // smsCode, // 手机验证码
  // qrcodeLogin, // 二维码登录
  // hiddenField,// 隐藏字段，页面上不显示，但是值会提交给后端
  type: string(name='type', example='cardSelect'),
  // 字段名称 例如：密码
  label: string(name='label', example='dd'),
  // 输入框的值类型，字符串还是数字，默认 string/number/paassword
  inputType: string(name='input_type', example='number'),
  // 字段的初始值，类型要和前端提交的类型保持一致，且是可被 JSON 序列化的
  initialValue: string(name='initial_value', example='ddd'),
  // 占位符，比如”请输入密码“
  placeholder: string(name='placeholder', example='请输入密码'),
  // 是否为禁用状态，true 表示禁用，默认 false
  disabled: boolean(name='disabled', example='true, false'),
  // 表示输入框是否为只读状态（只读和禁用都不能输入，但是样式不一样，所以要注意区分，不要同时声明 disabled 和 readOnly，否则以 disabled 优先）
  readOnly: string(name='read_only', example='true'),
  // 这个字段的提示说明文案
  tooltip: string(name='tooltip', example='这个字段的提示说明文案，点击字段名称右侧的 icon 时显示'),
  // 校验规则
  rules: [ Rule ](name='rules', example='校验规则'),
  // 逻辑列表
  logics: [ Logic ](name='logics', example=''),
  // 选择列表的可选值，只有 type 是 dropdownSelect、cardSelect 时才需要
  selectOptions: [ SelectOption ](name='select_options', example=''),
  // 忘记密码元素
  forgetMeta: ForgetMeta(name='forget_meta', example=''),
}

// 配对
model Pair {
  // left
  left: string(name='left', example='left'),
  // right
  right: Key(name='right', example='right'),
}

// 地区请求
model DistrictExtRequest {
  // 地区编码
  cityCode: string(name='city_code', example='340909'),
}

// card
model Card {
  // 名称（该页面的名称，可能做展示用）
  name: string(name='name', example='名称（该页面的名称，可能做展示用）'),
  // 如果一层有多个卡片，那么这个名称就作为tab的头名称展示
  tabShowName: string(name='tab_show_name', example='如果一层有多个卡片，那么这个名称就作为tab的头名称展示'),
  // 当前模版所有需要填充元素
  keyValues: Pair(name='key_values', example='当前模版所有需要填充元素'),
  // true：是，false：不是
  // 是否作同一个父节点的默认展示，比如验证码和密码默认是哪个
  isSelected: string(name='is_selected', example='是否作同一个父节点的默认展示'),
  // 备注：如果显示是这两个，代表返回的值得分别塞到这两个key对应的value中/
  returnValueKey: [ string ](name='return_value_key', example='[selectCard1,input1]'),
}

// 通用同步授权扩展字段
model AgreementExtRequest {
  // 证书类型
  type: string(name='type', example='证书类型'),
  // 是否盖章，true：是 false：否
  isSeal: string(name='is_seal', example='true'),
  // 地址
  address: string(name='address', example='http://sdsdfsd.com'),
}

// 树节点
model TreeNode {
  // 节点id，按树的前序排列
  id: long(name='id', example=''),
  // 父节点id，不存在为null
  parentNodeId: string(name='parent_node_id', example='父节点id，不存在为null'),
  // 深度
  depth: long(name='depth', example='1'),
  // 是否叶子结点
  isLeefNode: string(name='is_leef_node', example='true：是，false：否'),
  // 模版
  card: Card(name='card', example='模版'),
}

// 发票明细
model InvoiceItem {
  // 税收分类编码	
  spbm: string(name='spbm', example='xxx'),
  // 项目名称, 如果为折扣行，商品名称须与被折扣行的商品名称相同，不能多行折扣。
  mc: string(name='mc', example='xxx'),
  // 单位
  jldw?: string(name='jldw', example='xxx'),
  // 数量
  shul?: string(name='shul', example='10'),
  // 含税金额,2位小数
  je: string(name='je', example='10.11'),
  // 税率,当fplx!=51or53时，必填,3位小数，例1%为0.010；
  sl?: string(name='sl', example='0.01'),
  // 税额,当fplx!=51or53时，必填
  se?: string(name='se', example='10.11'),
  // 明细序号,从1开始递增
  mxxh: string(name='mxxh', example='2'),
  // 单价
  dj: string(name='dj', example='10.11'),
  // 规格型号
  ggxh?: string(name='ggxh', example='xxx'),
}

// 授权扩展信息
model StandardAuthExtendInfoRequest {
  // 协议列表
  agreementList: [ AgreementExtRequest ](name='agreement_list', example='协议列表'),
  // 地区请求
  districtextRequest: DistrictExtRequest(name='districtext_request', example='地区请求'),
}

// 返回详情
model ReturnDetail {
  // 结果对象内容
  bizContent: string(name='biz_content', example='{}'),
  // 返回形式
  returnType: string(name='return_type', example='BIZCONTENT 字段返回格式化,这种模式下取bizContent字段 FILE 文件模式，这种模式下用fileUrls获取文件'),
  // 文件列表
  fileUrls: [ string ](name='file_urls', example='["a.com","b.com"]'),
  // 文件类型
  fileType: string(name='file_type', example=' PDF pdf TXT JSON结构化'),
  // 加密模式
  encryptModel: string(name='encrypt_model', example='LINKS：链接加密 CONTENT：内容加密，使用信封模式，'),
  // 密钥信封
  secretEnvelope: string(name='secret_envelope', example='密钥信封，用RSA将将对内容处理的对称钥加密'),
}

// 二维码
model QrCodeValue {
  // 二维码链接
  qrCodeUrl: string(name='qr_code_url', example='二维码链接'),
  // 二维码描述信息。例如：请使用 xxx app 扫码登录
  desc: string(name='desc', example='二维码描述信息。例如：请使用 xxx app 扫码登录'),
  // 二维码在多长时间后失效，单位：秒
  timeout: long(name='timeout', example='60'),
}

// TreeTemplate
model TreeTemplate {
  // 树节点
  treeNode: TreeNode(name='tree_node', example=''),
  // Id
  id: string(name='id', example='123'),
  // 版本号
  version: string(name='version', example='1.0.8'),
  // 向上兼容的最小版本号
  compatibleMinVersion: string(name='compatible_min_version', example='1.0.06'),
}

// 通用base授权
model BaseAuthRequest {
  // 租户号
  instCode: string(name='inst_code', example='OCRGDSFD'),
  // 授权类型
  authType: string(name='auth_type', example='19'),
  // xdsadsfsdf
  orderNo: string(name='order_no', example='订单号'),
  // 扩展信息
  extendInfo: StandardAuthExtendInfoRequest(name='extend_info', example='扩展信息'),
}

// 发票标准模型
model Invoice {
  // 备注
  bz?: string(name='bz', example='xxx'),
  // 复核人
  fhr?: string(name='fhr', example='xxx'),
  // 发票代码, 发票代码+发票号码唯一
  fpdm: string(name='fpdm', example='xxx'),
  // 发票号码,发票代码+发票号码唯一
  fphm: string(name='fphm', example='xxx'),
  // 发票类型代码,
  // 默认填:20:广东电子普通发票
  // 01：增值税专用发票
  // 04：增值税普通发票
  // 10：增值税电子普通发票
  // 51：重庆通用机打一联发票76
  // 53：重庆通用机打三联发票210
  // 90：重庆通用机打三联发票190
  fplx: string(name='fplx', example='20'),
  // 发票明细集合
  fpxxmxs?: [ InvoiceItem ](name='fpxxmxs', example='xxx'),
  // 发票状态代码,0 正常 1 失控 2 作废 3 红字 4 异常票
  fpztdm: string(name='fpztdm', example='0'),
  // 购买方地址、电话
  gfdzdh?: string(name='gfdzdh', example='xxx'),
  // 购买方名称
  gfmc: string(name='gfmc', example='xxx'),
  // 购买方纳税人识别号
  gfsh?: string(name='gfsh', example='xxx'),
  // 购买方银行账号
  gfyhzh?: string(name='gfyhzh', example='xxx'),
  // 购买方类型,1企业 2个人 3其他
  gmflx?: string(name='gmflx', example='1'),
  // 金额
  je: string(name='je', example='20.11'),
  // 价税合计	， 单位：元（2 位小数）
  jshj: string(name='jshj', example='10.11'),
  // 开票类型,0-蓝字发票；1-红字发票；
  kplx: string(name='kplx', example='1'),
  // 开票人
  kpr: string(name='kpr', example='xxx'),
  // 开票日期
  kprq: string(pattern='\\\\d{4}[-]\\\\d{1,2}[-]\\\\d{1,2}[T]\\\\d{2}:\\\\d{2}:\\\\d{2}([Z]|([\\\\.]\\\\d{1,9})?[\\\\+]\\\\d{2}[\\\\:]?\\\\d{2})', name='kprq', example='xxx'),
  // 清单标志,00:无清单 01:有清单
  qdbz?: string(name='qdbz', example='00'),
  // 认证状态
  rzdklbdjgdm?: string(name='rzdklbdjgdm', example='xxx'),
  // 认证日期
  rzdklbdrq?: string(pattern='\\\\d{4}[-]\\\\d{1,2}[-]\\\\d{1,2}[T]\\\\d{2}:\\\\d{2}:\\\\d{2}([Z]|([\\\\.]\\\\d{1,9})?[\\\\+]\\\\d{2}[\\\\:]?\\\\d{2})', name='rzdklbdrq', example='2018-10-10T10:10:00Z'),
  // 税额,当发票类型代码	 fplx!=51or fplx!=53时，必填
  se?: string(name='se', example='10.11'),
  // 收款人
  skr?: string(name='skr', example='xxx'),
  // 税率标识,0不含税税率；1含税税率
  slbz: string(name='slbz', example='0'),
  // 所属税务机关代码:
  // 山东省343
  // 重庆市350
  // 广东省347
  ssdq: string(name='ssdq', example='343'),
  // 销售方地址、电话
  xfdzdh?: string(name='xfdzdh', example='xxx'),
  // 销售方名称
  xfmc: string(name='xfmc', example='xxx'),
  // 销售方纳税人识别号
  xfsh: string(name='xfsh', example='xxx'),
  // 销售方银行账号
  xfyhzh?: string(name='xfyhzh', example='xxx'),
  // 原发票代码, kplx开票类型为1时必填
  yfpdm?: string(name='yfpdm', example='xxx'),
  // 原发票号码,kplx开票类型为1时必填
  yfphm?: string(name='yfphm', example='xxx'),
  // 作废标志,0:未作废，1作废
  zfbz: string(name='zfbz', example='0'),
  // 作废时间
  zfsj?: string(pattern='\\\\d{4}[-]\\\\d{1,2}[-]\\\\d{1,2}[T]\\\\d{2}:\\\\d{2}:\\\\d{2}([Z]|([\\\\.]\\\\d{1,9})?[\\\\+]\\\\d{2}[\\\\:]?\\\\d{2})', name='zfsj', example='xxx'),
  // 扩展字段
  extFiled: string(name='ext_filed', example='{abc:123,def:456}'),
}

// 个人授权
model StandardRealPersonAuthRequest {
  // 个人证件号
  identityId: string(name='identity_id', example='个人证件号340902xxxx'),
  // 名字
  identityName: string(name='identity_name', example='张三'),
}

model AuthCorpRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 企业注册地址和电话号码
  corpAddressPhoneNo: string(name='corp_address_phone_no'),
  // 企业银行账号
  corpBankNo: string(name='corp_bank_no'),
  // 填写公司名称
  corpName: string(name='corp_name'),
  // 企业授权秘钥
  corpPrivateKey: string(name='corp_private_key'),
  // 企业纳税人识别号
  corpTaxId: string(name='corp_tax_id'),
}

model AuthCorpResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 目前仅用于广州区块链发票开通企业信息推送
 * Summary: 区块链发票开通企业信息推送
 */
async function authCorp(request: AuthCorpRequest): AuthCorpResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return authCorpEx(request, headers, runtime);
}

/**
 * Description: 目前仅用于广州区块链发票开通企业信息推送
 * Summary: 区块链发票开通企业信息推送
 */
async function authCorpEx(request: AuthCorpRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthCorpResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.corp.auth', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model PushChargeRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 租户
  bizTenant: string(name='biz_tenant'),
  // 平台分发,子业务类型，对应原来的authType.
  bizType: string(name='biz_type'),
  // 用户ID，根据业务对主体定义决定，比如票据业务的纳税人识别号
  customerId: string(name='customer_id'),
  // 系统编码,平台分发，定义枚举，全局用
  systemCode: string(name='system_code'),
  // 请求id
  taskRequestId: string(name='task_request_id'),
}

model PushChargeResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 目前用于浙江票据的计费推送，其他主站环境还是继续使用msg。
 * Summary: 计费推送
 */
async function pushCharge(request: PushChargeRequest): PushChargeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return pushChargeEx(request, headers, runtime);
}

/**
 * Description: 目前用于浙江票据的计费推送，其他主站环境还是继续使用msg。
 * Summary: 计费推送
 */
async function pushChargeEx(request: PushChargeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PushChargeResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.charge.push', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryChargeAuthRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 租户
  bizTenant: string(name='biz_tenant'),
  // 授权类型,业务类型
  bizType: string(name='biz_type'),
}

model QueryChargeAuthResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // OPEN:开通
  // STOP：停止
  // NOT_SALE：未授权
  authType?: string(name='auth_type'),
}

/**
 * Description: 查询计收费授权情况
 * Summary: 查询计收费授权情况
 */
async function queryChargeAuth(request: QueryChargeAuthRequest): QueryChargeAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryChargeAuthEx(request, headers, runtime);
}

/**
 * Description: 查询计收费授权情况
 * Summary: 查询计收费授权情况
 */
async function queryChargeAuthEx(request: QueryChargeAuthRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryChargeAuthResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.charge.auth.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model PushIcmInvoiceRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 批次号
  pch: string(name='pch'),
  // 发票信息（json格式）
  fpxx: string(name='fpxx'),
  // 发票类型
  // 01：增值税专用发票
  // 04：增值税普通发票
  // 10：增值税电子普通发票
  fplx: string(name='fplx'),
  // 是否是历史数据推送
  islsp: boolean(name='islsp'),
}

model PushIcmInvoiceResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 目前仅用于广州区块链发票信息推送
 * Summary:  区块链发票信息推送
 */
async function pushIcmInvoice(request: PushIcmInvoiceRequest): PushIcmInvoiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return pushIcmInvoiceEx(request, headers, runtime);
}

/**
 * Description: 目前仅用于广州区块链发票信息推送
 * Summary:  区块链发票信息推送
 */
async function pushIcmInvoiceEx(request: PushIcmInvoiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PushIcmInvoiceResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.icm.invoice.push', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryIcmInvoiceRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // ISV名称，用于标识合作的企业
  appId: string(name='app_id'),
  // 授权类型
  // 01:发票归集授权; 02:记账; 03:报销; 11:发票贷授权; （0X发票相关授权，1X金融类授权）
  authType: string(name='auth_type'),
  //  数据通知地址接口 (当type=02或者03时必填) 用于数据采集完毕后通知该接口如何取发票数据
  // 
  callbackUrl?: string(name='callback_url'),
  // java long型
  // 起始金额，当type=03（报销查询）时必填
  endAmount?: long(name='end_amount'),
  // 查询起始时间(当auth_type=02或者03时必填)
  // 当auth_type=02(记账查询)时，查询起始时间和查询截止时间必须在同一个月内，如查询起始日期是6.31，截止日期为7.1，则会提示查询时间不能跨月，最长时间为一个月
  // 最大查询范围为6.1-6.30
  endDate?: string(pattern='\\\\d{4}[-]\\\\d{1,2}[-]\\\\d{1,2}[T]\\\\d{2}:\\\\d{2}:\\\\d{2}([Z]|([\\\\.]\\\\d{1,9})?[\\\\+]\\\\d{2}[\\\\:]?\\\\d{2})', name='end_date'),
  // 非必填，不填则查询所有类型发票
  // "01": "增值税专用发票"
  // "04": "增值税普通发票"
  // "10": "增值税电子普通发票"
  invoiceType?: string(name='invoice_type'),
  // 查询的企业纳税人识别号
  nsrsbh: string(name='nsrsbh'),
  // 请求号，调用方企业保证每次调用唯一，蚂蚁发票平台通过该字段和app_id两个字段做幂等判断
  requestId: string(name='request_id'),
  // java long型
  // 起始金额，当type=03（报销查询）时必填
  startAmount?: long(name='start_amount'),
  // 查询起始时间(当auth_type=02或者03时必填)
  // 当auth_type=02(记账查询)时，查询起始时间和查询截止时间必须在同一个月内，如查询起始日期是6.31，截止日期为7.1，则会提示查询时间不能跨月，最长时间为一个月
  // 最大查询范围为6.1-6.30
  startDate?: string(pattern='\\\\d{4}[-]\\\\d{1,2}[-]\\\\d{1,2}[T]\\\\d{2}:\\\\d{2}:\\\\d{2}([Z]|([\\\\.]\\\\d{1,9})?[\\\\+]\\\\d{2}[\\\\:]?\\\\d{2})', name='start_date'),
}

model QueryIcmInvoiceResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 区块链发票信息查询接口-该接口为异步查询接口，查询结果通过回调调用方提供的callUrl方式进行通知
 * Summary:  区块链发票信息查询
 */
async function queryIcmInvoice(request: QueryIcmInvoiceRequest): QueryIcmInvoiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryIcmInvoiceEx(request, headers, runtime);
}

/**
 * Description: 区块链发票信息查询接口-该接口为异步查询接口，查询结果通过回调调用方提供的callUrl方式进行通知
 * Summary:  区块链发票信息查询
 */
async function queryIcmInvoiceEx(request: QueryIcmInvoiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryIcmInvoiceResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.icm.invoice.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model PushIcmInvoiceinfoRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 上票ISV app_id即secret_id
  appId: string(name='app_id'),
  // 发票号码	
  invoice: Invoice(name='invoice'),
}

model PushIcmInvoiceinfoResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 标准发票推送
 * Summary: 标准发票推送
 */
async function pushIcmInvoiceinfo(request: PushIcmInvoiceinfoRequest): PushIcmInvoiceinfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return pushIcmInvoiceinfoEx(request, headers, runtime);
}

/**
 * Description: 标准发票推送
 * Summary: 标准发票推送
 */
async function pushIcmInvoiceinfoEx(request: PushIcmInvoiceinfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PushIcmInvoiceinfoResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.icm.invoiceinfo.push', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model DescribeIcmInvoiceRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 发票销方税号
  xfsh: string(maxLength=30, name='xfsh'),
  // 发票代码
  fpdm: string(maxLength=100, name='fpdm'),
  // 发票号码
  fphm: string(maxLength=100, name='fphm'),
}

model DescribeIcmInvoiceResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 交易hash即txhash
  txhash?: string(name='txhash'),
  // 交易块号
  blockNumber?: string(name='block_number'),
  // 交易时间
  timestamp?: string(name='timestamp'),
}

/**
 * Description: 根据发票销方税号，发票代码和发票号码获取该张发票在链上的信息，比如快高，交易hash，交易时间
 * Summary: 获取数据的上链信息描述
 */
async function describeIcmInvoice(request: DescribeIcmInvoiceRequest): DescribeIcmInvoiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return describeIcmInvoiceEx(request, headers, runtime);
}

/**
 * Description: 根据发票销方税号，发票代码和发票号码获取该张发票在链上的信息，比如快高，交易hash，交易时间
 * Summary: 获取数据的上链信息描述
 */
async function describeIcmInvoiceEx(request: DescribeIcmInvoiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeIcmInvoiceResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.icm.invoice.describe', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model AuthIcmInvoiceRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 请求号，调用方企业保证每次调用唯一，蚂蚁发票平台通过该字段和app_id两个字段做幂等判断
  requestId: string(name='request_id'),
  // 查询的企业纳税人识别号
  // 
  nsrsbh: string(name='nsrsbh'),
  // 企业名称
  corpName: string(name='corp_name'),
  // 身份证号
  identityNumber: string(name='identity_number'),
  // 已认证的法人手机号
  cognizantMobile: string(name='cognizant_mobile'),
  // 已认证的法人姓名
  cognizantName: string(name='cognizant_name'),
  // 透传字段
  bizContext?: string(name='biz_context'),
  // 授权业务类型
  authType: string(name='auth_type'),
}

model AuthIcmInvoiceResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 授权是否成功：true：成功 false：失败
  success?: string(name='success'),
  // 透传字段
  bizContext?: string(name='biz_context'),
  // 纳税人识别号
  nsrsbh?: string(name='nsrsbh'),
  // 过期时间
  expiredTime?: string(name='expired_time'),
  // 业务请求id
  requestId?: string(name='request_id'),
  // 错误码
  errorCode?: string(name='error_code'),
  // 错误信息
  errorMsg?: string(name='error_msg'),
}

/**
 * Description: 区块链银行接口-该接口为支持贷后授权接口，授权结果以同步方式返回
 * Summary: 区块链银行授权接口
 */
async function authIcmInvoice(request: AuthIcmInvoiceRequest): AuthIcmInvoiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return authIcmInvoiceEx(request, headers, runtime);
}

/**
 * Description: 区块链银行接口-该接口为支持贷后授权接口，授权结果以同步方式返回
 * Summary: 区块链银行授权接口
 */
async function authIcmInvoiceEx(request: AuthIcmInvoiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthIcmInvoiceResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.icm.invoice.auth', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model AuthIcmRealpersonRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 基础授权请求
  request: BaseAuthRequest(name='request'),
  // 个人证件号
  identityId: string(name='identity_id'),
  // 名字
  identityName: string(name='identity_name'),
}

model AuthIcmRealpersonResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 是否授权成功true是，false否
  authSuccess?: boolean(name='auth_success'),
  // 订单号
  orderNo?: string(name='order_no'),
  // 过期时间
  expireTime?: string(name='expire_time'),
  // 授权时间 unix时间戳
  authTime?: string(name='auth_time'),
}

/**
 * Description: 个人数据使用授权
 * Summary: 个人数据使用授权
 */
async function authIcmRealperson(request: AuthIcmRealpersonRequest): AuthIcmRealpersonResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return authIcmRealpersonEx(request, headers, runtime);
}

/**
 * Description: 个人数据使用授权
 * Summary: 个人数据使用授权
 */
async function authIcmRealpersonEx(request: AuthIcmRealpersonRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthIcmRealpersonResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.icm.realperson.auth', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model ExecIcmSyncgatheringRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 机构号码
  instCode: string(name='inst_code'),
  // 请求流水号(必填),调用方保证每次请求号唯一，受理方用来校验唯一性，同一受理号返回请求结果一致
  bizRequestId: string(name='biz_request_id'),
  // 纳税人识别号(必填)
  identityId: string(name='identity_id'),
  // 授权类型(必填)
  authType: string(name='auth_type'),
  // 订单号
  orderNo: string(name='order_no'),
  // 补充内容,如果不动产中字段为空的话查的就是授权中的cityCode
  content: string(name='content'),
}

model ExecIcmSyncgatheringResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 返回的请求对象jsonString
  bizContent?: string(name='biz_content'),
  // unix秒时间戳,查询时间，用来对账使用
  queryTime?: string(name='query_time'),
  // 返回模式
  returnMode?: string(name='return_mode'),
  // 返回结果
  returnResult?: [ ReturnDetail ](name='return_result'),
}

/**
 * Description: 采集，不限制同步 异步
 * Summary: 采集
 */
async function execIcmSyncgathering(request: ExecIcmSyncgatheringRequest): ExecIcmSyncgatheringResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return execIcmSyncgatheringEx(request, headers, runtime);
}

/**
 * Description: 采集，不限制同步 异步
 * Summary: 采集
 */
async function execIcmSyncgatheringEx(request: ExecIcmSyncgatheringRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExecIcmSyncgatheringResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.icm.syncgathering.exec', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryApiAuthteplateRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务订单号
  orderNo: string(name='order_no'),
  // 身份ID 身份证或者统一社会信用编码
  identityId: string(name='identity_id'),
  // 名称
  identityName: string(name='identity_name'),
  // 业务类型
  // 11 税
  // 12票
  // 13税+票
  authType: string(name='auth_type'),
  // 法人名称
  cognizantName: string(name='cognizant_name'),
  // 法人证件号
  coidentityNumber: string(name='coidentity_number'),
  // 法人手机号
  cognizantMobile: string(name='cognizant_mobile'),
}

model QueryApiAuthteplateResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // JWT生成，设置失效时间，维持会话数据
  token?: string(name='token'),
  // Unix时间戳 秒
  expireTime?: long(name='expire_time'),
  // 模版树
  treeTemplate?: TreeTemplate(name='tree_template'),
}

/**
 * Description: 获取授权模版和token
 * Summary: 获取授权模版和token
 */
async function queryApiAuthteplate(request: QueryApiAuthteplateRequest): QueryApiAuthteplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryApiAuthteplateEx(request, headers, runtime);
}

/**
 * Description: 获取授权模版和token
 * Summary: 获取授权模版和token
 */
async function queryApiAuthteplateEx(request: QueryApiAuthteplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryApiAuthteplateResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.api.authteplate.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model ExecApiAuthtemplateRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // token
  token: string(name='token'),
  // 树的模版id
  treeTemplateId: string(name='tree_template_id'),
  // 模版对应的版本号
  treeVersion: string(name='tree_version'),
  // 对应节点ID
  nodeId: string(name='node_id'),
  // 当前卡片所有需要填充元素key
  // 和value值
  pairs: Pair(name='pairs'),
}

model ExecApiAuthtemplateResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 返回的下一层节点集合
  nodes?: [ TreeNode ](name='nodes'),
  // 树id
  treeTemplateId?: string(name='tree_template_id'),
  // 授权状态,提交接口此字段为空
  // 1、正在处理中
  // 2、登陆成功
  authState?: string(name='auth_state'),
  // 请求是否成功
  // true 成功
  // false 失败
  success?: boolean(name='success'),
}

/**
 * Description: 提交
 * Summary: 提交
 */
async function execApiAuthtemplate(request: ExecApiAuthtemplateRequest): ExecApiAuthtemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return execApiAuthtemplateEx(request, headers, runtime);
}

/**
 * Description: 提交
 * Summary: 提交
 */
async function execApiAuthtemplateEx(request: ExecApiAuthtemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExecApiAuthtemplateResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.api.authtemplate.exec', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryApiAuthtemplatedefineRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // token
  token: string(name='token'),
  // message：短信
  // qrCode：二维码
  actionType: string(name='action_type'),
  // 依赖的数据值 比如身份证
  dependsValue: string(name='depends_value'),
}

model QueryApiAuthtemplatedefineResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 二维码类型返回二维码描述
  // 短信无返回，接口成功即可
  value?: string(name='value'),
}

/**
 * Description: 获取要素信息
 * Summary: 获取要素信息
 */
async function queryApiAuthtemplatedefine(request: QueryApiAuthtemplatedefineRequest): QueryApiAuthtemplatedefineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryApiAuthtemplatedefineEx(request, headers, runtime);
}

/**
 * Description: 获取要素信息
 * Summary: 获取要素信息
 */
async function queryApiAuthtemplatedefineEx(request: QueryApiAuthtemplatedefineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryApiAuthtemplatedefineResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.api.authtemplatedefine.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryApiAuthtemplateresultRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务授权订单号 用户幂等控制，调用方保证唯一
  orderNo: string(name='order_no'),
  // 身份ID
  identityId: string(name='identity_id'),
}

model QueryApiAuthtemplateresultResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 是否成功
  success?: boolean(name='success'),
  // 授权状态
  // 1、正在处理中
  // 2、登陆成功
  authState?: string(name='auth_state'),
}

/**
 * Description: 获取授权结果
 * Summary: 获取授权结果
 */
async function queryApiAuthtemplateresult(request: QueryApiAuthtemplateresultRequest): QueryApiAuthtemplateresultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryApiAuthtemplateresultEx(request, headers, runtime);
}

/**
 * Description: 获取授权结果
 * Summary: 获取授权结果
 */
async function queryApiAuthtemplateresultEx(request: QueryApiAuthtemplateresultRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryApiAuthtemplateresultResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'blockchain.tax.api.authtemplateresult.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

