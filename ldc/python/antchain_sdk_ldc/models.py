# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel
from typing import List


class Config(TeaModel):
    """
    Model for initing client
    """
    def __init__(
        self,
        access_key_id: str = None,
        access_key_secret: str = None,
        security_token: str = None,
        protocol: str = None,
        read_timeout: int = None,
        connect_timeout: int = None,
        http_proxy: str = None,
        https_proxy: str = None,
        endpoint: str = None,
        no_proxy: str = None,
        max_idle_conns: int = None,
        user_agent: str = None,
        socks_5proxy: str = None,
        socks_5net_work: str = None,
        max_idle_time_millis: int = None,
        keep_alive_duration_millis: int = None,
        max_requests: int = None,
        max_requests_per_host: int = None,
    ):
        # accesskey id
        self.access_key_id = access_key_id
        # accesskey secret
        self.access_key_secret = access_key_secret
        # security token
        self.security_token = security_token
        # http protocol
        self.protocol = protocol
        # read timeout
        self.read_timeout = read_timeout
        # connect timeout
        self.connect_timeout = connect_timeout
        # http proxy
        self.http_proxy = http_proxy
        # https proxy
        self.https_proxy = https_proxy
        # endpoint
        self.endpoint = endpoint
        # proxy white list
        self.no_proxy = no_proxy
        # max idle conns
        self.max_idle_conns = max_idle_conns
        # user agent
        self.user_agent = user_agent
        # socks5 proxy
        self.socks_5proxy = socks_5proxy
        # socks5 network
        self.socks_5net_work = socks_5net_work
        # 长链接最大空闲时长
        self.max_idle_time_millis = max_idle_time_millis
        # 长链接最大连接时长
        self.keep_alive_duration_millis = keep_alive_duration_millis
        # 最大连接数（长链接最大总数）
        self.max_requests = max_requests
        # 每个目标主机的最大连接数（分主机域名的长链接最大总数
        self.max_requests_per_host = max_requests_per_host

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key_id is not None:
            result['accessKeyId'] = self.access_key_id
        if self.access_key_secret is not None:
            result['accessKeySecret'] = self.access_key_secret
        if self.security_token is not None:
            result['securityToken'] = self.security_token
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.read_timeout is not None:
            result['readTimeout'] = self.read_timeout
        if self.connect_timeout is not None:
            result['connectTimeout'] = self.connect_timeout
        if self.http_proxy is not None:
            result['httpProxy'] = self.http_proxy
        if self.https_proxy is not None:
            result['httpsProxy'] = self.https_proxy
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.no_proxy is not None:
            result['noProxy'] = self.no_proxy
        if self.max_idle_conns is not None:
            result['maxIdleConns'] = self.max_idle_conns
        if self.user_agent is not None:
            result['userAgent'] = self.user_agent
        if self.socks_5proxy is not None:
            result['socks5Proxy'] = self.socks_5proxy
        if self.socks_5net_work is not None:
            result['socks5NetWork'] = self.socks_5net_work
        if self.max_idle_time_millis is not None:
            result['maxIdleTimeMillis'] = self.max_idle_time_millis
        if self.keep_alive_duration_millis is not None:
            result['keepAliveDurationMillis'] = self.keep_alive_duration_millis
        if self.max_requests is not None:
            result['maxRequests'] = self.max_requests
        if self.max_requests_per_host is not None:
            result['maxRequestsPerHost'] = self.max_requests_per_host
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('accessKeyId') is not None:
            self.access_key_id = m.get('accessKeyId')
        if m.get('accessKeySecret') is not None:
            self.access_key_secret = m.get('accessKeySecret')
        if m.get('securityToken') is not None:
            self.security_token = m.get('securityToken')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('readTimeout') is not None:
            self.read_timeout = m.get('readTimeout')
        if m.get('connectTimeout') is not None:
            self.connect_timeout = m.get('connectTimeout')
        if m.get('httpProxy') is not None:
            self.http_proxy = m.get('httpProxy')
        if m.get('httpsProxy') is not None:
            self.https_proxy = m.get('httpsProxy')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('noProxy') is not None:
            self.no_proxy = m.get('noProxy')
        if m.get('maxIdleConns') is not None:
            self.max_idle_conns = m.get('maxIdleConns')
        if m.get('userAgent') is not None:
            self.user_agent = m.get('userAgent')
        if m.get('socks5Proxy') is not None:
            self.socks_5proxy = m.get('socks5Proxy')
        if m.get('socks5NetWork') is not None:
            self.socks_5net_work = m.get('socks5NetWork')
        if m.get('maxIdleTimeMillis') is not None:
            self.max_idle_time_millis = m.get('maxIdleTimeMillis')
        if m.get('keepAliveDurationMillis') is not None:
            self.keep_alive_duration_millis = m.get('keepAliveDurationMillis')
        if m.get('maxRequests') is not None:
            self.max_requests = m.get('maxRequests')
        if m.get('maxRequestsPerHost') is not None:
            self.max_requests_per_host = m.get('maxRequestsPerHost')
        return self


class LabelSelectorRequirement(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        values: List[str] = None,
    ):
        # label key
        self.key = key
        # label match operator
        self.operator = operator
        # label match values
        self.values = values

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.values, 'values')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.operator is not None:
            result['operator'] = self.operator
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class Label(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # label key
        self.key = key
        # label value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class LabelSelector(TeaModel):
    def __init__(
        self,
        match_expressions: List[LabelSelectorRequirement] = None,
        match_labels: List[Label] = None,
    ):
        # matchExpressions is a list of label selector requirements.
        self.match_expressions = match_expressions
        # matchLabels is a map of {key,value} pairs
        self.match_labels = match_labels

    def validate(self):
        if self.match_expressions:
            for k in self.match_expressions:
                if k:
                    k.validate()
        if self.match_labels:
            for k in self.match_labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['match_expressions'] = []
        if self.match_expressions is not None:
            for k in self.match_expressions:
                result['match_expressions'].append(k.to_map() if k else None)
        result['match_labels'] = []
        if self.match_labels is not None:
            for k in self.match_labels:
                result['match_labels'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.match_expressions = []
        if m.get('match_expressions') is not None:
            for k in m.get('match_expressions'):
                temp_model = LabelSelectorRequirement()
                self.match_expressions.append(temp_model.from_map(k))
        self.match_labels = []
        if m.get('match_labels') is not None:
            for k in m.get('match_labels'):
                temp_model = Label()
                self.match_labels.append(temp_model.from_map(k))
        return self


class NodeSelectorRequirement(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        values: List[str] = None,
    ):
        # key
        self.key = key
        # operator
        self.operator = operator
        # values
        self.values = values

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.values, 'values')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.operator is not None:
            result['operator'] = self.operator
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class NodeSelectorTerm(TeaModel):
    def __init__(
        self,
        match_expressions: List[NodeSelectorRequirement] = None,
        match_fields: List[NodeSelectorRequirement] = None,
    ):
        # A list of node selector requirements by node labels.
        # 
        self.match_expressions = match_expressions
        # A list of node selector requirements by node fields.
        # 
        self.match_fields = match_fields

    def validate(self):
        if self.match_expressions:
            for k in self.match_expressions:
                if k:
                    k.validate()
        self.validate_required(self.match_fields, 'match_fields')
        if self.match_fields:
            for k in self.match_fields:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['match_expressions'] = []
        if self.match_expressions is not None:
            for k in self.match_expressions:
                result['match_expressions'].append(k.to_map() if k else None)
        result['match_fields'] = []
        if self.match_fields is not None:
            for k in self.match_fields:
                result['match_fields'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.match_expressions = []
        if m.get('match_expressions') is not None:
            for k in m.get('match_expressions'):
                temp_model = NodeSelectorRequirement()
                self.match_expressions.append(temp_model.from_map(k))
        self.match_fields = []
        if m.get('match_fields') is not None:
            for k in m.get('match_fields'):
                temp_model = NodeSelectorRequirement()
                self.match_fields.append(temp_model.from_map(k))
        return self


class HttpGetAction(TeaModel):
    def __init__(
        self,
        path: str = None,
        port: str = None,
        scheme: str = None,
    ):
        # 健康检查url地址。
        self.path = path
        # 健康检查端口。
        self.port = port
        # 协议类型，http/https。
        self.scheme = scheme

    def validate(self):
        self.validate_required(self.path, 'path')
        self.validate_required(self.port, 'port')
        self.validate_required(self.scheme, 'scheme')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['path'] = self.path
        if self.port is not None:
            result['port'] = self.port
        if self.scheme is not None:
            result['scheme'] = self.scheme
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('scheme') is not None:
            self.scheme = m.get('scheme')
        return self


class ExecAction(TeaModel):
    def __init__(
        self,
        command: str = None,
    ):
        # 执行健康检查的命令。
        self.command = command

    def validate(self):
        self.validate_required(self.command, 'command')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['command'] = self.command
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('command') is not None:
            self.command = m.get('command')
        return self


class PodAffinityTerm(TeaModel):
    def __init__(
        self,
        label_selector: LabelSelector = None,
        namespaces: List[str] = None,
    ):
        # labelSelctor
        self.label_selector = label_selector
        # namespaces
        self.namespaces = namespaces

    def validate(self):
        self.validate_required(self.label_selector, 'label_selector')
        if self.label_selector:
            self.label_selector.validate()
        self.validate_required(self.namespaces, 'namespaces')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label_selector is not None:
            result['label_selector'] = self.label_selector.to_map()
        if self.namespaces is not None:
            result['namespaces'] = self.namespaces
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('label_selector') is not None:
            temp_model = LabelSelector()
            self.label_selector = temp_model.from_map(m['label_selector'])
        if m.get('namespaces') is not None:
            self.namespaces = m.get('namespaces')
        return self


class TcpSocketAction(TeaModel):
    def __init__(
        self,
        port: str = None,
    ):
        # 健康检查端口。
        self.port = port

    def validate(self):
        self.validate_required(self.port, 'port')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['port'] = self.port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('port') is not None:
            self.port = m.get('port')
        return self


class NodeSelector(TeaModel):
    def __init__(
        self,
        node_selector_terms: List[NodeSelectorTerm] = None,
    ):
        # node selector terms
        self.node_selector_terms = node_selector_terms

    def validate(self):
        self.validate_required(self.node_selector_terms, 'node_selector_terms')
        if self.node_selector_terms:
            for k in self.node_selector_terms:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['node_selector_terms'] = []
        if self.node_selector_terms is not None:
            for k in self.node_selector_terms:
                result['node_selector_terms'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_selector_terms = []
        if m.get('node_selector_terms') is not None:
            for k in m.get('node_selector_terms'):
                temp_model = NodeSelectorTerm()
                self.node_selector_terms.append(temp_model.from_map(k))
        return self


class ConfigmapSecretVolumeSource(TeaModel):
    def __init__(
        self,
        volume_ref_name: str = None,
    ):
        # 引用volume名称。
        self.volume_ref_name = volume_ref_name

    def validate(self):
        self.validate_required(self.volume_ref_name, 'volume_ref_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.volume_ref_name is not None:
            result['volume_ref_name'] = self.volume_ref_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('volume_ref_name') is not None:
            self.volume_ref_name = m.get('volume_ref_name')
        return self


class NFSVolumeSource(TeaModel):
    def __init__(
        self,
        path: str = None,
        server: str = None,
    ):
        # 挂载路径
        self.path = path
        # NFS 服务端地址
        self.server = server

    def validate(self):
        self.validate_required(self.path, 'path')
        self.validate_required(self.server, 'server')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['path'] = self.path
        if self.server is not None:
            result['server'] = self.server
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('server') is not None:
            self.server = m.get('server')
        return self


class PersistentVolumeClaimSource(TeaModel):
    def __init__(
        self,
        pvc_name: str = None,
    ):
        # 引用的PVC名称。
        self.pvc_name = pvc_name

    def validate(self):
        self.validate_required(self.pvc_name, 'pvc_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pvc_name is not None:
            result['pvc_name'] = self.pvc_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pvc_name') is not None:
            self.pvc_name = m.get('pvc_name')
        return self


class WeightedPodAffinityTerm(TeaModel):
    def __init__(
        self,
        pod_affinity_term: PodAffinityTerm = None,
        weight: int = None,
    ):
        # Pod Affinity Term
        self.pod_affinity_term = pod_affinity_term
        # weight
        self.weight = weight

    def validate(self):
        self.validate_required(self.pod_affinity_term, 'pod_affinity_term')
        if self.pod_affinity_term:
            self.pod_affinity_term.validate()
        self.validate_required(self.weight, 'weight')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pod_affinity_term is not None:
            result['pod_affinity_term'] = self.pod_affinity_term.to_map()
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pod_affinity_term') is not None:
            temp_model = PodAffinityTerm()
            self.pod_affinity_term = temp_model.from_map(m['pod_affinity_term'])
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class PreferredSchedulingTerm(TeaModel):
    def __init__(
        self,
        preference: NodeSelectorTerm = None,
        weight: int = None,
    ):
        # A null or empty node selector term matches no objects
        self.preference = preference
        # Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
        # 
        self.weight = weight

    def validate(self):
        if self.preference:
            self.preference.validate()
        self.validate_required(self.weight, 'weight')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.preference is not None:
            result['preference'] = self.preference.to_map()
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('preference') is not None:
            temp_model = NodeSelectorTerm()
            self.preference = temp_model.from_map(m['preference'])
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class LocalDiskVolumeSource(TeaModel):
    def __init__(
        self,
        host_directory_path: str = None,
        create_if_not_present: bool = None,
    ):
        # 主机路径。
        self.host_directory_path = host_directory_path
        # 是否允许创建。
        self.create_if_not_present = create_if_not_present

    def validate(self):
        self.validate_required(self.host_directory_path, 'host_directory_path')
        self.validate_required(self.create_if_not_present, 'create_if_not_present')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host_directory_path is not None:
            result['host_directory_path'] = self.host_directory_path
        if self.create_if_not_present is not None:
            result['create_if_not_present'] = self.create_if_not_present
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('host_directory_path') is not None:
            self.host_directory_path = m.get('host_directory_path')
        if m.get('create_if_not_present') is not None:
            self.create_if_not_present = m.get('create_if_not_present')
        return self


class EnvVarSource(TeaModel):
    def __init__(
        self,
        object_name: str = None,
        object_type: str = None,
        key: str = None,
    ):
        # 对应的ConfigMap或Secret名称。
        self.object_name = object_name
        # 对应的Object类型。
        # 取值：ConfigMap | Secret
        self.object_type = object_type
        # 引用的ConfigMap或则Secret的key。
        self.key = key

    def validate(self):
        self.validate_required(self.object_name, 'object_name')
        self.validate_required(self.object_type, 'object_type')
        self.validate_required(self.key, 'key')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.object_name is not None:
            result['object_name'] = self.object_name
        if self.object_type is not None:
            result['object_type'] = self.object_type
        if self.key is not None:
            result['key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('object_name') is not None:
            self.object_name = m.get('object_name')
        if m.get('object_type') is not None:
            self.object_type = m.get('object_type')
        if m.get('key') is not None:
            self.key = m.get('key')
        return self


class EmptyDirVolumeSource(TeaModel):
    def __init__(
        self,
        medium: str = None,
        name: str = None,
        size_limit: str = None,
    ):
        # 存储介质。
        self.medium = medium
        # volume name。
        self.name = name
        # 存储大小。
        self.size_limit = size_limit

    def validate(self):
        self.validate_required(self.medium, 'medium')
        self.validate_required(self.name, 'name')
        self.validate_required(self.size_limit, 'size_limit')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.medium is not None:
            result['medium'] = self.medium
        if self.name is not None:
            result['name'] = self.name
        if self.size_limit is not None:
            result['size_limit'] = self.size_limit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('medium') is not None:
            self.medium = m.get('medium')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('size_limit') is not None:
            self.size_limit = m.get('size_limit')
        return self


class HealthCheckProbe(TeaModel):
    def __init__(
        self,
        exec_action: ExecAction = None,
        failure_threshold: int = None,
        http_get_action: HttpGetAction = None,
        initial_delay_seconds: int = None,
        period_seconds: int = None,
        success_threshold: int = None,
        tcp_socket_action: TcpSocketAction = None,
        time_out_seconds: int = None,
    ):
        # 基于命令行类型的探针必填
        self.exec_action = exec_action
        # 探针运行失败阈值
        # 
        self.failure_threshold = failure_threshold
        # 基于HTTP GET请求的探针必填
        # 
        self.http_get_action = http_get_action
        # 探针初始运行延迟时间
        # 
        self.initial_delay_seconds = initial_delay_seconds
        # 探针运行间隔时间
        # 
        self.period_seconds = period_seconds
        # 探针运行成功阈值
        # 
        self.success_threshold = success_threshold
        # 基于TCP连接的探针必填
        # 
        self.tcp_socket_action = tcp_socket_action
        # 探针运行超时时间
        # 
        self.time_out_seconds = time_out_seconds

    def validate(self):
        if self.exec_action:
            self.exec_action.validate()
        self.validate_required(self.failure_threshold, 'failure_threshold')
        if self.http_get_action:
            self.http_get_action.validate()
        self.validate_required(self.initial_delay_seconds, 'initial_delay_seconds')
        self.validate_required(self.period_seconds, 'period_seconds')
        self.validate_required(self.success_threshold, 'success_threshold')
        if self.tcp_socket_action:
            self.tcp_socket_action.validate()
        self.validate_required(self.time_out_seconds, 'time_out_seconds')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_action is not None:
            result['exec_action'] = self.exec_action.to_map()
        if self.failure_threshold is not None:
            result['failure_threshold'] = self.failure_threshold
        if self.http_get_action is not None:
            result['http_get_action'] = self.http_get_action.to_map()
        if self.initial_delay_seconds is not None:
            result['initial_delay_seconds'] = self.initial_delay_seconds
        if self.period_seconds is not None:
            result['period_seconds'] = self.period_seconds
        if self.success_threshold is not None:
            result['success_threshold'] = self.success_threshold
        if self.tcp_socket_action is not None:
            result['tcp_socket_action'] = self.tcp_socket_action.to_map()
        if self.time_out_seconds is not None:
            result['time_out_seconds'] = self.time_out_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('exec_action') is not None:
            temp_model = ExecAction()
            self.exec_action = temp_model.from_map(m['exec_action'])
        if m.get('failure_threshold') is not None:
            self.failure_threshold = m.get('failure_threshold')
        if m.get('http_get_action') is not None:
            temp_model = HttpGetAction()
            self.http_get_action = temp_model.from_map(m['http_get_action'])
        if m.get('initial_delay_seconds') is not None:
            self.initial_delay_seconds = m.get('initial_delay_seconds')
        if m.get('period_seconds') is not None:
            self.period_seconds = m.get('period_seconds')
        if m.get('success_threshold') is not None:
            self.success_threshold = m.get('success_threshold')
        if m.get('tcp_socket_action') is not None:
            temp_model = TcpSocketAction()
            self.tcp_socket_action = temp_model.from_map(m['tcp_socket_action'])
        if m.get('time_out_seconds') is not None:
            self.time_out_seconds = m.get('time_out_seconds')
        return self


class PodAntiAffinity(TeaModel):
    def __init__(
        self,
        preferred_during_scheduling_ignored_during_execution: List[WeightedPodAffinityTerm] = None,
        required_during_scheduling_ignored_during_execution: List[PodAffinityTerm] = None,
    ):
        # The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
        self.preferred_during_scheduling_ignored_during_execution = preferred_during_scheduling_ignored_during_execution
        # If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node
        self.required_during_scheduling_ignored_during_execution = required_during_scheduling_ignored_during_execution

    def validate(self):
        if self.preferred_during_scheduling_ignored_during_execution:
            for k in self.preferred_during_scheduling_ignored_during_execution:
                if k:
                    k.validate()
        if self.required_during_scheduling_ignored_during_execution:
            for k in self.required_during_scheduling_ignored_during_execution:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['preferred_during_scheduling_ignored_during_execution'] = []
        if self.preferred_during_scheduling_ignored_during_execution is not None:
            for k in self.preferred_during_scheduling_ignored_during_execution:
                result['preferred_during_scheduling_ignored_during_execution'].append(k.to_map() if k else None)
        result['required_during_scheduling_ignored_during_execution'] = []
        if self.required_during_scheduling_ignored_during_execution is not None:
            for k in self.required_during_scheduling_ignored_during_execution:
                result['required_during_scheduling_ignored_during_execution'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.preferred_during_scheduling_ignored_during_execution = []
        if m.get('preferred_during_scheduling_ignored_during_execution') is not None:
            for k in m.get('preferred_during_scheduling_ignored_during_execution'):
                temp_model = WeightedPodAffinityTerm()
                self.preferred_during_scheduling_ignored_during_execution.append(temp_model.from_map(k))
        self.required_during_scheduling_ignored_during_execution = []
        if m.get('required_during_scheduling_ignored_during_execution') is not None:
            for k in m.get('required_during_scheduling_ignored_during_execution'):
                temp_model = PodAffinityTerm()
                self.required_during_scheduling_ignored_during_execution.append(temp_model.from_map(k))
        return self


class HPABasedElasticConfigMetricTargetResourceValue(TeaModel):
    def __init__(
        self,
        value: int = None,
        unit: str = None,
    ):
        # 数值
        self.value = value
        # 数值单位:
        # Byte, Ki, Mi, Gi, Ti, Pi
        # m, C
        self.unit = unit

    def validate(self):
        self.validate_required(self.value, 'value')
        self.validate_required(self.unit, 'unit')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        if self.unit is not None:
            result['unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('unit') is not None:
            self.unit = m.get('unit')
        return self


class FieldOverride(TeaModel):
    def __init__(
        self,
        cell: str = None,
        name: str = None,
        value: str = None,
    ):
        # 部署单元名称
        self.cell = cell
        # 字段名称
        self.name = name
        # 字段值
        self.value = value

    def validate(self):
        self.validate_required(self.cell, 'cell')
        self.validate_required(self.name, 'name')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell is not None:
            result['cell'] = self.cell
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class HPAScalePolicy(TeaModel):
    def __init__(
        self,
        type: str = None,
        value: int = None,
        period_seconds: int = None,
    ):
        # 枚举型：
        # - pods：按pod个数扩缩容；
        # - percent：基于当前副本数的百分比扩缩容。
        self.type = type
        # 当type为percent时，value值为增长副本数的百分比，900%表示在原先副本数的基础上增加9倍（单位：%）；当type为pods时，value值为增加的副本数目（单位：个）。
        self.value = value
        # 每次扩缩容动作间隔时间：600表示每10分钟操作一次
        self.period_seconds = period_seconds

    def validate(self):
        self.validate_required(self.type, 'type')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value
        if self.period_seconds is not None:
            result['period_seconds'] = self.period_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('period_seconds') is not None:
            self.period_seconds = m.get('period_seconds')
        return self


class PodAffinity(TeaModel):
    def __init__(
        self,
        preferred_during_scheduling_ignored_during_execution: List[WeightedPodAffinityTerm] = None,
        required_during_dcheduling_ignored_during_execution: List[PodAffinityTerm] = None,
    ):
        # The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions.
        self.preferred_during_scheduling_ignored_during_execution = preferred_during_scheduling_ignored_during_execution
        # f the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node.
        self.required_during_dcheduling_ignored_during_execution = required_during_dcheduling_ignored_during_execution

    def validate(self):
        if self.preferred_during_scheduling_ignored_during_execution:
            for k in self.preferred_during_scheduling_ignored_during_execution:
                if k:
                    k.validate()
        self.validate_required(self.required_during_dcheduling_ignored_during_execution, 'required_during_dcheduling_ignored_during_execution')
        if self.required_during_dcheduling_ignored_during_execution:
            for k in self.required_during_dcheduling_ignored_during_execution:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['preferred_during_scheduling_ignored_during_execution'] = []
        if self.preferred_during_scheduling_ignored_during_execution is not None:
            for k in self.preferred_during_scheduling_ignored_during_execution:
                result['preferred_during_scheduling_ignored_during_execution'].append(k.to_map() if k else None)
        result['required_during_dcheduling_ignored_during_execution'] = []
        if self.required_during_dcheduling_ignored_during_execution is not None:
            for k in self.required_during_dcheduling_ignored_during_execution:
                result['required_during_dcheduling_ignored_during_execution'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.preferred_during_scheduling_ignored_during_execution = []
        if m.get('preferred_during_scheduling_ignored_during_execution') is not None:
            for k in m.get('preferred_during_scheduling_ignored_during_execution'):
                temp_model = WeightedPodAffinityTerm()
                self.preferred_during_scheduling_ignored_during_execution.append(temp_model.from_map(k))
        self.required_during_dcheduling_ignored_during_execution = []
        if m.get('required_during_dcheduling_ignored_during_execution') is not None:
            for k in m.get('required_during_dcheduling_ignored_during_execution'):
                temp_model = PodAffinityTerm()
                self.required_during_dcheduling_ignored_during_execution.append(temp_model.from_map(k))
        return self


class LogConfigEntity(TeaModel):
    def __init__(
        self,
        config_name: str = None,
        input_type: str = None,
        logstore_name: str = None,
        log_path: str = None,
        file_pattern: str = None,
        log_sample: str = None,
        log_begin_regex: str = None,
        regex: str = None,
        docker_include_label: str = None,
        docker_exclude_label: str = None,
        file_path_blacklist: List[str] = None,
        key: List[str] = None,
    ):
        # 配置名称
        self.config_name = config_name
        # 输入类型
        self.input_type = input_type
        # 日志库名称
        self.logstore_name = logstore_name
        # 日志目录
        self.log_path = log_path
        # file_pattern
        self.file_pattern = file_pattern
        # log_sample
        self.log_sample = log_sample
        # logBeginRegex
        self.log_begin_regex = log_begin_regex
        # regex
        self.regex = regex
        # op不支持map，请传入一个可以序列化成map的字符串
        self.docker_include_label = docker_include_label
        # OP不支持map，请传入一个可以序列化的JSON
        self.docker_exclude_label = docker_exclude_label
        # file_path_blacklist
        self.file_path_blacklist = file_path_blacklist
        # 正则表达式必填，用于提取内容
        self.key = key

    def validate(self):
        self.validate_required(self.config_name, 'config_name')
        self.validate_required(self.input_type, 'input_type')
        self.validate_required(self.logstore_name, 'logstore_name')
        self.validate_required(self.log_path, 'log_path')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_name is not None:
            result['config_name'] = self.config_name
        if self.input_type is not None:
            result['input_type'] = self.input_type
        if self.logstore_name is not None:
            result['logstore_name'] = self.logstore_name
        if self.log_path is not None:
            result['log_path'] = self.log_path
        if self.file_pattern is not None:
            result['file_pattern'] = self.file_pattern
        if self.log_sample is not None:
            result['log_sample'] = self.log_sample
        if self.log_begin_regex is not None:
            result['log_begin_regex'] = self.log_begin_regex
        if self.regex is not None:
            result['regex'] = self.regex
        if self.docker_include_label is not None:
            result['docker_include_label'] = self.docker_include_label
        if self.docker_exclude_label is not None:
            result['docker_exclude_label'] = self.docker_exclude_label
        if self.file_path_blacklist is not None:
            result['file_path_blacklist'] = self.file_path_blacklist
        if self.key is not None:
            result['key'] = self.key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('config_name') is not None:
            self.config_name = m.get('config_name')
        if m.get('input_type') is not None:
            self.input_type = m.get('input_type')
        if m.get('logstore_name') is not None:
            self.logstore_name = m.get('logstore_name')
        if m.get('log_path') is not None:
            self.log_path = m.get('log_path')
        if m.get('file_pattern') is not None:
            self.file_pattern = m.get('file_pattern')
        if m.get('log_sample') is not None:
            self.log_sample = m.get('log_sample')
        if m.get('log_begin_regex') is not None:
            self.log_begin_regex = m.get('log_begin_regex')
        if m.get('regex') is not None:
            self.regex = m.get('regex')
        if m.get('docker_include_label') is not None:
            self.docker_include_label = m.get('docker_include_label')
        if m.get('docker_exclude_label') is not None:
            self.docker_exclude_label = m.get('docker_exclude_label')
        if m.get('file_path_blacklist') is not None:
            self.file_path_blacklist = m.get('file_path_blacklist')
        if m.get('key') is not None:
            self.key = m.get('key')
        return self


class NodeAffinity(TeaModel):
    def __init__(
        self,
        preferred_during_scheduling_ignored_during_execution: List[PreferredSchedulingTerm] = None,
        required_during_dcheduling_ignored_during_execution: NodeSelector = None,
    ):
        # The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions
        self.preferred_during_scheduling_ignored_during_execution = preferred_during_scheduling_ignored_during_execution
        # If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node
        self.required_during_dcheduling_ignored_during_execution = required_during_dcheduling_ignored_during_execution

    def validate(self):
        if self.preferred_during_scheduling_ignored_during_execution:
            for k in self.preferred_during_scheduling_ignored_during_execution:
                if k:
                    k.validate()
        self.validate_required(self.required_during_dcheduling_ignored_during_execution, 'required_during_dcheduling_ignored_during_execution')
        if self.required_during_dcheduling_ignored_during_execution:
            self.required_during_dcheduling_ignored_during_execution.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['preferred_during_scheduling_ignored_during_execution'] = []
        if self.preferred_during_scheduling_ignored_during_execution is not None:
            for k in self.preferred_during_scheduling_ignored_during_execution:
                result['preferred_during_scheduling_ignored_during_execution'].append(k.to_map() if k else None)
        if self.required_during_dcheduling_ignored_during_execution is not None:
            result['required_during_dcheduling_ignored_during_execution'] = self.required_during_dcheduling_ignored_during_execution.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.preferred_during_scheduling_ignored_during_execution = []
        if m.get('preferred_during_scheduling_ignored_during_execution') is not None:
            for k in m.get('preferred_during_scheduling_ignored_during_execution'):
                temp_model = PreferredSchedulingTerm()
                self.preferred_during_scheduling_ignored_during_execution.append(temp_model.from_map(k))
        if m.get('required_during_dcheduling_ignored_during_execution') is not None:
            temp_model = NodeSelector()
            self.required_during_dcheduling_ignored_during_execution = temp_model.from_map(m['required_during_dcheduling_ignored_during_execution'])
        return self


class HealthCheckConfig(TeaModel):
    def __init__(
        self,
        liveness_probe: HealthCheckProbe = None,
        readiness_probe: HealthCheckProbe = None,
    ):
        # liveness 检查
        # 
        self.liveness_probe = liveness_probe
        # readiness 检查
        # 
        self.readiness_probe = readiness_probe

    def validate(self):
        if self.liveness_probe:
            self.liveness_probe.validate()
        if self.readiness_probe:
            self.readiness_probe.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.liveness_probe is not None:
            result['liveness_probe'] = self.liveness_probe.to_map()
        if self.readiness_probe is not None:
            result['readiness_probe'] = self.readiness_probe.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('liveness_probe') is not None:
            temp_model = HealthCheckProbe()
            self.liveness_probe = temp_model.from_map(m['liveness_probe'])
        if m.get('readiness_probe') is not None:
            temp_model = HealthCheckProbe()
            self.readiness_probe = temp_model.from_map(m['readiness_probe'])
        return self


class EnvVar(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        value_from: EnvVarSource = None,
        type: str = None,
    ):
        # 环境变量名称。
        self.name = name
        # 环境变量value。
        self.value = value
        # 环境变量的取值来源。
        self.value_from = value_from
        # EnvVar类型
        self.type = type

    def validate(self):
        self.validate_required(self.name, 'name')
        if self.value_from:
            self.value_from.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        if self.value_from is not None:
            result['value_from'] = self.value_from.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('value_from') is not None:
            temp_model = EnvVarSource()
            self.value_from = temp_model.from_map(m['value_from'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class VolumeMount(TeaModel):
    def __init__(
        self,
        configmap_secret_volume_source: ConfigmapSecretVolumeSource = None,
        empty_dir_volume_source: EmptyDirVolumeSource = None,
        local_disk_volume_source: LocalDiskVolumeSource = None,
        mount_path: str = None,
        name: str = None,
        read_only: bool = None,
        sub_path: str = None,
        volume_source_category_type: str = None,
        pvc_source: PersistentVolumeClaimSource = None,
        sub_path_expr: str = None,
        nfs_volume_source: NFSVolumeSource = None,
    ):
        # 引用Configmap&Secret的存储。
        self.configmap_secret_volume_source = configmap_secret_volume_source
        # 基于empty dir的存储。
        self.empty_dir_volume_source = empty_dir_volume_source
        # 基于本地磁盘的存储资源。
        self.local_disk_volume_source = local_disk_volume_source
        # 容器内挂载路径。
        self.mount_path = mount_path
        # 引用的volume名称。
        self.name = name
        # 是否只读。
        self.read_only = read_only
        # 容器内挂载路径子路径。
        self.sub_path = sub_path
        # 数据卷类型，取值 LOCAL_STORAGE：主机挂载， CONFIGMAP：配置项， SECRET：保密字典
        self.volume_source_category_type = volume_source_category_type
        # 引用的PVC信息。
        self.pvc_source = pvc_source
        # 容器内挂载子路径的表达式，与sub_path互斥
        self.sub_path_expr = sub_path_expr
        # nfs volume
        self.nfs_volume_source = nfs_volume_source

    def validate(self):
        if self.configmap_secret_volume_source:
            self.configmap_secret_volume_source.validate()
        if self.empty_dir_volume_source:
            self.empty_dir_volume_source.validate()
        if self.local_disk_volume_source:
            self.local_disk_volume_source.validate()
        self.validate_required(self.mount_path, 'mount_path')
        self.validate_required(self.read_only, 'read_only')
        self.validate_required(self.volume_source_category_type, 'volume_source_category_type')
        if self.pvc_source:
            self.pvc_source.validate()
        if self.nfs_volume_source:
            self.nfs_volume_source.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configmap_secret_volume_source is not None:
            result['configmap_secret_volume_source'] = self.configmap_secret_volume_source.to_map()
        if self.empty_dir_volume_source is not None:
            result['empty_dir_volume_source'] = self.empty_dir_volume_source.to_map()
        if self.local_disk_volume_source is not None:
            result['local_disk_volume_source'] = self.local_disk_volume_source.to_map()
        if self.mount_path is not None:
            result['mount_path'] = self.mount_path
        if self.name is not None:
            result['name'] = self.name
        if self.read_only is not None:
            result['read_only'] = self.read_only
        if self.sub_path is not None:
            result['sub_path'] = self.sub_path
        if self.volume_source_category_type is not None:
            result['volume_source_category_type'] = self.volume_source_category_type
        if self.pvc_source is not None:
            result['pvc_source'] = self.pvc_source.to_map()
        if self.sub_path_expr is not None:
            result['sub_path_expr'] = self.sub_path_expr
        if self.nfs_volume_source is not None:
            result['nfs_volume_source'] = self.nfs_volume_source.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('configmap_secret_volume_source') is not None:
            temp_model = ConfigmapSecretVolumeSource()
            self.configmap_secret_volume_source = temp_model.from_map(m['configmap_secret_volume_source'])
        if m.get('empty_dir_volume_source') is not None:
            temp_model = EmptyDirVolumeSource()
            self.empty_dir_volume_source = temp_model.from_map(m['empty_dir_volume_source'])
        if m.get('local_disk_volume_source') is not None:
            temp_model = LocalDiskVolumeSource()
            self.local_disk_volume_source = temp_model.from_map(m['local_disk_volume_source'])
        if m.get('mount_path') is not None:
            self.mount_path = m.get('mount_path')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('read_only') is not None:
            self.read_only = m.get('read_only')
        if m.get('sub_path') is not None:
            self.sub_path = m.get('sub_path')
        if m.get('volume_source_category_type') is not None:
            self.volume_source_category_type = m.get('volume_source_category_type')
        if m.get('pvc_source') is not None:
            temp_model = PersistentVolumeClaimSource()
            self.pvc_source = temp_model.from_map(m['pvc_source'])
        if m.get('sub_path_expr') is not None:
            self.sub_path_expr = m.get('sub_path_expr')
        if m.get('nfs_volume_source') is not None:
            temp_model = NFSVolumeSource()
            self.nfs_volume_source = temp_model.from_map(m['nfs_volume_source'])
        return self


class EnvVarOverride(TeaModel):
    def __init__(
        self,
        cell: str = None,
        name: str = None,
        value: str = None,
    ):
        # 部署单元名称。
        self.cell = cell
        # 环境变量名称。
        self.name = name
        # 环境变量取值。
        self.value = value

    def validate(self):
        self.validate_required(self.cell, 'cell')
        self.validate_required(self.name, 'name')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell is not None:
            result['cell'] = self.cell
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class MapStringToString(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class LifecycleHook(TeaModel):
    def __init__(
        self,
        post_start_exec: ExecAction = None,
        post_start_http: HttpGetAction = None,
        post_start_tcp: TcpSocketAction = None,
        pre_stop_exec: ExecAction = None,
        pre_stop_http: HttpGetAction = None,
        pre_stop_tcp: TcpSocketAction = None,
    ):
        # 启动后执行命令。
        self.post_start_exec = post_start_exec
        # 启动后执行http get。
        self.post_start_http = post_start_http
        # 启动后执行TCP请求。
        self.post_start_tcp = post_start_tcp
        # 停止前执行命令。
        self.pre_stop_exec = pre_stop_exec
        # 停止前http get。
        self.pre_stop_http = pre_stop_http
        # 停止前TCP请求。
        self.pre_stop_tcp = pre_stop_tcp

    def validate(self):
        if self.post_start_exec:
            self.post_start_exec.validate()
        if self.post_start_http:
            self.post_start_http.validate()
        if self.post_start_tcp:
            self.post_start_tcp.validate()
        if self.pre_stop_exec:
            self.pre_stop_exec.validate()
        if self.pre_stop_http:
            self.pre_stop_http.validate()
        if self.pre_stop_tcp:
            self.pre_stop_tcp.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.post_start_exec is not None:
            result['post_start_exec'] = self.post_start_exec.to_map()
        if self.post_start_http is not None:
            result['post_start_http'] = self.post_start_http.to_map()
        if self.post_start_tcp is not None:
            result['post_start_tcp'] = self.post_start_tcp.to_map()
        if self.pre_stop_exec is not None:
            result['pre_stop_exec'] = self.pre_stop_exec.to_map()
        if self.pre_stop_http is not None:
            result['pre_stop_http'] = self.pre_stop_http.to_map()
        if self.pre_stop_tcp is not None:
            result['pre_stop_tcp'] = self.pre_stop_tcp.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('post_start_exec') is not None:
            temp_model = ExecAction()
            self.post_start_exec = temp_model.from_map(m['post_start_exec'])
        if m.get('post_start_http') is not None:
            temp_model = HttpGetAction()
            self.post_start_http = temp_model.from_map(m['post_start_http'])
        if m.get('post_start_tcp') is not None:
            temp_model = TcpSocketAction()
            self.post_start_tcp = temp_model.from_map(m['post_start_tcp'])
        if m.get('pre_stop_exec') is not None:
            temp_model = ExecAction()
            self.pre_stop_exec = temp_model.from_map(m['pre_stop_exec'])
        if m.get('pre_stop_http') is not None:
            temp_model = HttpGetAction()
            self.pre_stop_http = temp_model.from_map(m['pre_stop_http'])
        if m.get('pre_stop_tcp') is not None:
            temp_model = TcpSocketAction()
            self.pre_stop_tcp = temp_model.from_map(m['pre_stop_tcp'])
        return self


class PodDNSConfigOption(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
    ):
        # name
        self.name = name
        # value
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class PodAffinityTermEntity(TeaModel):
    def __init__(
        self,
        label_selector: List[MapStringToString] = None,
        namespaces: List[str] = None,
        topology_key: str = None,
    ):
        # label_selector
        self.label_selector = label_selector
        # namespaces
        self.namespaces = namespaces
        # topology_key
        self.topology_key = topology_key

    def validate(self):
        if self.label_selector:
            for k in self.label_selector:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['label_selector'] = []
        if self.label_selector is not None:
            for k in self.label_selector:
                result['label_selector'].append(k.to_map() if k else None)
        if self.namespaces is not None:
            result['namespaces'] = self.namespaces
        if self.topology_key is not None:
            result['topology_key'] = self.topology_key
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.label_selector = []
        if m.get('label_selector') is not None:
            for k in m.get('label_selector'):
                temp_model = MapStringToString()
                self.label_selector.append(temp_model.from_map(k))
        if m.get('namespaces') is not None:
            self.namespaces = m.get('namespaces')
        if m.get('topology_key') is not None:
            self.topology_key = m.get('topology_key')
        return self


class MatchExpression(TeaModel):
    def __init__(
        self,
        key: str = None,
        operator: str = None,
        values: List[str] = None,
    ):
        # key
        self.key = key
        # operator
        self.operator = operator
        # values
        self.values = values

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.operator is not None:
            result['operator'] = self.operator
        if self.values is not None:
            result['values'] = self.values
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('values') is not None:
            self.values = m.get('values')
        return self


class Toleration(TeaModel):
    def __init__(
        self,
        effect: str = None,
        key: str = None,
        operator: str = None,
        toleration_seconds: int = None,
        value: str = None,
    ):
        # 取值：NoExecute、PreferNoSchedule、NoSchedule
        self.effect = effect
        # Key is the taint key that the toleration applies to.
        self.key = key
        # 取值：Equal、Exists
        self.operator = operator
        # TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint.
        self.toleration_seconds = toleration_seconds
        # Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        self.value = value

    def validate(self):
        self.validate_required(self.effect, 'effect')
        self.validate_required(self.key, 'key')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.effect is not None:
            result['effect'] = self.effect
        if self.key is not None:
            result['key'] = self.key
        if self.operator is not None:
            result['operator'] = self.operator
        if self.toleration_seconds is not None:
            result['toleration_seconds'] = self.toleration_seconds
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('effect') is not None:
            self.effect = m.get('effect')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('toleration_seconds') is not None:
            self.toleration_seconds = m.get('toleration_seconds')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ContainerStateRunning(TeaModel):
    def __init__(
        self,
        started_at: str = None,
    ):
        # container启动时间
        self.started_at = started_at

    def validate(self):
        self.validate_required(self.started_at, 'started_at')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.started_at is not None:
            result['started_at'] = self.started_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('started_at') is not None:
            self.started_at = m.get('started_at')
        return self


class Annotation(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # annotation key
        self.key = key
        # annotation value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ContainerSpec(TeaModel):
    def __init__(
        self,
        cpu_limit: str = None,
        cpu_request: str = None,
        entry_points: List[str] = None,
        envs: List[EnvVar] = None,
        env_overrides: List[EnvVarOverride] = None,
        health_check_config: HealthCheckConfig = None,
        image: str = None,
        image_build_name: str = None,
        image_pull_secret: str = None,
        image_source: str = None,
        lifecycle_hook: LifecycleHook = None,
        log_configs: List[LogConfigEntity] = None,
        memory_limit: str = None,
        memory_request: str = None,
        name: str = None,
        restart_policy: str = None,
        type: str = None,
        volume_mounts: List[VolumeMount] = None,
        volume_mounts_str: str = None,
        volumes_str: str = None,
        field_overrides: List[FieldOverride] = None,
        yaml_content: str = None,
    ):
        # 最大CPU限制，格式 1/1m。
        self.cpu_limit = cpu_limit
        # 最少需要的CPU核数，格式 1/1m。
        self.cpu_request = cpu_request
        # 启动命令。
        self.entry_points = entry_points
        # 环境变量。
        self.envs = envs
        # 容器环境变量配置覆盖。
        self.env_overrides = env_overrides
        # 健康检查配置
        # 
        self.health_check_config = health_check_config
        # 地址，格式形如 repository:tag。
        self.image = image
        # 镜像构建名。
        self.image_build_name = image_build_name
        # image pull secret
        self.image_pull_secret = image_pull_secret
        # 镜像来源，构建/普通镜像。
        self.image_source = image_source
        # 生命周期钩子。
        self.lifecycle_hook = lifecycle_hook
        # 日志服务配置
        self.log_configs = log_configs
        # 最大内存限制，单位 Byte/Ki/Mi/Gi/Ti/Pi。
        self.memory_limit = memory_limit
        # 最小需要的内存大小，单位 Byte/Ki/Mi/Gi/Ti/Pi。
        self.memory_request = memory_request
        # 容器名称。
        self.name = name
        # 重启策略。
        self.restart_policy = restart_policy
        # 容器类型。
        self.type = type
        # 存储卷
        # 
        self.volume_mounts = volume_mounts
        # volumeMountV2, json格式，方便扩展, 与volumes_str搭配使用，启用后废弃volume_mount字段
        # {
        # "volumeMounts": [{
        # "mountPath": "/container/config",
        # "name": "aarm-base-configmap-volume",
        # "readOnly": true
        # }, {
        # "mountPath": "/container/scrt",
        # "name": "panling-secret-volume",
        # "readOnly": true
        # }, {
        # "mountPath": "/container/pvc",
        # "name": "afa-public-data-pv",
        # "readOnly": true
        # }, {
        # "mountPath": "/container/local",
        # "name": "container-local-host-volume",
        # "readOnly": true
        # }]
        # }
        # 这里会兼容原来OpenAPI传过来的volume_mount字段
        self.volume_mounts_str = volume_mounts_str
        # 与volume_mounts_str搭配使用，描述pod的volume部分
        # {
        # "volumes": [{
        # "configMap": {
        # "defaultMode": 256,
        # "name": "aarm-base"
        # },
        # "name": "aarm-base-configmap-volume"
        # },
        # {
        # "name": "panling-secret-volume",
        # "secret": {
        # "defaultMode": 256,
        # "secretName": "panling"
        # }
        # },
        # {
        # "name": "afa-public-data-pv",
        # "persistentVolumeClaim": {
        # "claimName": "afa-public-data"
        # }
        # },
        # {
        # "hostPath": {
        # "path": "/local"
        # },
        # "name": "container-local-host-volume"
        # }
        # ]
        # }
        self.volumes_str = volumes_str
        # 基础字段覆盖
        self.field_overrides = field_overrides
        # 容器yaml内容
        self.yaml_content = yaml_content

    def validate(self):
        self.validate_required(self.cpu_limit, 'cpu_limit')
        self.validate_required(self.cpu_request, 'cpu_request')
        if self.envs:
            for k in self.envs:
                if k:
                    k.validate()
        if self.env_overrides:
            for k in self.env_overrides:
                if k:
                    k.validate()
        if self.health_check_config:
            self.health_check_config.validate()
        self.validate_required(self.image, 'image')
        self.validate_required(self.image_source, 'image_source')
        if self.lifecycle_hook:
            self.lifecycle_hook.validate()
        if self.log_configs:
            for k in self.log_configs:
                if k:
                    k.validate()
        self.validate_required(self.memory_limit, 'memory_limit')
        self.validate_required(self.memory_request, 'memory_request')
        self.validate_required(self.name, 'name')
        self.validate_required(self.restart_policy, 'restart_policy')
        self.validate_required(self.type, 'type')
        if self.volume_mounts:
            for k in self.volume_mounts:
                if k:
                    k.validate()
        if self.field_overrides:
            for k in self.field_overrides:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_limit is not None:
            result['cpu_limit'] = self.cpu_limit
        if self.cpu_request is not None:
            result['cpu_request'] = self.cpu_request
        if self.entry_points is not None:
            result['entry_points'] = self.entry_points
        result['envs'] = []
        if self.envs is not None:
            for k in self.envs:
                result['envs'].append(k.to_map() if k else None)
        result['env_overrides'] = []
        if self.env_overrides is not None:
            for k in self.env_overrides:
                result['env_overrides'].append(k.to_map() if k else None)
        if self.health_check_config is not None:
            result['health_check_config'] = self.health_check_config.to_map()
        if self.image is not None:
            result['image'] = self.image
        if self.image_build_name is not None:
            result['image_build_name'] = self.image_build_name
        if self.image_pull_secret is not None:
            result['image_pull_secret'] = self.image_pull_secret
        if self.image_source is not None:
            result['image_source'] = self.image_source
        if self.lifecycle_hook is not None:
            result['lifecycle_hook'] = self.lifecycle_hook.to_map()
        result['log_configs'] = []
        if self.log_configs is not None:
            for k in self.log_configs:
                result['log_configs'].append(k.to_map() if k else None)
        if self.memory_limit is not None:
            result['memory_limit'] = self.memory_limit
        if self.memory_request is not None:
            result['memory_request'] = self.memory_request
        if self.name is not None:
            result['name'] = self.name
        if self.restart_policy is not None:
            result['restart_policy'] = self.restart_policy
        if self.type is not None:
            result['type'] = self.type
        result['volume_mounts'] = []
        if self.volume_mounts is not None:
            for k in self.volume_mounts:
                result['volume_mounts'].append(k.to_map() if k else None)
        if self.volume_mounts_str is not None:
            result['volume_mounts_str'] = self.volume_mounts_str
        if self.volumes_str is not None:
            result['volumes_str'] = self.volumes_str
        result['field_overrides'] = []
        if self.field_overrides is not None:
            for k in self.field_overrides:
                result['field_overrides'].append(k.to_map() if k else None)
        if self.yaml_content is not None:
            result['yaml_content'] = self.yaml_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cpu_limit') is not None:
            self.cpu_limit = m.get('cpu_limit')
        if m.get('cpu_request') is not None:
            self.cpu_request = m.get('cpu_request')
        if m.get('entry_points') is not None:
            self.entry_points = m.get('entry_points')
        self.envs = []
        if m.get('envs') is not None:
            for k in m.get('envs'):
                temp_model = EnvVar()
                self.envs.append(temp_model.from_map(k))
        self.env_overrides = []
        if m.get('env_overrides') is not None:
            for k in m.get('env_overrides'):
                temp_model = EnvVarOverride()
                self.env_overrides.append(temp_model.from_map(k))
        if m.get('health_check_config') is not None:
            temp_model = HealthCheckConfig()
            self.health_check_config = temp_model.from_map(m['health_check_config'])
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('image_build_name') is not None:
            self.image_build_name = m.get('image_build_name')
        if m.get('image_pull_secret') is not None:
            self.image_pull_secret = m.get('image_pull_secret')
        if m.get('image_source') is not None:
            self.image_source = m.get('image_source')
        if m.get('lifecycle_hook') is not None:
            temp_model = LifecycleHook()
            self.lifecycle_hook = temp_model.from_map(m['lifecycle_hook'])
        self.log_configs = []
        if m.get('log_configs') is not None:
            for k in m.get('log_configs'):
                temp_model = LogConfigEntity()
                self.log_configs.append(temp_model.from_map(k))
        if m.get('memory_limit') is not None:
            self.memory_limit = m.get('memory_limit')
        if m.get('memory_request') is not None:
            self.memory_request = m.get('memory_request')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('restart_policy') is not None:
            self.restart_policy = m.get('restart_policy')
        if m.get('type') is not None:
            self.type = m.get('type')
        self.volume_mounts = []
        if m.get('volume_mounts') is not None:
            for k in m.get('volume_mounts'):
                temp_model = VolumeMount()
                self.volume_mounts.append(temp_model.from_map(k))
        if m.get('volume_mounts_str') is not None:
            self.volume_mounts_str = m.get('volume_mounts_str')
        if m.get('volumes_str') is not None:
            self.volumes_str = m.get('volumes_str')
        self.field_overrides = []
        if m.get('field_overrides') is not None:
            for k in m.get('field_overrides'):
                temp_model = FieldOverride()
                self.field_overrides.append(temp_model.from_map(k))
        if m.get('yaml_content') is not None:
            self.yaml_content = m.get('yaml_content')
        return self


class HPABasedElasticConfigMetricTarget(TeaModel):
    def __init__(
        self,
        type: str = None,
        value: HPABasedElasticConfigMetricTargetResourceValue = None,
        utilization: int = None,
    ):
        # 支持两种类型：AverageValue，Utilization
        self.type = type
        # value
        self.value = value
        # 利用率
        self.utilization = utilization

    def validate(self):
        self.validate_required(self.type, 'type')
        if self.value:
            self.value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.value is not None:
            result['value'] = self.value.to_map()
        if self.utilization is not None:
            result['utilization'] = self.utilization
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('value') is not None:
            temp_model = HPABasedElasticConfigMetricTargetResourceValue()
            self.value = temp_model.from_map(m['value'])
        if m.get('utilization') is not None:
            self.utilization = m.get('utilization')
        return self


class PodReadinessGate(TeaModel):
    def __init__(
        self,
        condition_type: str = None,
    ):
        # ConditionType refers to a condition in the pod_s condition list with matching type.
        self.condition_type = condition_type

    def validate(self):
        self.validate_required(self.condition_type, 'condition_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.condition_type is not None:
            result['condition_type'] = self.condition_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('condition_type') is not None:
            self.condition_type = m.get('condition_type')
        return self


class HPAScaleRule(TeaModel):
    def __init__(
        self,
        stabilization_window_seconds: int = None,
        policies: List[HPAScalePolicy] = None,
    ):
        # 冷却窗口时间
        self.stabilization_window_seconds = stabilization_window_seconds
        # 扩缩容策略
        self.policies = policies

    def validate(self):
        if self.policies:
            for k in self.policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.stabilization_window_seconds is not None:
            result['stabilization_window_seconds'] = self.stabilization_window_seconds
        result['policies'] = []
        if self.policies is not None:
            for k in self.policies:
                result['policies'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('stabilization_window_seconds') is not None:
            self.stabilization_window_seconds = m.get('stabilization_window_seconds')
        self.policies = []
        if m.get('policies') is not None:
            for k in m.get('policies'):
                temp_model = HPAScalePolicy()
                self.policies.append(temp_model.from_map(k))
        return self


class Affinity(TeaModel):
    def __init__(
        self,
        node_affinity: NodeAffinity = None,
        pod_affinity: PodAffinity = None,
        pod_anti_affinity: PodAntiAffinity = None,
    ):
        # Describes node affinity scheduling rules for the pod.
        # 
        self.node_affinity = node_affinity
        # Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
        self.pod_affinity = pod_affinity
        # Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
        # 
        self.pod_anti_affinity = pod_anti_affinity

    def validate(self):
        if self.node_affinity:
            self.node_affinity.validate()
        if self.pod_affinity:
            self.pod_affinity.validate()
        if self.pod_anti_affinity:
            self.pod_anti_affinity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.node_affinity is not None:
            result['node_affinity'] = self.node_affinity.to_map()
        if self.pod_affinity is not None:
            result['pod_affinity'] = self.pod_affinity.to_map()
        if self.pod_anti_affinity is not None:
            result['pod_anti_affinity'] = self.pod_anti_affinity.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('node_affinity') is not None:
            temp_model = NodeAffinity()
            self.node_affinity = temp_model.from_map(m['node_affinity'])
        if m.get('pod_affinity') is not None:
            temp_model = PodAffinity()
            self.pod_affinity = temp_model.from_map(m['pod_affinity'])
        if m.get('pod_anti_affinity') is not None:
            temp_model = PodAntiAffinity()
            self.pod_anti_affinity = temp_model.from_map(m['pod_anti_affinity'])
        return self


class ContainerStateTerminated(TeaModel):
    def __init__(
        self,
        container_id: str = None,
        exit_code: int = None,
        finished_at: str = None,
        message: str = None,
        reason: str = None,
        signal: str = None,
        started_at: str = None,
    ):
        # container id
        self.container_id = container_id
        # exit code
        self.exit_code = exit_code
        # container结束时间
        self.finished_at = finished_at
        # message
        self.message = message
        # reason
        self.reason = reason
        # signal
        self.signal = signal
        # container start time
        self.started_at = started_at

    def validate(self):
        self.validate_required(self.container_id, 'container_id')
        self.validate_required(self.exit_code, 'exit_code')
        self.validate_required(self.finished_at, 'finished_at')
        self.validate_required(self.message, 'message')
        self.validate_required(self.reason, 'reason')
        self.validate_required(self.signal, 'signal')
        self.validate_required(self.started_at, 'started_at')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['container_id'] = self.container_id
        if self.exit_code is not None:
            result['exit_code'] = self.exit_code
        if self.finished_at is not None:
            result['finished_at'] = self.finished_at
        if self.message is not None:
            result['message'] = self.message
        if self.reason is not None:
            result['reason'] = self.reason
        if self.signal is not None:
            result['signal'] = self.signal
        if self.started_at is not None:
            result['started_at'] = self.started_at
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('container_id') is not None:
            self.container_id = m.get('container_id')
        if m.get('exit_code') is not None:
            self.exit_code = m.get('exit_code')
        if m.get('finished_at') is not None:
            self.finished_at = m.get('finished_at')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('signal') is not None:
            self.signal = m.get('signal')
        if m.get('started_at') is not None:
            self.started_at = m.get('started_at')
        return self


class ResourceValue(TeaModel):
    def __init__(
        self,
        value: int = None,
        unit: str = None,
    ):
        # value
        self.value = value
        # Ki、Mi、Gi、Ti、Pi、m、c
        self.unit = unit

    def validate(self):
        self.validate_required(self.value, 'value')
        self.validate_required(self.unit, 'unit')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        if self.unit is not None:
            result['unit'] = self.unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('unit') is not None:
            self.unit = m.get('unit')
        return self


class HostAlias(TeaModel):
    def __init__(
        self,
        hostnames: List[str] = None,
        ip: str = None,
    ):
        # Hostnames for the above IP address.
        self.hostnames = hostnames
        # IP address of the host file entry.
        # 
        self.ip = ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hostnames is not None:
            result['hostnames'] = self.hostnames
        if self.ip is not None:
            result['ip'] = self.ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hostnames') is not None:
            self.hostnames = m.get('hostnames')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        return self


class PodDNSConfig(TeaModel):
    def __init__(
        self,
        nameservers: List[str] = None,
        options: List[PodDNSConfigOption] = None,
        searches: List[str] = None,
    ):
        # A list of DNS name server IP addresses
        self.nameservers = nameservers
        # A list of DNS resolver options.
        self.options = options
        # A list of DNS search domains for host-name lookup
        self.searches = searches

    def validate(self):
        if self.options:
            for k in self.options:
                if k:
                    k.validate()
        self.validate_required(self.searches, 'searches')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nameservers is not None:
            result['nameservers'] = self.nameservers
        result['options'] = []
        if self.options is not None:
            for k in self.options:
                result['options'].append(k.to_map() if k else None)
        if self.searches is not None:
            result['searches'] = self.searches
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('nameservers') is not None:
            self.nameservers = m.get('nameservers')
        self.options = []
        if m.get('options') is not None:
            for k in m.get('options'):
                temp_model = PodDNSConfigOption()
                self.options.append(temp_model.from_map(k))
        if m.get('searches') is not None:
            self.searches = m.get('searches')
        return self


class Volume(TeaModel):
    def __init__(
        self,
        host_path: str = None,
        name: str = None,
        ref_resource_name: str = None,
        type: str = None,
        read_only: bool = None,
    ):
        # 主机目录[仅针对HostPath类型volume有效]
        self.host_path = host_path
        # Volume名称。
        self.name = name
        # 关联的资源名称。
        self.ref_resource_name = ref_resource_name
        # LOCAL_STORAGE：主机挂载|CONFIGMAP：配置项|SECRET：保密字典
        self.type = type
        # Volume是否只读
        self.read_only = read_only

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host_path is not None:
            result['host_path'] = self.host_path
        if self.name is not None:
            result['name'] = self.name
        if self.ref_resource_name is not None:
            result['ref_resource_name'] = self.ref_resource_name
        if self.type is not None:
            result['type'] = self.type
        if self.read_only is not None:
            result['read_only'] = self.read_only
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('host_path') is not None:
            self.host_path = m.get('host_path')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ref_resource_name') is not None:
            self.ref_resource_name = m.get('ref_resource_name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('read_only') is not None:
            self.read_only = m.get('read_only')
        return self


class PodNodeSelector(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class ContainerStateWaiting(TeaModel):
    def __init__(
        self,
        message: str = None,
        reason: str = None,
    ):
        # message
        self.message = message
        # reason
        self.reason = reason

    def validate(self):
        self.validate_required(self.message, 'message')
        self.validate_required(self.reason, 'reason')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['message'] = self.message
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class PodDetailInfo(TeaModel):
    def __init__(
        self,
        cluster: str = None,
        created_time: str = None,
        finalizers: List[str] = None,
        lifecycle_stage: str = None,
        name: str = None,
        namespace: str = None,
        pod_ip: str = None,
        revision: str = None,
        status: str = None,
        uid: str = None,
        message: str = None,
    ):
        # 集群名称
        # 
        self.cluster = cluster
        # pod created time
        self.created_time = created_time
        # 已经具备的finalizers
        self.finalizers = finalizers
        # pod的生命周期当前阶段
        self.lifecycle_stage = lifecycle_stage
        # pod name
        self.name = name
        # pod namespace
        self.namespace = namespace
        # pod ip
        self.pod_ip = pod_ip
        # pod的版本
        self.revision = revision
        # pod status
        self.status = status
        # pod uid
        self.uid = uid
        # 描述Pod当前状态的信息
        self.message = message

    def validate(self):
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.created_time, 'created_time')
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.pod_ip, 'pod_ip')
        self.validate_required(self.status, 'status')
        self.validate_required(self.message, 'message')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.finalizers is not None:
            result['finalizers'] = self.finalizers
        if self.lifecycle_stage is not None:
            result['lifecycle_stage'] = self.lifecycle_stage
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.pod_ip is not None:
            result['pod_ip'] = self.pod_ip
        if self.revision is not None:
            result['revision'] = self.revision
        if self.status is not None:
            result['status'] = self.status
        if self.uid is not None:
            result['uid'] = self.uid
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('finalizers') is not None:
            self.finalizers = m.get('finalizers')
        if m.get('lifecycle_stage') is not None:
            self.lifecycle_stage = m.get('lifecycle_stage')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('pod_ip') is not None:
            self.pod_ip = m.get('pod_ip')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class RollingUpdateDeployment(TeaModel):
    def __init__(
        self,
        max_surge: str = None,
        max_unavailable: str = None,
    ):
        # The maximum number of pods that can be scheduled above the desired number of pods.
        self.max_surge = max_surge
        # The maximum number of pods that can be unavailable during the update.
        self.max_unavailable = max_unavailable

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_surge is not None:
            result['max_surge'] = self.max_surge
        if self.max_unavailable is not None:
            result['max_unavailable'] = self.max_unavailable
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('max_surge') is not None:
            self.max_surge = m.get('max_surge')
        if m.get('max_unavailable') is not None:
            self.max_unavailable = m.get('max_unavailable')
        return self


class HPAScaleBehavior(TeaModel):
    def __init__(
        self,
        scale_up: HPAScaleRule = None,
        scale_down: HPAScaleRule = None,
    ):
        # 扩容高级规则
        self.scale_up = scale_up
        # 缩容高级规则
        self.scale_down = scale_down

    def validate(self):
        if self.scale_up:
            self.scale_up.validate()
        if self.scale_down:
            self.scale_down.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scale_up is not None:
            result['scale_up'] = self.scale_up.to_map()
        if self.scale_down is not None:
            result['scale_down'] = self.scale_down.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('scale_up') is not None:
            temp_model = HPAScaleRule()
            self.scale_up = temp_model.from_map(m['scale_up'])
        if m.get('scale_down') is not None:
            temp_model = HPAScaleRule()
            self.scale_down = temp_model.from_map(m['scale_down'])
        return self


class MapResourceNameToValue(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: ResourceValue = None,
    ):
        # key
        self.key = key
        # value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')
        if self.value:
            self.value.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            temp_model = ResourceValue()
            self.value = temp_model.from_map(m['value'])
        return self


class LoadBalancerListener(TeaModel):
    def __init__(
        self,
        backend_server_port: int = None,
        band_width: int = None,
        ca_certificate_id: str = None,
        cookie: str = None,
        cookie_timeout: int = None,
        established_timeout: int = None,
        healthy_threshold: int = None,
        health_check: str = None,
        health_check_connect_port: int = None,
        health_check_connect_timeout: int = None,
        health_check_domain: str = None,
        health_check_http_method: str = None,
        health_check_http_code: str = None,
        health_check_interval: int = None,
        health_check_threshold: int = None,
        health_check_timeout: int = None,
        health_check_uri: str = None,
        listener_port: int = None,
        persistence_timeout: int = None,
        protocol: str = None,
        scheduler: str = None,
        session_sticky_type: int = None,
        unhealthy_threshold: int = None,
        xforward_for: bool = None,
        domain: str = None,
        path: str = None,
        acl_status: str = None,
        acl_type: str = None,
        acl_id: str = None,
    ):
        # 负载均衡实例后端使用的端口。
        # 取值：1-65535。
        self.backend_server_port = backend_server_port
        # 监听的带宽峰值，取值：
        # -1：不限制带宽峰值。
        # 1~5120：监听的带宽峰值，所有监听的带宽峰值之和不能超过实例的带宽峰值。
        self.band_width = band_width
        # CA证书ID。
        # 若既上传CA证书又上传服务器证书，即采用双向认证。
        # 若用户只上传服务器证书，即为单向认证。
        self.ca_certificate_id = ca_certificate_id
        # 服务器上配置的Cookie。
        # 长度为1~200个字符，只能包含ASCII英文字母和数字字符，不能包含逗号、分号或空格，也不能以开头。
        self.cookie = cookie
        # Cookie超时时间
        self.cookie_timeout = cookie_timeout
        # 连接超时时间（秒）
        self.established_timeout = established_timeout
        # 健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success。
        # 取值: 2-10。
        self.healthy_threshold = healthy_threshold
        # 是否开启健康检查。
        # 取值：ON | OFF。
        self.health_check = health_check
        # 健康检查端口。
        self.health_check_connect_port = health_check_connect_port
        # 健康检查链接超时时间。
        self.health_check_connect_timeout = health_check_connect_timeout
        # 用于健康检查的域名。取值：
        # ip： 后端服务器的私网IP。当指定了IP或该参数未指定时，负载均衡会使用各后端服务器的私网IP当做健康检查使用的域名。
        # domain：域名长度为1-80，只能包含字母、数字、点号（.）和连字符（-）。
        self.health_check_domain = health_check_domain
        # 健康检查http method，支持head和get
        self.health_check_http_method = health_check_http_method
        # 健康检查正常的HTTP状态码，多个状态码用逗号分隔。
        # 默认值为http_2xx。
        self.health_check_http_code = health_check_http_code
        # 健康检查的时间间隔。
        # 取值:1-50（秒）。
        self.health_check_interval = health_check_interval
        # 健康检查threshold。
        self.health_check_threshold = health_check_threshold
        # 接收来自运行状况检查的响应需要等待的时间。如果后端ECS在指定的时间内没有正确响应，则判定为健康检查失败。
        # 取值：1-300（秒）。
        self.health_check_timeout = health_check_timeout
        # 用于健康检查的URI。
        # 当TCP监听需要使用HTTP健康检查时可配置此参数，如不配置则按TCP健康检查。
        self.health_check_uri = health_check_uri
        # 负载均衡实例前端使用的端口。
        # 取值：1-65535。
        self.listener_port = listener_port
        # TCP 会话保持的超时时间（秒）
        self.persistence_timeout = persistence_timeout
        # 监听使用协议。
        self.protocol = protocol
        # 负载均衡策略（RR 轮询 | WLC 最小连接数）
        self.scheduler = scheduler
        # 0不开会话保持 / 1植入Cookie / 2重写Cookie。
        # 开启会话保持功能后，负载均衡会把来自同一客户端的访问请求分发到同一台后端服务器上进行处理。
        # HTTP协议会话保持基于Cookie。负载均衡提供了两种Cookie处理方式：
        # 植入Cookie：您只需要指定Cookie的过期时间。
        # 客户端第一次访问时，负载均衡会在返回请求中植入Cookie（即在HTTP/HTTPS响应报文中插入SERVERID），下次客户端携带此Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器上。
        # 重写Cookie：可以根据需要指定HTTPS/HTTP响应中插入的Cookie。您需要在后端服务器上维护该Cookie的过期时间和生存时间。
        # 负载均衡服务发现用户自定义了Cookie，将会对原来的Cookie进行重写，下次客户端携带新的Cookie访问，负载均衡服务会将请求定向转发给之前记录到的后端服务器
        self.session_sticky_type = session_sticky_type
        # 健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail。
        # 取值：2-10。
        self.unhealthy_threshold = unhealthy_threshold
        # 是否开启通过 X-Forwarded-For 的方式获取来访者真实 IP
        self.xforward_for = xforward_for
        # 统一接入域名
        self.domain = domain
        # 统一接入转发路径
        self.path = path
        # on 代表开启 acl，off 代表关闭 acl
        self.acl_status = acl_status
        # acl 类型，white 代表白名单；black 代表黑名单
        self.acl_type = acl_type
        # 访问控制列表的 id
        self.acl_id = acl_id

    def validate(self):
        self.validate_required(self.backend_server_port, 'backend_server_port')
        self.validate_required(self.session_sticky_type, 'session_sticky_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_server_port is not None:
            result['backend_server_port'] = self.backend_server_port
        if self.band_width is not None:
            result['band_width'] = self.band_width
        if self.ca_certificate_id is not None:
            result['ca_certificate_id'] = self.ca_certificate_id
        if self.cookie is not None:
            result['cookie'] = self.cookie
        if self.cookie_timeout is not None:
            result['cookie_timeout'] = self.cookie_timeout
        if self.established_timeout is not None:
            result['established_timeout'] = self.established_timeout
        if self.healthy_threshold is not None:
            result['healthy_threshold'] = self.healthy_threshold
        if self.health_check is not None:
            result['health_check'] = self.health_check
        if self.health_check_connect_port is not None:
            result['health_check_connect_port'] = self.health_check_connect_port
        if self.health_check_connect_timeout is not None:
            result['health_check_connect_timeout'] = self.health_check_connect_timeout
        if self.health_check_domain is not None:
            result['health_check_domain'] = self.health_check_domain
        if self.health_check_http_method is not None:
            result['health_check_http_method'] = self.health_check_http_method
        if self.health_check_http_code is not None:
            result['health_check_http_code'] = self.health_check_http_code
        if self.health_check_interval is not None:
            result['health_check_interval'] = self.health_check_interval
        if self.health_check_threshold is not None:
            result['health_check_threshold'] = self.health_check_threshold
        if self.health_check_timeout is not None:
            result['health_check_timeout'] = self.health_check_timeout
        if self.health_check_uri is not None:
            result['health_check_uri'] = self.health_check_uri
        if self.listener_port is not None:
            result['listener_port'] = self.listener_port
        if self.persistence_timeout is not None:
            result['persistence_timeout'] = self.persistence_timeout
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.scheduler is not None:
            result['scheduler'] = self.scheduler
        if self.session_sticky_type is not None:
            result['session_sticky_type'] = self.session_sticky_type
        if self.unhealthy_threshold is not None:
            result['unhealthy_threshold'] = self.unhealthy_threshold
        if self.xforward_for is not None:
            result['xforward_for'] = self.xforward_for
        if self.domain is not None:
            result['domain'] = self.domain
        if self.path is not None:
            result['path'] = self.path
        if self.acl_status is not None:
            result['acl_status'] = self.acl_status
        if self.acl_type is not None:
            result['acl_type'] = self.acl_type
        if self.acl_id is not None:
            result['acl_id'] = self.acl_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('backend_server_port') is not None:
            self.backend_server_port = m.get('backend_server_port')
        if m.get('band_width') is not None:
            self.band_width = m.get('band_width')
        if m.get('ca_certificate_id') is not None:
            self.ca_certificate_id = m.get('ca_certificate_id')
        if m.get('cookie') is not None:
            self.cookie = m.get('cookie')
        if m.get('cookie_timeout') is not None:
            self.cookie_timeout = m.get('cookie_timeout')
        if m.get('established_timeout') is not None:
            self.established_timeout = m.get('established_timeout')
        if m.get('healthy_threshold') is not None:
            self.healthy_threshold = m.get('healthy_threshold')
        if m.get('health_check') is not None:
            self.health_check = m.get('health_check')
        if m.get('health_check_connect_port') is not None:
            self.health_check_connect_port = m.get('health_check_connect_port')
        if m.get('health_check_connect_timeout') is not None:
            self.health_check_connect_timeout = m.get('health_check_connect_timeout')
        if m.get('health_check_domain') is not None:
            self.health_check_domain = m.get('health_check_domain')
        if m.get('health_check_http_method') is not None:
            self.health_check_http_method = m.get('health_check_http_method')
        if m.get('health_check_http_code') is not None:
            self.health_check_http_code = m.get('health_check_http_code')
        if m.get('health_check_interval') is not None:
            self.health_check_interval = m.get('health_check_interval')
        if m.get('health_check_threshold') is not None:
            self.health_check_threshold = m.get('health_check_threshold')
        if m.get('health_check_timeout') is not None:
            self.health_check_timeout = m.get('health_check_timeout')
        if m.get('health_check_uri') is not None:
            self.health_check_uri = m.get('health_check_uri')
        if m.get('listener_port') is not None:
            self.listener_port = m.get('listener_port')
        if m.get('persistence_timeout') is not None:
            self.persistence_timeout = m.get('persistence_timeout')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('scheduler') is not None:
            self.scheduler = m.get('scheduler')
        if m.get('session_sticky_type') is not None:
            self.session_sticky_type = m.get('session_sticky_type')
        if m.get('unhealthy_threshold') is not None:
            self.unhealthy_threshold = m.get('unhealthy_threshold')
        if m.get('xforward_for') is not None:
            self.xforward_for = m.get('xforward_for')
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('acl_status') is not None:
            self.acl_status = m.get('acl_status')
        if m.get('acl_type') is not None:
            self.acl_type = m.get('acl_type')
        if m.get('acl_id') is not None:
            self.acl_id = m.get('acl_id')
        return self


class ReplicaCount(TeaModel):
    def __init__(
        self,
        type: str = None,
        name: str = None,
        count: int = None,
        original_count: int = None,
    ):
        # 副本数量是部署单元维度还是集群维度。目前只支持Cell
        self.type = type
        # 部署单元名称或集群名称。
        self.name = name
        # 对应副本数量。
        self.count = count
        # （针对huanyu场景），original_count该单元当前的副本个数（count对应期望的副本个数）
        self.original_count = original_count

    def validate(self):
        self.validate_required(self.type, 'type')
        self.validate_required(self.name, 'name')
        self.validate_required(self.count, 'count')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.name is not None:
            result['name'] = self.name
        if self.count is not None:
            result['count'] = self.count
        if self.original_count is not None:
            result['original_count'] = self.original_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('original_count') is not None:
            self.original_count = m.get('original_count')
        return self


class NodeAffinityConfig(TeaModel):
    def __init__(
        self,
        match_expressions: List[MatchExpression] = None,
        requested: bool = None,
        weight: int = None,
    ):
        # match_expressions
        self.match_expressions = match_expressions
        # requested
        self.requested = requested
        # weight
        self.weight = weight

    def validate(self):
        if self.match_expressions:
            for k in self.match_expressions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['match_expressions'] = []
        if self.match_expressions is not None:
            for k in self.match_expressions:
                result['match_expressions'].append(k.to_map() if k else None)
        if self.requested is not None:
            result['requested'] = self.requested
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.match_expressions = []
        if m.get('match_expressions') is not None:
            for k in m.get('match_expressions'):
                temp_model = MatchExpression()
                self.match_expressions.append(temp_model.from_map(k))
        if m.get('requested') is not None:
            self.requested = m.get('requested')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class CellReplicasMap(TeaModel):
    def __init__(
        self,
        name: str = None,
        replicas: int = None,
    ):
        # cell name
        self.name = name
        # 副本数
        self.replicas = replicas

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.replicas, 'replicas')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.replicas is not None:
            result['replicas'] = self.replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('replicas') is not None:
            self.replicas = m.get('replicas')
        return self


class PodSpec(TeaModel):
    def __init__(
        self,
        active_deadline_seconds: int = None,
        affinity: Affinity = None,
        automount_service_account_token: bool = None,
        containers: List[ContainerSpec] = None,
        dns_config: PodDNSConfig = None,
        dns_policy: str = None,
        enable_service_links: bool = None,
        host_aliases: HostAlias = None,
        host_ipc: bool = None,
        host_network: bool = None,
        host_pid: bool = None,
        hostname: str = None,
        image_pull_secrets: List[str] = None,
        init_containers: List[ContainerSpec] = None,
        node_name: str = None,
        node_selector: List[PodNodeSelector] = None,
        priority: int = None,
        priority_class_name: str = None,
        readiness_gates: PodReadinessGate = None,
        restart_policy: str = None,
        service_account_name: str = None,
        tolerations: List[Toleration] = None,
        volumes: List[Volume] = None,
    ):
        # Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers
        self.active_deadline_seconds = active_deadline_seconds
        # If specified, the pod_s scheduling constraints
        # 
        self.affinity = affinity
        # AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
        # 
        self.automount_service_account_token = automount_service_account_token
        # List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
        # 
        self.containers = containers
        # Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
        self.dns_config = dns_config
        # Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are _ClusterFirstWithHostNet_, _ClusterFirst_, _Default_ or _None_. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to _ClusterFirstWithHostNet_.
        self.dns_policy = dns_policy
        # EnableServiceLinks indicates whether information about services should be injected into pod_s environment variables, matching the syntax of Docker links. Optional: Defaults to true.
        # 
        self.enable_service_links = enable_service_links
        # HostAliases is an optional list of hosts and IPs that will be injected into the pod_s hosts file if specified. This is only valid for non-hostNetwork pods.
        self.host_aliases = host_aliases
        # Use the host_s ipc namespace. Optional: Default to false.
        # 
        self.host_ipc = host_ipc
        # Host networking requested for this pod. Use the host_s network namespace. If this option is set, the ports that will be used must be specified. Default to false.
        # 
        self.host_network = host_network
        # Use the host_s pid namespace. Optional: Default to false.
        # 
        self.host_pid = host_pid
        # Specifies the hostname of the Pod If not specified, the pod_s hostname will be set to a system-defined value.
        # 
        self.hostname = hostname
        # ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec
        self.image_pull_secrets = image_pull_secrets
        # List of initialization containers belonging to the pod
        self.init_containers = init_containers
        # NodeName is a request to schedule this pod onto a specific node.
        self.node_name = node_name
        # NodeSelector is a selector which must be true for the pod to fit on a node
        self.node_selector = node_selector
        # The priority value. Various system components use this field to find the priority of the pod.
        self.priority = priority
        # If specified, indicates the pod_s priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority
        self.priority_class_name = priority_class_name
        # If specified, all readiness gates will be evaluated for pod readiness
        self.readiness_gates = readiness_gates
        # Restart policy for all containers within the pod
        self.restart_policy = restart_policy
        # ServiceAccountName is the name of the ServiceAccount to use to run this pod
        self.service_account_name = service_account_name
        # If specified, the pod_s tolerations.
        # 
        self.tolerations = tolerations
        # List of volumes that can be mounted by containers belonging to the pod
        self.volumes = volumes

    def validate(self):
        if self.affinity:
            self.affinity.validate()
        self.validate_required(self.containers, 'containers')
        if self.containers:
            for k in self.containers:
                if k:
                    k.validate()
        if self.dns_config:
            self.dns_config.validate()
        if self.host_aliases:
            self.host_aliases.validate()
        if self.init_containers:
            for k in self.init_containers:
                if k:
                    k.validate()
        if self.node_selector:
            for k in self.node_selector:
                if k:
                    k.validate()
        if self.readiness_gates:
            self.readiness_gates.validate()
        if self.tolerations:
            for k in self.tolerations:
                if k:
                    k.validate()
        if self.volumes:
            for k in self.volumes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_deadline_seconds is not None:
            result['active_deadline_seconds'] = self.active_deadline_seconds
        if self.affinity is not None:
            result['affinity'] = self.affinity.to_map()
        if self.automount_service_account_token is not None:
            result['automount_service_account_token'] = self.automount_service_account_token
        result['containers'] = []
        if self.containers is not None:
            for k in self.containers:
                result['containers'].append(k.to_map() if k else None)
        if self.dns_config is not None:
            result['dns_config'] = self.dns_config.to_map()
        if self.dns_policy is not None:
            result['dns_policy'] = self.dns_policy
        if self.enable_service_links is not None:
            result['enable_service_links'] = self.enable_service_links
        if self.host_aliases is not None:
            result['host_aliases'] = self.host_aliases.to_map()
        if self.host_ipc is not None:
            result['host_ipc'] = self.host_ipc
        if self.host_network is not None:
            result['host_network'] = self.host_network
        if self.host_pid is not None:
            result['host_pid'] = self.host_pid
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.image_pull_secrets is not None:
            result['image_pull_secrets'] = self.image_pull_secrets
        result['init_containers'] = []
        if self.init_containers is not None:
            for k in self.init_containers:
                result['init_containers'].append(k.to_map() if k else None)
        if self.node_name is not None:
            result['node_name'] = self.node_name
        result['node_selector'] = []
        if self.node_selector is not None:
            for k in self.node_selector:
                result['node_selector'].append(k.to_map() if k else None)
        if self.priority is not None:
            result['priority'] = self.priority
        if self.priority_class_name is not None:
            result['priority_class_name'] = self.priority_class_name
        if self.readiness_gates is not None:
            result['readiness_gates'] = self.readiness_gates.to_map()
        if self.restart_policy is not None:
            result['restart_policy'] = self.restart_policy
        if self.service_account_name is not None:
            result['service_account_name'] = self.service_account_name
        result['tolerations'] = []
        if self.tolerations is not None:
            for k in self.tolerations:
                result['tolerations'].append(k.to_map() if k else None)
        result['volumes'] = []
        if self.volumes is not None:
            for k in self.volumes:
                result['volumes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('active_deadline_seconds') is not None:
            self.active_deadline_seconds = m.get('active_deadline_seconds')
        if m.get('affinity') is not None:
            temp_model = Affinity()
            self.affinity = temp_model.from_map(m['affinity'])
        if m.get('automount_service_account_token') is not None:
            self.automount_service_account_token = m.get('automount_service_account_token')
        self.containers = []
        if m.get('containers') is not None:
            for k in m.get('containers'):
                temp_model = ContainerSpec()
                self.containers.append(temp_model.from_map(k))
        if m.get('dns_config') is not None:
            temp_model = PodDNSConfig()
            self.dns_config = temp_model.from_map(m['dns_config'])
        if m.get('dns_policy') is not None:
            self.dns_policy = m.get('dns_policy')
        if m.get('enable_service_links') is not None:
            self.enable_service_links = m.get('enable_service_links')
        if m.get('host_aliases') is not None:
            temp_model = HostAlias()
            self.host_aliases = temp_model.from_map(m['host_aliases'])
        if m.get('host_ipc') is not None:
            self.host_ipc = m.get('host_ipc')
        if m.get('host_network') is not None:
            self.host_network = m.get('host_network')
        if m.get('host_pid') is not None:
            self.host_pid = m.get('host_pid')
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('image_pull_secrets') is not None:
            self.image_pull_secrets = m.get('image_pull_secrets')
        self.init_containers = []
        if m.get('init_containers') is not None:
            for k in m.get('init_containers'):
                temp_model = ContainerSpec()
                self.init_containers.append(temp_model.from_map(k))
        if m.get('node_name') is not None:
            self.node_name = m.get('node_name')
        self.node_selector = []
        if m.get('node_selector') is not None:
            for k in m.get('node_selector'):
                temp_model = PodNodeSelector()
                self.node_selector.append(temp_model.from_map(k))
        if m.get('priority') is not None:
            self.priority = m.get('priority')
        if m.get('priority_class_name') is not None:
            self.priority_class_name = m.get('priority_class_name')
        if m.get('readiness_gates') is not None:
            temp_model = PodReadinessGate()
            self.readiness_gates = temp_model.from_map(m['readiness_gates'])
        if m.get('restart_policy') is not None:
            self.restart_policy = m.get('restart_policy')
        if m.get('service_account_name') is not None:
            self.service_account_name = m.get('service_account_name')
        self.tolerations = []
        if m.get('tolerations') is not None:
            for k in m.get('tolerations'):
                temp_model = Toleration()
                self.tolerations.append(temp_model.from_map(k))
        self.volumes = []
        if m.get('volumes') is not None:
            for k in m.get('volumes'):
                temp_model = Volume()
                self.volumes.append(temp_model.from_map(k))
        return self


class HPABasedElasticConfigMetric(TeaModel):
    def __init__(
        self,
        name: str = None,
        target: HPABasedElasticConfigMetricTarget = None,
    ):
        # 指标名称：
        # CPU，Memory，QPS，RT
        self.name = name
        # 目标值
        self.target = target

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.target, 'target')
        if self.target:
            self.target.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.target is not None:
            result['target'] = self.target.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('target') is not None:
            temp_model = HPABasedElasticConfigMetricTarget()
            self.target = temp_model.from_map(m['target'])
        return self


class ObjectMeta(TeaModel):
    def __init__(
        self,
        annotations: List[Annotation] = None,
        creation_timestamp: str = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
    ):
        # k8s meta annotation
        self.annotations = annotations
        # 创建时间戳
        self.creation_timestamp = creation_timestamp
        # k8s meta labels
        self.labels = labels
        # 名称
        self.name = name
        # 命名空间
        self.namespace = namespace

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.creation_timestamp is not None:
            self.validate_pattern(self.creation_timestamp, 'creation_timestamp', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.labels, 'labels')
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.creation_timestamp is not None:
            result['creation_timestamp'] = self.creation_timestamp
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = Annotation()
                self.annotations.append(temp_model.from_map(k))
        if m.get('creation_timestamp') is not None:
            self.creation_timestamp = m.get('creation_timestamp')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class PodAffinityConfig(TeaModel):
    def __init__(
        self,
        anti_affinity: bool = None,
        pod_affinity_term: PodAffinityTermEntity = None,
        requested: bool = None,
        weight: int = None,
    ):
        # anti_affinity
        self.anti_affinity = anti_affinity
        # pod_affinity_term
        self.pod_affinity_term = pod_affinity_term
        # requested
        self.requested = requested
        # weight
        self.weight = weight

    def validate(self):
        if self.pod_affinity_term:
            self.pod_affinity_term.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anti_affinity is not None:
            result['anti_affinity'] = self.anti_affinity
        if self.pod_affinity_term is not None:
            result['pod_affinity_term'] = self.pod_affinity_term.to_map()
        if self.requested is not None:
            result['requested'] = self.requested
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('anti_affinity') is not None:
            self.anti_affinity = m.get('anti_affinity')
        if m.get('pod_affinity_term') is not None:
            temp_model = PodAffinityTermEntity()
            self.pod_affinity_term = temp_model.from_map(m['pod_affinity_term'])
        if m.get('requested') is not None:
            self.requested = m.get('requested')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class ContainerState(TeaModel):
    def __init__(
        self,
        running: ContainerStateRunning = None,
        terminated: ContainerStateTerminated = None,
        waiting: ContainerStateWaiting = None,
    ):
        # container running state
        self.running = running
        # container terminated state
        self.terminated = terminated
        # container waiting state
        self.waiting = waiting

    def validate(self):
        self.validate_required(self.running, 'running')
        if self.running:
            self.running.validate()
        self.validate_required(self.terminated, 'terminated')
        if self.terminated:
            self.terminated.validate()
        self.validate_required(self.waiting, 'waiting')
        if self.waiting:
            self.waiting.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.running is not None:
            result['running'] = self.running.to_map()
        if self.terminated is not None:
            result['terminated'] = self.terminated.to_map()
        if self.waiting is not None:
            result['waiting'] = self.waiting.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('running') is not None:
            temp_model = ContainerStateRunning()
            self.running = temp_model.from_map(m['running'])
        if m.get('terminated') is not None:
            temp_model = ContainerStateTerminated()
            self.terminated = temp_model.from_map(m['terminated'])
        if m.get('waiting') is not None:
            temp_model = ContainerStateWaiting()
            self.waiting = temp_model.from_map(m['waiting'])
        return self


class TemplateParam(TeaModel):
    def __init__(
        self,
        id: str = None,
        key: str = None,
        value: str = None,
        name: str = None,
        required: bool = None,
    ):
        # 参数唯一标识
        self.id = id
        # 参数key
        self.key = key
        # 参数值
        self.value = value
        # 参数中文名称
        self.name = name
        # 是否必填
        self.required = required

    def validate(self):
        self.validate_required(self.key, 'key')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        if self.name is not None:
            result['name'] = self.name
        if self.required is not None:
            result['required'] = self.required
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('required') is not None:
            self.required = m.get('required')
        return self


class HasHookConfig(TeaModel):
    def __init__(
        self,
        pre_type: str = None,
        pre_ref_id: str = None,
        pre_name: str = None,
        pre_params: List[TemplateParam] = None,
        pre_need_confirm: bool = None,
        post_type: str = None,
        post_ref_id: str = None,
        post_name: str = None,
        post_params: List[TemplateParam] = None,
        post_need_confirm: bool = None,
    ):
        # 前置脚本类型，巡检或预案
        self.pre_type = pre_type
        # 前置巡检或预案id
        self.pre_ref_id = pre_ref_id
        # 前置巡检或预案名称
        self.pre_name = pre_name
        # 前置巡检或预案参数
        self.pre_params = pre_params
        # 前置是否需要确认
        self.pre_need_confirm = pre_need_confirm
        # 后置脚本类型，巡检或预案
        self.post_type = post_type
        # 后置巡检或预案id
        self.post_ref_id = post_ref_id
        # 后置巡检或预案名称
        self.post_name = post_name
        # 后置巡检或预案参数
        self.post_params = post_params
        # 后置是否需要确认
        self.post_need_confirm = post_need_confirm

    def validate(self):
        if self.pre_params:
            for k in self.pre_params:
                if k:
                    k.validate()
        if self.post_params:
            for k in self.post_params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pre_type is not None:
            result['pre_type'] = self.pre_type
        if self.pre_ref_id is not None:
            result['pre_ref_id'] = self.pre_ref_id
        if self.pre_name is not None:
            result['pre_name'] = self.pre_name
        result['pre_params'] = []
        if self.pre_params is not None:
            for k in self.pre_params:
                result['pre_params'].append(k.to_map() if k else None)
        if self.pre_need_confirm is not None:
            result['pre_need_confirm'] = self.pre_need_confirm
        if self.post_type is not None:
            result['post_type'] = self.post_type
        if self.post_ref_id is not None:
            result['post_ref_id'] = self.post_ref_id
        if self.post_name is not None:
            result['post_name'] = self.post_name
        result['post_params'] = []
        if self.post_params is not None:
            for k in self.post_params:
                result['post_params'].append(k.to_map() if k else None)
        if self.post_need_confirm is not None:
            result['post_need_confirm'] = self.post_need_confirm
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pre_type') is not None:
            self.pre_type = m.get('pre_type')
        if m.get('pre_ref_id') is not None:
            self.pre_ref_id = m.get('pre_ref_id')
        if m.get('pre_name') is not None:
            self.pre_name = m.get('pre_name')
        self.pre_params = []
        if m.get('pre_params') is not None:
            for k in m.get('pre_params'):
                temp_model = TemplateParam()
                self.pre_params.append(temp_model.from_map(k))
        if m.get('pre_need_confirm') is not None:
            self.pre_need_confirm = m.get('pre_need_confirm')
        if m.get('post_type') is not None:
            self.post_type = m.get('post_type')
        if m.get('post_ref_id') is not None:
            self.post_ref_id = m.get('post_ref_id')
        if m.get('post_name') is not None:
            self.post_name = m.get('post_name')
        self.post_params = []
        if m.get('post_params') is not None:
            for k in m.get('post_params'):
                temp_model = TemplateParam()
                self.post_params.append(temp_model.from_map(k))
        if m.get('post_need_confirm') is not None:
            self.post_need_confirm = m.get('post_need_confirm')
        return self


class AffinityEntity(TeaModel):
    def __init__(
        self,
        node_affinity: List[NodeAffinityConfig] = None,
        pod_affinity: List[PodAffinityConfig] = None,
    ):
        # NodeAffinityConfig list
        self.node_affinity = node_affinity
        # pod_affinity list
        self.pod_affinity = pod_affinity

    def validate(self):
        if self.node_affinity:
            for k in self.node_affinity:
                if k:
                    k.validate()
        if self.pod_affinity:
            for k in self.pod_affinity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['node_affinity'] = []
        if self.node_affinity is not None:
            for k in self.node_affinity:
                result['node_affinity'].append(k.to_map() if k else None)
        result['pod_affinity'] = []
        if self.pod_affinity is not None:
            for k in self.pod_affinity:
                result['pod_affinity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.node_affinity = []
        if m.get('node_affinity') is not None:
            for k in m.get('node_affinity'):
                temp_model = NodeAffinityConfig()
                self.node_affinity.append(temp_model.from_map(k))
        self.pod_affinity = []
        if m.get('pod_affinity') is not None:
            for k in m.get('pod_affinity'):
                temp_model = PodAffinityConfig()
                self.pod_affinity.append(temp_model.from_map(k))
        return self


class ResourceRequirementConfig(TeaModel):
    def __init__(
        self,
        limits: List[MapResourceNameToValue] = None,
        requests: List[MapResourceNameToValue] = None,
    ):
        # limits
        self.limits = limits
        # requests
        self.requests = requests

    def validate(self):
        if self.limits:
            for k in self.limits:
                if k:
                    k.validate()
        if self.requests:
            for k in self.requests:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['limits'] = []
        if self.limits is not None:
            for k in self.limits:
                result['limits'].append(k.to_map() if k else None)
        result['requests'] = []
        if self.requests is not None:
            for k in self.requests:
                result['requests'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.limits = []
        if m.get('limits') is not None:
            for k in m.get('limits'):
                temp_model = MapResourceNameToValue()
                self.limits.append(temp_model.from_map(k))
        self.requests = []
        if m.get('requests') is not None:
            for k in m.get('requests'):
                temp_model = MapResourceNameToValue()
                self.requests.append(temp_model.from_map(k))
        return self


class OpsComputerTask(TeaModel):
    def __init__(
        self,
        description: str = None,
        execute_details: str = None,
        finish_time: str = None,
        name: str = None,
        start_time: str = None,
        status: str = None,
    ):
        # 任务描述
        self.description = description
        # 执行详情。如果任务成功，为执行日志；如果任务失败，为错误信息
        self.execute_details = execute_details
        # 任务结束时间
        self.finish_time = finish_time
        # 任务名称
        self.name = name
        # 任务开始时间
        self.start_time = start_time
        # 任务状态。取值列表： EXECUTING：执行中； SUCCESS：执行成功； FAILED：执行失败
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.execute_details is not None:
            result['execute_details'] = self.execute_details
        if self.finish_time is not None:
            result['finish_time'] = self.finish_time
        if self.name is not None:
            result['name'] = self.name
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('execute_details') is not None:
            self.execute_details = m.get('execute_details')
        if m.get('finish_time') is not None:
            self.finish_time = m.get('finish_time')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class RegistryAccout(TeaModel):
    def __init__(
        self,
        email: str = None,
        password: str = None,
        registry: str = None,
        username: str = None,
    ):
        # registry email url
        self.email = email
        # registry password
        self.password = password
        # registry url
        self.registry = registry
        # registry username
        self.username = username

    def validate(self):
        self.validate_required(self.password, 'password')
        self.validate_required(self.registry, 'registry')
        self.validate_required(self.username, 'username')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.email is not None:
            result['email'] = self.email
        if self.password is not None:
            result['password'] = self.password
        if self.registry is not None:
            result['registry'] = self.registry
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('email') is not None:
            self.email = m.get('email')
        if m.get('password') is not None:
            self.password = m.get('password')
        if m.get('registry') is not None:
            self.registry = m.get('registry')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class ApiHookConfig(TeaModel):
    def __init__(
        self,
        post_url: str = None,
        auth_key: str = None,
        timeout: str = None,
        check_url: str = None,
    ):
        # 卡点要调用的api地址
        self.post_url = post_url
        # 授权码
        self.auth_key = auth_key
        # 接口超时时间，单位ms
        self.timeout = timeout
        # 查询异步卡点接口执行结果api
        self.check_url = check_url

    def validate(self):
        self.validate_required(self.post_url, 'post_url')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.post_url is not None:
            result['post_url'] = self.post_url
        if self.auth_key is not None:
            result['auth_key'] = self.auth_key
        if self.timeout is not None:
            result['timeout'] = self.timeout
        if self.check_url is not None:
            result['check_url'] = self.check_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('post_url') is not None:
            self.post_url = m.get('post_url')
        if m.get('auth_key') is not None:
            self.auth_key = m.get('auth_key')
        if m.get('timeout') is not None:
            self.timeout = m.get('timeout')
        if m.get('check_url') is not None:
            self.check_url = m.get('check_url')
        return self


class HPABasedElasticConfig(TeaModel):
    def __init__(
        self,
        cells: List[CellReplicasMap] = None,
        min_replica: int = None,
        max_replica: int = None,
        metrics: List[HPABasedElasticConfigMetric] = None,
        behavior: HPAScaleBehavior = None,
    ):
        # pod要发布的部署单元及每个部署单元副本数的映射关系列表
        self.cells = cells
        # 最小副本数
        self.min_replica = min_replica
        # 最大副本数
        self.max_replica = max_replica
        # 弹性伸缩指标列表
        self.metrics = metrics
        # 扩缩容规则高级配置
        self.behavior = behavior

    def validate(self):
        self.validate_required(self.cells, 'cells')
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()
        self.validate_required(self.min_replica, 'min_replica')
        self.validate_required(self.max_replica, 'max_replica')
        self.validate_required(self.metrics, 'metrics')
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()
        if self.behavior:
            self.behavior.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        if self.min_replica is not None:
            result['min_replica'] = self.min_replica
        if self.max_replica is not None:
            result['max_replica'] = self.max_replica
        result['metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['metrics'].append(k.to_map() if k else None)
        if self.behavior is not None:
            result['behavior'] = self.behavior.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = CellReplicasMap()
                self.cells.append(temp_model.from_map(k))
        if m.get('min_replica') is not None:
            self.min_replica = m.get('min_replica')
        if m.get('max_replica') is not None:
            self.max_replica = m.get('max_replica')
        self.metrics = []
        if m.get('metrics') is not None:
            for k in m.get('metrics'):
                temp_model = HPABasedElasticConfigMetric()
                self.metrics.append(temp_model.from_map(k))
        if m.get('behavior') is not None:
            temp_model = HPAScaleBehavior()
            self.behavior = temp_model.from_map(m['behavior'])
        return self


class CellServer(TeaModel):
    def __init__(
        self,
        cell: str = None,
        servers: List[str] = None,
        count: int = None,
        server_ips: List[str] = None,
    ):
        # 单元名字
        self.cell = cell
        # server或pod组
        self.servers = servers
        # cell中host的数量
        self.count = count
        # servers列表对应的服务器/pod ip地址列表，目前仅在antcloud.ldc.opsplan.stages.export方法中返回
        self.server_ips = server_ips

    def validate(self):
        self.validate_required(self.cell, 'cell')
        self.validate_required(self.count, 'count')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell is not None:
            result['cell'] = self.cell
        if self.servers is not None:
            result['servers'] = self.servers
        if self.count is not None:
            result['count'] = self.count
        if self.server_ips is not None:
            result['server_ips'] = self.server_ips
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('servers') is not None:
            self.servers = m.get('servers')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('server_ips') is not None:
            self.server_ips = m.get('server_ips')
        return self


class FixedReplicaElasticConfig(TeaModel):
    def __init__(
        self,
        replicas: List[ReplicaCount] = None,
    ):
        # 各部署单元/集群的副本数配置。
        self.replicas = replicas

    def validate(self):
        self.validate_required(self.replicas, 'replicas')
        if self.replicas:
            for k in self.replicas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['replicas'] = []
        if self.replicas is not None:
            for k in self.replicas:
                result['replicas'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.replicas = []
        if m.get('replicas') is not None:
            for k in m.get('replicas'):
                temp_model = ReplicaCount()
                self.replicas.append(temp_model.from_map(k))
        return self


class AppDeployCell(TeaModel):
    def __init__(
        self,
        cell_name: str = None,
        partition: int = None,
        release_count: int = None,
        pod_list: List[PodDetailInfo] = None,
    ):
        # 单元名字
        self.cell_name = cell_name
        # 执行到当前cell的pod总数
        self.partition = partition
        # 当前分组发布的pod数
        self.release_count = release_count
        # 当前cell发布的pod列表
        self.pod_list = pod_list

    def validate(self):
        self.validate_required(self.cell_name, 'cell_name')
        self.validate_required(self.partition, 'partition')
        self.validate_required(self.release_count, 'release_count')
        self.validate_required(self.pod_list, 'pod_list')
        if self.pod_list:
            for k in self.pod_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.partition is not None:
            result['partition'] = self.partition
        if self.release_count is not None:
            result['release_count'] = self.release_count
        result['pod_list'] = []
        if self.pod_list is not None:
            for k in self.pod_list:
                result['pod_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('partition') is not None:
            self.partition = m.get('partition')
        if m.get('release_count') is not None:
            self.release_count = m.get('release_count')
        self.pod_list = []
        if m.get('pod_list') is not None:
            for k in m.get('pod_list'):
                temp_model = PodDetailInfo()
                self.pod_list.append(temp_model.from_map(k))
        return self


class DeploymentCondition(TeaModel):
    def __init__(
        self,
        last_transition_time: str = None,
        last_update_time: str = None,
        message: str = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        # Last time the condition transitioned from one status to another.
        self.last_transition_time = last_transition_time
        # The last time this condition was updated.
        # 
        self.last_update_time = last_update_time
        # A human readable message indicating details about the transition.
        # 
        self.message = message
        # The reason for the condition_s last transition.
        # 
        self.reason = reason
        # Status of the condition, one of True, False, Unknown.
        # 
        self.status = status
        # Type of deployment condition.
        # 
        self.type = type

    def validate(self):
        if self.last_transition_time is not None:
            self.validate_pattern(self.last_transition_time, 'last_transition_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.last_update_time is not None:
            self.validate_pattern(self.last_update_time, 'last_update_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.status, 'status')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.last_transition_time is not None:
            result['last_transition_time'] = self.last_transition_time
        if self.last_update_time is not None:
            result['last_update_time'] = self.last_update_time
        if self.message is not None:
            result['message'] = self.message
        if self.reason is not None:
            result['reason'] = self.reason
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('last_transition_time') is not None:
            self.last_transition_time = m.get('last_transition_time')
        if m.get('last_update_time') is not None:
            self.last_update_time = m.get('last_update_time')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class LoadBalancerListenerWithRule(TeaModel):
    def __init__(
        self,
        domain: str = None,
        listener: LoadBalancerListener = None,
        path: str = None,
        weight: int = None,
    ):
        # 统一接入域名。
        self.domain = domain
        # 负载均衡监听。
        self.listener = listener
        # 转发路径。
        self.path = path
        # 权重。
        self.weight = weight

    def validate(self):
        self.validate_required(self.domain, 'domain')
        self.validate_required(self.listener, 'listener')
        if self.listener:
            self.listener.validate()
        self.validate_required(self.path, 'path')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['domain'] = self.domain
        if self.listener is not None:
            result['listener'] = self.listener.to_map()
        if self.path is not None:
            result['path'] = self.path
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        if m.get('listener') is not None:
            temp_model = LoadBalancerListener()
            self.listener = temp_model.from_map(m['listener'])
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class PodTemplateSpec(TeaModel):
    def __init__(
        self,
        metadata: ObjectMeta = None,
        spec: PodSpec = None,
    ):
        # k8s Standard object_s metadata.
        self.metadata = metadata
        # Specification of the desired behavior of the pod.
        self.spec = spec

    def validate(self):
        self.validate_required(self.metadata, 'metadata')
        if self.metadata:
            self.metadata.validate()
        self.validate_required(self.spec, 'spec')
        if self.spec:
            self.spec.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        if self.spec is not None:
            result['spec'] = self.spec.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('metadata') is not None:
            temp_model = ObjectMeta()
            self.metadata = temp_model.from_map(m['metadata'])
        if m.get('spec') is not None:
            temp_model = PodSpec()
            self.spec = temp_model.from_map(m['spec'])
        return self


class ContainerStatus(TeaModel):
    def __init__(
        self,
        container_id: str = None,
        image: str = None,
        last_start_time: str = None,
        name: str = None,
        ready: bool = None,
        restart_count: int = None,
        state: ContainerState = None,
    ):
        # container id
        self.container_id = container_id
        # image
        self.image = image
        # 上一次启动时间
        self.last_start_time = last_start_time
        # container name
        self.name = name
        # 是否ready
        self.ready = ready
        # 重启次数
        self.restart_count = restart_count
        # container state
        self.state = state

    def validate(self):
        self.validate_required(self.container_id, 'container_id')
        self.validate_required(self.image, 'image')
        self.validate_required(self.last_start_time, 'last_start_time')
        self.validate_required(self.name, 'name')
        self.validate_required(self.ready, 'ready')
        self.validate_required(self.restart_count, 'restart_count')
        self.validate_required(self.state, 'state')
        if self.state:
            self.state.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['container_id'] = self.container_id
        if self.image is not None:
            result['image'] = self.image
        if self.last_start_time is not None:
            result['last_start_time'] = self.last_start_time
        if self.name is not None:
            result['name'] = self.name
        if self.ready is not None:
            result['ready'] = self.ready
        if self.restart_count is not None:
            result['restart_count'] = self.restart_count
        if self.state is not None:
            result['state'] = self.state.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('container_id') is not None:
            self.container_id = m.get('container_id')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('last_start_time') is not None:
            self.last_start_time = m.get('last_start_time')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('ready') is not None:
            self.ready = m.get('ready')
        if m.get('restart_count') is not None:
            self.restart_count = m.get('restart_count')
        if m.get('state') is not None:
            temp_model = ContainerState()
            self.state = temp_model.from_map(m['state'])
        return self


class SpannerSubClusterOverrides(TeaModel):
    def __init__(
        self,
        zone: str = None,
        image: str = None,
    ):
        # 机房/可用区
        self.zone = zone
        # spanner镜像地址
        self.image = image

    def validate(self):
        self.validate_required(self.zone, 'zone')
        self.validate_required(self.image, 'image')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.zone is not None:
            result['zone'] = self.zone
        if self.image is not None:
            result['image'] = self.image
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('zone') is not None:
            self.zone = m.get('zone')
        if m.get('image') is not None:
            self.image = m.get('image')
        return self


class DeploymentStrategy(TeaModel):
    def __init__(
        self,
        rolling_update: RollingUpdateDeployment = None,
        type: str = None,
    ):
        # Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
        self.rolling_update = rolling_update
        # Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
        self.type = type

    def validate(self):
        if self.rolling_update:
            self.rolling_update.validate()
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rolling_update is not None:
            result['rolling_update'] = self.rolling_update.to_map()
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('rolling_update') is not None:
            temp_model = RollingUpdateDeployment()
            self.rolling_update = temp_model.from_map(m['rolling_update'])
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class CellPods(TeaModel):
    def __init__(
        self,
        cell: str = None,
        pod_names: List[str] = None,
    ):
        # 部署单元名称
        self.cell = cell
        # pod标识列表
        self.pod_names = pod_names

    def validate(self):
        self.validate_required(self.cell, 'cell')
        self.validate_required(self.pod_names, 'pod_names')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell is not None:
            result['cell'] = self.cell
        if self.pod_names is not None:
            result['pod_names'] = self.pod_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('pod_names') is not None:
            self.pod_names = m.get('pod_names')
        return self


class ServicePortMapping(TeaModel):
    def __init__(
        self,
        port: int = None,
        protocol: str = None,
        target_port: int = None,
    ):
        # 访问配置前端端口。
        self.port = port
        # 访问配置协议。
        self.protocol = protocol
        # 访问配置后端端口。
        self.target_port = target_port

    def validate(self):
        self.validate_required(self.port, 'port')
        self.validate_required(self.protocol, 'protocol')
        self.validate_required(self.target_port, 'target_port')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['port'] = self.port
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.target_port is not None:
            result['target_port'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('target_port') is not None:
            self.target_port = m.get('target_port')
        return self


class HttpEntryStatus(TeaModel):
    def __init__(
        self,
        backend_port: int = None,
        node_port: int = None,
    ):
        # 此entry分配到的spanner后端端口（l7 listener 端口）
        self.backend_port = backend_port
        # 此entry对应service分配到的节点端口
        self.node_port = node_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_port is not None:
            result['backend_port'] = self.backend_port
        if self.node_port is not None:
            result['node_port'] = self.node_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('backend_port') is not None:
            self.backend_port = m.get('backend_port')
        if m.get('node_port') is not None:
            self.node_port = m.get('node_port')
        return self


class ConfigMapData(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # configmap data key
        self.key = key
        # configmap data value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class OperationChangeInstance(TeaModel):
    def __init__(
        self,
        hostname: str = None,
        cell: str = None,
        ip: str = None,
        id: str = None,
    ):
        # 主机名
        self.hostname = hostname
        # 部署单元
        self.cell = cell
        # ip
        self.ip = ip
        # 资源ID
        self.id = id

    def validate(self):
        self.validate_required(self.cell, 'cell')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hostname is not None:
            result['hostname'] = self.hostname
        if self.cell is not None:
            result['cell'] = self.cell
        if self.ip is not None:
            result['ip'] = self.ip
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hostname') is not None:
            self.hostname = m.get('hostname')
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class HeadlessService(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # headless service 的名称，不能以-0~-9结尾
        self.name = name

    def validate(self):
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class EnvVarClusterOverride(TeaModel):
    def __init__(
        self,
        name: str = None,
        value: str = None,
        container_name: str = None,
    ):
        # 环境变量名称
        self.name = name
        # 环境变量取值
        self.value = value
        # Pod容器名称
        self.container_name = container_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.value, 'value')
        self.validate_required(self.container_name, 'container_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.value is not None:
            result['value'] = self.value
        if self.container_name is not None:
            result['container_name'] = self.container_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('container_name') is not None:
            self.container_name = m.get('container_name')
        return self


class OpsContainerService(TeaModel):
    def __init__(
        self,
        namespace: str = None,
        name: str = None,
        selected_pods: List[CellPods] = None,
    ):
        # 命名空间
        self.namespace = namespace
        # 容器服务名称
        self.name = name
        # 待操作目标pods列表
        self.selected_pods = selected_pods

    def validate(self):
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.name, 'name')
        if self.selected_pods:
            for k in self.selected_pods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.name is not None:
            result['name'] = self.name
        result['selected_pods'] = []
        if self.selected_pods is not None:
            for k in self.selected_pods:
                result['selected_pods'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.selected_pods = []
        if m.get('selected_pods') is not None:
            for k in m.get('selected_pods'):
                temp_model = CellPods()
                self.selected_pods.append(temp_model.from_map(k))
        return self


class DeployConfig(TeaModel):
    def __init__(
        self,
        affinity: AffinityEntity = None,
        annotations: str = None,
        custom_labels: str = None,
        group_count: int = None,
        group_strategy: str = None,
        labels: str = None,
        max_group_capacity: int = None,
        need_beta: bool = None,
        need_confirm: bool = None,
        enable_sofa_mesh: bool = None,
        upgrade_strategy: str = None,
        confirm_strategy: str = None,
        pod_naming_policy: str = None,
        force_stride_control: bool = None,
        max_cell_pod_percentage: int = None,
    ):
        # 节点亲和性配置
        self.affinity = affinity
        # annotations
        self.annotations = annotations
        # 用户自定义标签，将会在pod上生效
        self.custom_labels = custom_labels
        # 最小分组数
        self.group_count = group_count
        # 容器服务部署分组策略。
        self.group_strategy = group_strategy
        # labels
        self.labels = labels
        # 单个分组最大Pod数量。
        self.max_group_capacity = max_group_capacity
        # 是否需要beta confirm。
        self.need_beta = need_beta
        # 是否需要分组确认。
        self.need_confirm = need_confirm
        # 已废弃
        self.enable_sofa_mesh = enable_sofa_mesh
        # 只支持InPlace
        self.upgrade_strategy = upgrade_strategy
        # 分组确认策略，FIRST：第一个分组需要确认，EACH：每个分组都需要确认（默认）
        self.confirm_strategy = confirm_strategy
        # pod name 命名规则，lks 1.23.0 开始支持。Default/PersistentSequence
        self.pod_naming_policy = pod_naming_policy
        # [已废除] 是否开启强制步长控制。对于ALL_ONE, ALL_ONE_CELL_BETA等分组模式，group_count与max_group_capacity字段将生效，提供精细化分组，以满足用户的pod发布并发控制需求
        self.force_stride_control = force_stride_control
        # 每个部署单元单批次最大变更pod比例，仅当group_strategy为ALL_CELL_PERCENTAGE时生效
        self.max_cell_pod_percentage = max_cell_pod_percentage

    def validate(self):
        if self.affinity:
            self.affinity.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affinity is not None:
            result['affinity'] = self.affinity.to_map()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.custom_labels is not None:
            result['custom_labels'] = self.custom_labels
        if self.group_count is not None:
            result['group_count'] = self.group_count
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        if self.labels is not None:
            result['labels'] = self.labels
        if self.max_group_capacity is not None:
            result['max_group_capacity'] = self.max_group_capacity
        if self.need_beta is not None:
            result['need_beta'] = self.need_beta
        if self.need_confirm is not None:
            result['need_confirm'] = self.need_confirm
        if self.enable_sofa_mesh is not None:
            result['enable_sofa_mesh'] = self.enable_sofa_mesh
        if self.upgrade_strategy is not None:
            result['upgrade_strategy'] = self.upgrade_strategy
        if self.confirm_strategy is not None:
            result['confirm_strategy'] = self.confirm_strategy
        if self.pod_naming_policy is not None:
            result['pod_naming_policy'] = self.pod_naming_policy
        if self.force_stride_control is not None:
            result['force_stride_control'] = self.force_stride_control
        if self.max_cell_pod_percentage is not None:
            result['max_cell_pod_percentage'] = self.max_cell_pod_percentage
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('affinity') is not None:
            temp_model = AffinityEntity()
            self.affinity = temp_model.from_map(m['affinity'])
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('custom_labels') is not None:
            self.custom_labels = m.get('custom_labels')
        if m.get('group_count') is not None:
            self.group_count = m.get('group_count')
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('max_group_capacity') is not None:
            self.max_group_capacity = m.get('max_group_capacity')
        if m.get('need_beta') is not None:
            self.need_beta = m.get('need_beta')
        if m.get('need_confirm') is not None:
            self.need_confirm = m.get('need_confirm')
        if m.get('enable_sofa_mesh') is not None:
            self.enable_sofa_mesh = m.get('enable_sofa_mesh')
        if m.get('upgrade_strategy') is not None:
            self.upgrade_strategy = m.get('upgrade_strategy')
        if m.get('confirm_strategy') is not None:
            self.confirm_strategy = m.get('confirm_strategy')
        if m.get('pod_naming_policy') is not None:
            self.pod_naming_policy = m.get('pod_naming_policy')
        if m.get('force_stride_control') is not None:
            self.force_stride_control = m.get('force_stride_control')
        if m.get('max_cell_pod_percentage') is not None:
            self.max_cell_pod_percentage = m.get('max_cell_pod_percentage')
        return self


class HttpsEntryStatus(TeaModel):
    def __init__(
        self,
        backend_port: int = None,
        node_port: int = None,
    ):
        # 统一接入实例https entry分配到的spanner 后端端口
        self.backend_port = backend_port
        # 统一接入实例对应的service分配到的节点端口
        self.node_port = node_port

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.backend_port is not None:
            result['backend_port'] = self.backend_port
        if self.node_port is not None:
            result['node_port'] = self.node_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('backend_port') is not None:
            self.backend_port = m.get('backend_port')
        if m.get('node_port') is not None:
            self.node_port = m.get('node_port')
        return self


class ElasticConfig(TeaModel):
    def __init__(
        self,
        fixed_replica: FixedReplicaElasticConfig = None,
        hpa: HPABasedElasticConfig = None,
        mode: str = None,
    ):
        # 固定副本数配置。
        self.fixed_replica = fixed_replica
        # 弹性伸缩配置
        self.hpa = hpa
        # 弹性配置模式：
        # FIXED 固定副本数
        # HPA 弹性伸缩
        self.mode = mode

    def validate(self):
        if self.fixed_replica:
            self.fixed_replica.validate()
        if self.hpa:
            self.hpa.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fixed_replica is not None:
            result['fixed_replica'] = self.fixed_replica.to_map()
        if self.hpa is not None:
            result['hpa'] = self.hpa.to_map()
        if self.mode is not None:
            result['mode'] = self.mode
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('fixed_replica') is not None:
            temp_model = FixedReplicaElasticConfig()
            self.fixed_replica = temp_model.from_map(m['fixed_replica'])
        if m.get('hpa') is not None:
            temp_model = HPABasedElasticConfig()
            self.hpa = temp_model.from_map(m['hpa'])
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        return self


class IngressConfig(TeaModel):
    def __init__(
        self,
        domain: str = None,
        listeners: List[LoadBalancerListenerWithRule] = None,
        load_balancer_iaas_id: str = None,
        load_balancer_name: str = None,
        load_balancer_type: str = None,
        name: str = None,
        spanner_cluster_id: str = None,
        unified_access_entries: List[str] = None,
        unified_access_entry_ports: List[int] = None,
        unified_access_instance_name: str = None,
        unified_access_instance_federated_id: str = None,
        listeners_v2: List[LoadBalancerListener] = None,
        unified_access_route_rule: str = None,
    ):
        # 统一接入域名。
        self.domain = domain
        # 监听及转发规则配置。
        self.listeners = listeners
        # 关联的负载均衡实例的ID。
        self.load_balancer_iaas_id = load_balancer_iaas_id
        # 关联负载均衡实例名称。
        self.load_balancer_name = load_balancer_name
        # 负载均衡网络类型。
        self.load_balancer_type = load_balancer_type
        # ingress名称。
        self.name = name
        # Spanner集群名称。
        self.spanner_cluster_id = spanner_cluster_id
        # 统一接入协议（http|https）
        self.unified_access_entries = unified_access_entries
        # 与统一接入协议相对应的统一接入实例入端口列表
        self.unified_access_entry_ports = unified_access_entry_ports
        # 所属统一接入实例
        self.unified_access_instance_name = unified_access_instance_name
        # 统一接入实例联邦负载均衡id
        self.unified_access_instance_federated_id = unified_access_instance_federated_id
        # 监听及转发规则配置 V2
        self.listeners_v2 = listeners_v2
        # 统一接入路由模式（LDC|NONLDC）
        self.unified_access_route_rule = unified_access_route_rule

    def validate(self):
        if self.listeners:
            for k in self.listeners:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        if self.listeners_v2:
            for k in self.listeners_v2:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['domain'] = self.domain
        result['listeners'] = []
        if self.listeners is not None:
            for k in self.listeners:
                result['listeners'].append(k.to_map() if k else None)
        if self.load_balancer_iaas_id is not None:
            result['load_balancer_iaas_id'] = self.load_balancer_iaas_id
        if self.load_balancer_name is not None:
            result['load_balancer_name'] = self.load_balancer_name
        if self.load_balancer_type is not None:
            result['load_balancer_type'] = self.load_balancer_type
        if self.name is not None:
            result['name'] = self.name
        if self.spanner_cluster_id is not None:
            result['spanner_cluster_id'] = self.spanner_cluster_id
        if self.unified_access_entries is not None:
            result['unified_access_entries'] = self.unified_access_entries
        if self.unified_access_entry_ports is not None:
            result['unified_access_entry_ports'] = self.unified_access_entry_ports
        if self.unified_access_instance_name is not None:
            result['unified_access_instance_name'] = self.unified_access_instance_name
        if self.unified_access_instance_federated_id is not None:
            result['unified_access_instance_federated_id'] = self.unified_access_instance_federated_id
        result['listeners_v2'] = []
        if self.listeners_v2 is not None:
            for k in self.listeners_v2:
                result['listeners_v2'].append(k.to_map() if k else None)
        if self.unified_access_route_rule is not None:
            result['unified_access_route_rule'] = self.unified_access_route_rule
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        self.listeners = []
        if m.get('listeners') is not None:
            for k in m.get('listeners'):
                temp_model = LoadBalancerListenerWithRule()
                self.listeners.append(temp_model.from_map(k))
        if m.get('load_balancer_iaas_id') is not None:
            self.load_balancer_iaas_id = m.get('load_balancer_iaas_id')
        if m.get('load_balancer_name') is not None:
            self.load_balancer_name = m.get('load_balancer_name')
        if m.get('load_balancer_type') is not None:
            self.load_balancer_type = m.get('load_balancer_type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('spanner_cluster_id') is not None:
            self.spanner_cluster_id = m.get('spanner_cluster_id')
        if m.get('unified_access_entries') is not None:
            self.unified_access_entries = m.get('unified_access_entries')
        if m.get('unified_access_entry_ports') is not None:
            self.unified_access_entry_ports = m.get('unified_access_entry_ports')
        if m.get('unified_access_instance_name') is not None:
            self.unified_access_instance_name = m.get('unified_access_instance_name')
        if m.get('unified_access_instance_federated_id') is not None:
            self.unified_access_instance_federated_id = m.get('unified_access_instance_federated_id')
        self.listeners_v2 = []
        if m.get('listeners_v2') is not None:
            for k in m.get('listeners_v2'):
                temp_model = LoadBalancerListener()
                self.listeners_v2.append(temp_model.from_map(k))
        if m.get('unified_access_route_rule') is not None:
            self.unified_access_route_rule = m.get('unified_access_route_rule')
        return self


class DeploymentStatus(TeaModel):
    def __init__(
        self,
        available_replicas: int = None,
        conditions: List[DeploymentCondition] = None,
        observed_generation: int = None,
        ready_replicas: int = None,
        replicas: int = None,
        unavailable_replicas: int = None,
        updated_replicas: int = None,
    ):
        # Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
        # 
        self.available_replicas = available_replicas
        # Represents the latest available observations of a deployment_s current state.
        # 
        self.conditions = conditions
        # The generation observed by the deployment controller.
        # 
        self.observed_generation = observed_generation
        # Total number of ready pods targeted by this deployment.
        # 
        self.ready_replicas = ready_replicas
        # Total number of non-terminated pods targeted by this deployment (their labels match the selector).
        # 
        self.replicas = replicas
        # Total number of unavailable pods targeted by this deployment.
        self.unavailable_replicas = unavailable_replicas
        # Total number of non-terminated pods targeted by this deployment that have the desired template spec.
        self.updated_replicas = updated_replicas

    def validate(self):
        self.validate_required(self.available_replicas, 'available_replicas')
        self.validate_required(self.conditions, 'conditions')
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        self.validate_required(self.ready_replicas, 'ready_replicas')
        self.validate_required(self.replicas, 'replicas')
        self.validate_required(self.unavailable_replicas, 'unavailable_replicas')
        self.validate_required(self.updated_replicas, 'updated_replicas')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_replicas is not None:
            result['available_replicas'] = self.available_replicas
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        if self.observed_generation is not None:
            result['observed_generation'] = self.observed_generation
        if self.ready_replicas is not None:
            result['ready_replicas'] = self.ready_replicas
        if self.replicas is not None:
            result['replicas'] = self.replicas
        if self.unavailable_replicas is not None:
            result['unavailable_replicas'] = self.unavailable_replicas
        if self.updated_replicas is not None:
            result['updated_replicas'] = self.updated_replicas
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('available_replicas') is not None:
            self.available_replicas = m.get('available_replicas')
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = DeploymentCondition()
                self.conditions.append(temp_model.from_map(k))
        if m.get('observed_generation') is not None:
            self.observed_generation = m.get('observed_generation')
        if m.get('ready_replicas') is not None:
            self.ready_replicas = m.get('ready_replicas')
        if m.get('replicas') is not None:
            self.replicas = m.get('replicas')
        if m.get('unavailable_replicas') is not None:
            self.unavailable_replicas = m.get('unavailable_replicas')
        if m.get('updated_replicas') is not None:
            self.updated_replicas = m.get('updated_replicas')
        return self


class FederatedDeploymentStatusTopologies(TeaModel):
    def __init__(
        self,
        message: str = None,
        name: str = None,
        status: str = None,
        time: str = None,
    ):
        # message
        self.message = message
        # name
        self.name = name
        # status
        self.status = status
        # time
        self.time = time

    def validate(self):
        self.validate_required(self.message, 'message')
        self.validate_required(self.name, 'name')
        self.validate_required(self.status, 'status')
        self.validate_required(self.time, 'time')
        if self.time is not None:
            self.validate_pattern(self.time, 'time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        if self.status is not None:
            result['status'] = self.status
        if self.time is not None:
            result['time'] = self.time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('time') is not None:
            self.time = m.get('time')
        return self


class ClusterIpService(TeaModel):
    def __init__(
        self,
        name: str = None,
        ports: List[ServicePortMapping] = None,
    ):
        # 对应ClusterIP service名称。
        self.name = name
        # ClusterIP service暴露的端口列表。
        self.ports = ports

    def validate(self):
        self.validate_required(self.name, 'name')
        if self.ports:
            for k in self.ports:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        result['ports'] = []
        if self.ports is not None:
            for k in self.ports:
                result['ports'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        self.ports = []
        if m.get('ports') is not None:
            for k in m.get('ports'):
                temp_model = ServicePortMapping()
                self.ports.append(temp_model.from_map(k))
        return self


class TrafficConfig(TeaModel):
    def __init__(
        self,
        registry_managed: bool = None,
        registry_traffic_off_wait_sec: int = None,
    ):
        # 是否摘除注册中心流量
        self.registry_managed = registry_managed
        # 摘流等待时间
        self.registry_traffic_off_wait_sec = registry_traffic_off_wait_sec

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.registry_managed is not None:
            result['registry_managed'] = self.registry_managed
        if self.registry_traffic_off_wait_sec is not None:
            result['registry_traffic_off_wait_sec'] = self.registry_traffic_off_wait_sec
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('registry_managed') is not None:
            self.registry_managed = m.get('registry_managed')
        if m.get('registry_traffic_off_wait_sec') is not None:
            self.registry_traffic_off_wait_sec = m.get('registry_traffic_off_wait_sec')
        return self


class LocalSubClusterDetail(TeaModel):
    def __init__(
        self,
        available: int = None,
        desired: int = None,
        image: str = None,
        labels: List[Label] = None,
        message: str = None,
        ready: int = None,
        state: str = None,
        updated: int = None,
        version: str = None,
        overrides: List[SpannerSubClusterOverrides] = None,
    ):
        # 可用实例数
        self.available = available
        # 期望实例数
        self.desired = desired
        # 容器镜像地址
        self.image = image
        # 发布容器带的标签
        self.labels = labels
        # 可能存在的错误信息
        self.message = message
        # 健康实例数
        self.ready = ready
        # 实际sub cluster 状态
        self.state = state
        # 已更新实例数
        self.updated = updated
        # 容器版本
        self.version = version
        # 多个机房下的覆盖配置项
        self.overrides = overrides

    def validate(self):
        self.validate_required(self.image, 'image')
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.state, 'state')
        self.validate_required(self.version, 'version')
        if self.overrides:
            for k in self.overrides:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available is not None:
            result['available'] = self.available
        if self.desired is not None:
            result['desired'] = self.desired
        if self.image is not None:
            result['image'] = self.image
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.message is not None:
            result['message'] = self.message
        if self.ready is not None:
            result['ready'] = self.ready
        if self.state is not None:
            result['state'] = self.state
        if self.updated is not None:
            result['updated'] = self.updated
        if self.version is not None:
            result['version'] = self.version
        result['overrides'] = []
        if self.overrides is not None:
            for k in self.overrides:
                result['overrides'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('available') is not None:
            self.available = m.get('available')
        if m.get('desired') is not None:
            self.desired = m.get('desired')
        if m.get('image') is not None:
            self.image = m.get('image')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('ready') is not None:
            self.ready = m.get('ready')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('updated') is not None:
            self.updated = m.get('updated')
        if m.get('version') is not None:
            self.version = m.get('version')
        self.overrides = []
        if m.get('overrides') is not None:
            for k in m.get('overrides'):
                temp_model = SpannerSubClusterOverrides()
                self.overrides.append(temp_model.from_map(k))
        return self


class LoadBalancerService(TeaModel):
    def __init__(
        self,
        domain: str = None,
        listeners: List[LoadBalancerListener] = None,
        load_balancer_iaas_id: str = None,
        load_balancer_name: str = None,
        name: str = None,
        spanner_cluster_id: str = None,
        address_type: str = None,
        cell_slb_iaas_id_map: List[MapStringToString] = None,
        cell_lb_vip_map: List[MapStringToString] = None,
        use_fed_loadbalancer: bool = None,
        fed_loadbalancer_name: str = None,
        enable_graceful_shutdown_waiting: bool = None,
        graceful_shutdown_waiting_time: int = None,
        enable_in_cluster_forward_optimization: bool = None,
    ):
        # 域名。
        self.domain = domain
        # 负载均衡实例监听列表。
        self.listeners = listeners
        # 关联的负载均衡实例的ID。
        self.load_balancer_iaas_id = load_balancer_iaas_id
        # LoadBalancer类型service关联负载均衡实例名称。
        self.load_balancer_name = load_balancer_name
        # LoadBalancer类型service名称。
        self.name = name
        # Spanner集群名称。
        self.spanner_cluster_id = spanner_cluster_id
        # 负载均衡实例的网络类型（internet | intranet | office | multidomain）
        self.address_type = address_type
        # 该服务在每个 cell 下要复用的负载均衡实例 ID
        self.cell_slb_iaas_id_map = cell_slb_iaas_id_map
        # custom address type模式下，指定各cell负载均衡vip
        self.cell_lb_vip_map = cell_lb_vip_map
        # 是否使用联邦负载均衡实例
        self.use_fed_loadbalancer = use_fed_loadbalancer
        # 联邦负载均衡实例名称
        self.fed_loadbalancer_name = fed_loadbalancer_name
        # 是否开启优雅下线等待，默认为false。
        self.enable_graceful_shutdown_waiting = enable_graceful_shutdown_waiting
        # 优雅下线等待时间，单位秒，默认0.
        self.graceful_shutdown_waiting_time = graceful_shutdown_waiting_time
        # 是否开启集群内转发优化（集群内访问lb vip时是否走kube-proxy转发链路）
        self.enable_in_cluster_forward_optimization = enable_in_cluster_forward_optimization

    def validate(self):
        self.validate_required(self.listeners, 'listeners')
        if self.listeners:
            for k in self.listeners:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        if self.cell_slb_iaas_id_map:
            for k in self.cell_slb_iaas_id_map:
                if k:
                    k.validate()
        if self.cell_lb_vip_map:
            for k in self.cell_lb_vip_map:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['domain'] = self.domain
        result['listeners'] = []
        if self.listeners is not None:
            for k in self.listeners:
                result['listeners'].append(k.to_map() if k else None)
        if self.load_balancer_iaas_id is not None:
            result['load_balancer_iaas_id'] = self.load_balancer_iaas_id
        if self.load_balancer_name is not None:
            result['load_balancer_name'] = self.load_balancer_name
        if self.name is not None:
            result['name'] = self.name
        if self.spanner_cluster_id is not None:
            result['spanner_cluster_id'] = self.spanner_cluster_id
        if self.address_type is not None:
            result['address_type'] = self.address_type
        result['cell_slb_iaas_id_map'] = []
        if self.cell_slb_iaas_id_map is not None:
            for k in self.cell_slb_iaas_id_map:
                result['cell_slb_iaas_id_map'].append(k.to_map() if k else None)
        result['cell_lb_vip_map'] = []
        if self.cell_lb_vip_map is not None:
            for k in self.cell_lb_vip_map:
                result['cell_lb_vip_map'].append(k.to_map() if k else None)
        if self.use_fed_loadbalancer is not None:
            result['use_fed_loadbalancer'] = self.use_fed_loadbalancer
        if self.fed_loadbalancer_name is not None:
            result['fed_loadbalancer_name'] = self.fed_loadbalancer_name
        if self.enable_graceful_shutdown_waiting is not None:
            result['enable_graceful_shutdown_waiting'] = self.enable_graceful_shutdown_waiting
        if self.graceful_shutdown_waiting_time is not None:
            result['graceful_shutdown_waiting_time'] = self.graceful_shutdown_waiting_time
        if self.enable_in_cluster_forward_optimization is not None:
            result['enable_in_cluster_forward_optimization'] = self.enable_in_cluster_forward_optimization
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        self.listeners = []
        if m.get('listeners') is not None:
            for k in m.get('listeners'):
                temp_model = LoadBalancerListener()
                self.listeners.append(temp_model.from_map(k))
        if m.get('load_balancer_iaas_id') is not None:
            self.load_balancer_iaas_id = m.get('load_balancer_iaas_id')
        if m.get('load_balancer_name') is not None:
            self.load_balancer_name = m.get('load_balancer_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('spanner_cluster_id') is not None:
            self.spanner_cluster_id = m.get('spanner_cluster_id')
        if m.get('address_type') is not None:
            self.address_type = m.get('address_type')
        self.cell_slb_iaas_id_map = []
        if m.get('cell_slb_iaas_id_map') is not None:
            for k in m.get('cell_slb_iaas_id_map'):
                temp_model = MapStringToString()
                self.cell_slb_iaas_id_map.append(temp_model.from_map(k))
        self.cell_lb_vip_map = []
        if m.get('cell_lb_vip_map') is not None:
            for k in m.get('cell_lb_vip_map'):
                temp_model = MapStringToString()
                self.cell_lb_vip_map.append(temp_model.from_map(k))
        if m.get('use_fed_loadbalancer') is not None:
            self.use_fed_loadbalancer = m.get('use_fed_loadbalancer')
        if m.get('fed_loadbalancer_name') is not None:
            self.fed_loadbalancer_name = m.get('fed_loadbalancer_name')
        if m.get('enable_graceful_shutdown_waiting') is not None:
            self.enable_graceful_shutdown_waiting = m.get('enable_graceful_shutdown_waiting')
        if m.get('graceful_shutdown_waiting_time') is not None:
            self.graceful_shutdown_waiting_time = m.get('graceful_shutdown_waiting_time')
        if m.get('enable_in_cluster_forward_optimization') is not None:
            self.enable_in_cluster_forward_optimization = m.get('enable_in_cluster_forward_optimization')
        return self


class VolumeClaimConfig(TeaModel):
    def __init__(
        self,
        name: str = None,
        storage_class: str = None,
        resource_requirement_config: ResourceRequirementConfig = None,
    ):
        # name
        self.name = name
        # storage_class
        self.storage_class = storage_class
        # resourceRequirementConfig
        self.resource_requirement_config = resource_requirement_config

    def validate(self):
        if self.resource_requirement_config:
            self.resource_requirement_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.storage_class is not None:
            result['storage_class'] = self.storage_class
        if self.resource_requirement_config is not None:
            result['resource_requirement_config'] = self.resource_requirement_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('storage_class') is not None:
            self.storage_class = m.get('storage_class')
        if m.get('resource_requirement_config') is not None:
            temp_model = ResourceRequirementConfig()
            self.resource_requirement_config = temp_model.from_map(m['resource_requirement_config'])
        return self


class SecretData(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # secret data key
        self.key = key
        # secret data value
        self.value = value

    def validate(self):
        self.validate_required(self.key, 'key')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class CustomHook(TeaModel):
    def __init__(
        self,
        hook_scope: str = None,
        hook_type: str = None,
        hook_name: str = None,
        hook_strategy: str = None,
        custom_num: int = None,
        api_hook_config: ApiHookConfig = None,
        has_hook_config: HasHookConfig = None,
        ignore_supported: bool = None,
        timeout_millis: int = None,
        un_override: bool = None,
        need_confirm: bool = None,
    ):
        # 卡点范围，目前只支持分批
        self.hook_scope = hook_scope
        # 卡点类型：api或has
        self.hook_type = hook_type
        # 卡点名称
        self.hook_name = hook_name
        # 卡点执行策略：each-每个分组，first-第一个分组，last-最后一个分组，custom-自定义分组。
        # 默认每个分组都会执行。
        self.hook_strategy = hook_strategy
        # 自定义批次编号，从1开始。hook_strategy=custom时有效
        self.custom_num = custom_num
        # api类型卡点配置，当hook_type=api时不能为空
        self.api_hook_config = api_hook_config
        # 守夜人类型卡点配置，当hook_type=has时不能为空
        self.has_hook_config = has_hook_config
        # 【暂不支持】是否允许忽略
        self.ignore_supported = ignore_supported
        # 【暂不支持】任务超时时间，单位毫秒，默认10分钟
        self.timeout_millis = timeout_millis
        # 【暂不支持】默认true
        self.un_override = un_override
        # 【暂不支持】是否需要确认
        self.need_confirm = need_confirm

    def validate(self):
        self.validate_required(self.hook_scope, 'hook_scope')
        self.validate_required(self.hook_type, 'hook_type')
        if self.api_hook_config:
            self.api_hook_config.validate()
        if self.has_hook_config:
            self.has_hook_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hook_scope is not None:
            result['hook_scope'] = self.hook_scope
        if self.hook_type is not None:
            result['hook_type'] = self.hook_type
        if self.hook_name is not None:
            result['hook_name'] = self.hook_name
        if self.hook_strategy is not None:
            result['hook_strategy'] = self.hook_strategy
        if self.custom_num is not None:
            result['custom_num'] = self.custom_num
        if self.api_hook_config is not None:
            result['api_hook_config'] = self.api_hook_config.to_map()
        if self.has_hook_config is not None:
            result['has_hook_config'] = self.has_hook_config.to_map()
        if self.ignore_supported is not None:
            result['ignore_supported'] = self.ignore_supported
        if self.timeout_millis is not None:
            result['timeout_millis'] = self.timeout_millis
        if self.un_override is not None:
            result['un_override'] = self.un_override
        if self.need_confirm is not None:
            result['need_confirm'] = self.need_confirm
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('hook_scope') is not None:
            self.hook_scope = m.get('hook_scope')
        if m.get('hook_type') is not None:
            self.hook_type = m.get('hook_type')
        if m.get('hook_name') is not None:
            self.hook_name = m.get('hook_name')
        if m.get('hook_strategy') is not None:
            self.hook_strategy = m.get('hook_strategy')
        if m.get('custom_num') is not None:
            self.custom_num = m.get('custom_num')
        if m.get('api_hook_config') is not None:
            temp_model = ApiHookConfig()
            self.api_hook_config = temp_model.from_map(m['api_hook_config'])
        if m.get('has_hook_config') is not None:
            temp_model = HasHookConfig()
            self.has_hook_config = temp_model.from_map(m['has_hook_config'])
        if m.get('ignore_supported') is not None:
            self.ignore_supported = m.get('ignore_supported')
        if m.get('timeout_millis') is not None:
            self.timeout_millis = m.get('timeout_millis')
        if m.get('un_override') is not None:
            self.un_override = m.get('un_override')
        if m.get('need_confirm') is not None:
            self.need_confirm = m.get('need_confirm')
        return self


class ReleaseBatchObj(TeaModel):
    def __init__(
        self,
        batch_num: int = None,
        cell_servers: List[CellServer] = None,
    ):
        # 第一个批次
        self.batch_num = batch_num
        # 单元内服务数组
        self.cell_servers = cell_servers

    def validate(self):
        self.validate_required(self.batch_num, 'batch_num')
        self.validate_required(self.cell_servers, 'cell_servers')
        if self.cell_servers:
            for k in self.cell_servers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_num is not None:
            result['batch_num'] = self.batch_num
        result['cell_servers'] = []
        if self.cell_servers is not None:
            for k in self.cell_servers:
                result['cell_servers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('batch_num') is not None:
            self.batch_num = m.get('batch_num')
        self.cell_servers = []
        if m.get('cell_servers') is not None:
            for k in m.get('cell_servers'):
                temp_model = CellServer()
                self.cell_servers.append(temp_model.from_map(k))
        return self


class OpsApplication(TeaModel):
    def __init__(
        self,
        name: str = None,
        version: str = None,
        status: str = None,
    ):
        # 应用名称
        self.name = name
        # 应用发布版本（部分运维操作可能不包含版本信息，为null）
        self.version = version
        # 应用（服务）当前运维状态。取值列表： INITING：初始化中； INIT_FAILED：初始化失败； INITED：初始化完成； EXECUTING：执行中； SUCCESS：执行成功； FAILED：执行失败； ROLLBACKED：已回滚； CANCELED：已取消
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.version is not None:
            result['version'] = self.version
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class DeploymentSpec(TeaModel):
    def __init__(
        self,
        min_ready_seconds: int = None,
        paused: bool = None,
        progress_deadline_seconds: int = None,
        replicas: int = None,
        revision_history_limit: int = None,
        selector: LabelSelector = None,
        strategy: DeploymentStrategy = None,
        template: PodTemplateSpec = None,
    ):
        # Minimum number of seconds for which a newly created pod should be ready without any of its container crashing
        self.min_ready_seconds = min_ready_seconds
        # Indicates that the deployment is paused.
        # 
        self.paused = paused
        # he maximum time in seconds for a deployment to make progress before it is considered to be failed.
        self.progress_deadline_seconds = progress_deadline_seconds
        # Number of desired pods.
        self.replicas = replicas
        # The number of old ReplicaSets to retain to allow rollback.
        self.revision_history_limit = revision_history_limit
        # Label selector for pods.
        self.selector = selector
        # The deployment strategy to use to replace existing pods with new ones.
        # 
        self.strategy = strategy
        # Template describes the pods that will be created.
        self.template = template

    def validate(self):
        self.validate_required(self.replicas, 'replicas')
        if self.selector:
            self.selector.validate()
        if self.strategy:
            self.strategy.validate()
        self.validate_required(self.template, 'template')
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.min_ready_seconds is not None:
            result['min_ready_seconds'] = self.min_ready_seconds
        if self.paused is not None:
            result['paused'] = self.paused
        if self.progress_deadline_seconds is not None:
            result['progress_deadline_seconds'] = self.progress_deadline_seconds
        if self.replicas is not None:
            result['replicas'] = self.replicas
        if self.revision_history_limit is not None:
            result['revision_history_limit'] = self.revision_history_limit
        if self.selector is not None:
            result['selector'] = self.selector.to_map()
        if self.strategy is not None:
            result['strategy'] = self.strategy.to_map()
        if self.template is not None:
            result['template'] = self.template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('min_ready_seconds') is not None:
            self.min_ready_seconds = m.get('min_ready_seconds')
        if m.get('paused') is not None:
            self.paused = m.get('paused')
        if m.get('progress_deadline_seconds') is not None:
            self.progress_deadline_seconds = m.get('progress_deadline_seconds')
        if m.get('replicas') is not None:
            self.replicas = m.get('replicas')
        if m.get('revision_history_limit') is not None:
            self.revision_history_limit = m.get('revision_history_limit')
        if m.get('selector') is not None:
            temp_model = LabelSelector()
            self.selector = temp_model.from_map(m['selector'])
        if m.get('strategy') is not None:
            temp_model = DeploymentStrategy()
            self.strategy = temp_model.from_map(m['strategy'])
        if m.get('template') is not None:
            temp_model = PodTemplateSpec()
            self.template = temp_model.from_map(m['template'])
        return self


class SidecarTemplate(TeaModel):
    def __init__(
        self,
        id: str = None,
        region_id: str = None,
        scope: str = None,
        sidecar_name: str = None,
        sidecar_version: str = None,
        template: str = None,
        type: str = None,
        workspace_group_id: str = None,
        workspace_id: str = None,
    ):
        # sidecar模版id
        self.id = id
        # region_id
        self.region_id = region_id
        # 
        # 模板生效范围
        self.scope = scope
        # sidecar名称
        self.sidecar_name = sidecar_name
        # sidecar模版版本
        self.sidecar_version = sidecar_version
        # sidercar模版
        self.template = template
        # 这个字段是lhc专用，表示此模板的来源，META为sidecar元数据来源，XFLUSH为系统模板
        # 本结构体同时还暂时兼容了调用sidecar元数据openapi的使用，后期会只用于LHC用途，届时会去掉sidecar元数据接口的字段。
        self.type = type
        # workspace_group_id
        self.workspace_group_id = workspace_group_id
        # workspace_id
        self.workspace_id = workspace_id

    def validate(self):
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.sidecar_name, 'sidecar_name')
        self.validate_required(self.sidecar_version, 'sidecar_version')
        self.validate_required(self.template, 'template')
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_id, 'workspace_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.region_id is not None:
            result['region_id'] = self.region_id
        if self.scope is not None:
            result['scope'] = self.scope
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.template is not None:
            result['template'] = self.template
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('region_id') is not None:
            self.region_id = m.get('region_id')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('template') is not None:
            self.template = m.get('template')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        return self


class FedImagePullSecretOverride(TeaModel):
    def __init__(
        self,
        data: RegistryAccout = None,
        name: str = None,
        name_override: str = None,
    ):
        # override data
        self.data = data
        # cell name
        self.name = name
        # cell name override
        self.name_override = name_override

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.name_override, 'name_override')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.name_override is not None:
            result['name_override'] = self.name_override
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data') is not None:
            temp_model = RegistryAccout()
            self.data = temp_model.from_map(m['data'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('name_override') is not None:
            self.name_override = m.get('name_override')
        return self


class AppReleaseConfig(TeaModel):
    def __init__(
        self,
        name: str = None,
        image: str = None,
        commit_id: str = None,
        commit_branch: str = None,
        last_revision_id: str = None,
        revision_id: str = None,
        revision_diff: str = None,
    ):
        # 名称
        self.name = name
        # 应用镜像
        self.image = image
        # commitID
        self.commit_id = commit_id
        # 代码分支
        self.commit_branch = commit_branch
        # diff基准版本，上一次最新发布的版本
        self.last_revision_id = last_revision_id
        # 应用服务版本id
        self.revision_id = revision_id
        # 应用服务版本diff摘要信息
        self.revision_diff = revision_diff

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.image, 'image')
        self.validate_required(self.commit_id, 'commit_id')
        self.validate_required(self.commit_branch, 'commit_branch')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.image is not None:
            result['image'] = self.image
        if self.commit_id is not None:
            result['commit_id'] = self.commit_id
        if self.commit_branch is not None:
            result['commit_branch'] = self.commit_branch
        if self.last_revision_id is not None:
            result['last_revision_id'] = self.last_revision_id
        if self.revision_id is not None:
            result['revision_id'] = self.revision_id
        if self.revision_diff is not None:
            result['revision_diff'] = self.revision_diff
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('commit_id') is not None:
            self.commit_id = m.get('commit_id')
        if m.get('commit_branch') is not None:
            self.commit_branch = m.get('commit_branch')
        if m.get('last_revision_id') is not None:
            self.last_revision_id = m.get('last_revision_id')
        if m.get('revision_id') is not None:
            self.revision_id = m.get('revision_id')
        if m.get('revision_diff') is not None:
            self.revision_diff = m.get('revision_diff')
        return self


class ResourceOverride(TeaModel):
    def __init__(
        self,
        cell: str = None,
        path: str = None,
        value: str = None,
        type: str = None,
    ):
        # 部署单元名称，ALL 代表所有部署单元
        self.cell = cell
        # fed 资源路径
        self.path = path
        # 值
        self.value = value
        # 值的字段类型，支持 string、number、boolean
        self.type = type

    def validate(self):
        self.validate_required(self.cell, 'cell')
        self.validate_required(self.path, 'path')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell is not None:
            result['cell'] = self.cell
        if self.path is not None:
            result['path'] = self.path
        if self.value is not None:
            result['value'] = self.value
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class AppDeployTask(TeaModel):
    def __init__(
        self,
        action_code: str = None,
        app_deploy_cells: List[AppDeployCell] = None,
        confirm_supported: bool = None,
        data: str = None,
        id: str = None,
        ignore_supported: bool = None,
        retry_supported: bool = None,
        state: str = None,
        started_time: str = None,
        finished_time: str = None,
        message_detail: str = None,
        task_type: str = None,
        task_display_name: str = None,
    ):
        # 操作code
        self.action_code = action_code
        # 当前任务的发布单元列表
        self.app_deploy_cells = app_deploy_cells
        # 是否支持确认操作
        self.confirm_supported = confirm_supported
        # 上下文数据，json字符串
        self.data = data
        # id
        self.id = id
        # 是否支持跳过操作
        self.ignore_supported = ignore_supported
        # 是否支持重试操作
        self.retry_supported = retry_supported
        # 当前状态
        self.state = state
        # 开始时间。
        self.started_time = started_time
        # 结束时间。
        self.finished_time = finished_time
        # message detail
        self.message_detail = message_detail
        # 任务类型
        self.task_type = task_type
        # 任务显示名称，自定义卡点任务才会有值
        self.task_display_name = task_display_name

    def validate(self):
        self.validate_required(self.action_code, 'action_code')
        self.validate_required(self.app_deploy_cells, 'app_deploy_cells')
        if self.app_deploy_cells:
            for k in self.app_deploy_cells:
                if k:
                    k.validate()
        self.validate_required(self.confirm_supported, 'confirm_supported')
        self.validate_required(self.data, 'data')
        self.validate_required(self.id, 'id')
        self.validate_required(self.ignore_supported, 'ignore_supported')
        self.validate_required(self.retry_supported, 'retry_supported')
        self.validate_required(self.state, 'state')
        self.validate_required(self.started_time, 'started_time')
        if self.started_time is not None:
            self.validate_pattern(self.started_time, 'started_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.finished_time, 'finished_time')
        if self.finished_time is not None:
            self.validate_pattern(self.finished_time, 'finished_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_code is not None:
            result['action_code'] = self.action_code
        result['app_deploy_cells'] = []
        if self.app_deploy_cells is not None:
            for k in self.app_deploy_cells:
                result['app_deploy_cells'].append(k.to_map() if k else None)
        if self.confirm_supported is not None:
            result['confirm_supported'] = self.confirm_supported
        if self.data is not None:
            result['data'] = self.data
        if self.id is not None:
            result['id'] = self.id
        if self.ignore_supported is not None:
            result['ignore_supported'] = self.ignore_supported
        if self.retry_supported is not None:
            result['retry_supported'] = self.retry_supported
        if self.state is not None:
            result['state'] = self.state
        if self.started_time is not None:
            result['started_time'] = self.started_time
        if self.finished_time is not None:
            result['finished_time'] = self.finished_time
        if self.message_detail is not None:
            result['message_detail'] = self.message_detail
        if self.task_type is not None:
            result['task_type'] = self.task_type
        if self.task_display_name is not None:
            result['task_display_name'] = self.task_display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_code') is not None:
            self.action_code = m.get('action_code')
        self.app_deploy_cells = []
        if m.get('app_deploy_cells') is not None:
            for k in m.get('app_deploy_cells'):
                temp_model = AppDeployCell()
                self.app_deploy_cells.append(temp_model.from_map(k))
        if m.get('confirm_supported') is not None:
            self.confirm_supported = m.get('confirm_supported')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('ignore_supported') is not None:
            self.ignore_supported = m.get('ignore_supported')
        if m.get('retry_supported') is not None:
            self.retry_supported = m.get('retry_supported')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('started_time') is not None:
            self.started_time = m.get('started_time')
        if m.get('finished_time') is not None:
            self.finished_time = m.get('finished_time')
        if m.get('message_detail') is not None:
            self.message_detail = m.get('message_detail')
        if m.get('task_type') is not None:
            self.task_type = m.get('task_type')
        if m.get('task_display_name') is not None:
            self.task_display_name = m.get('task_display_name')
        return self


class ContainerInfo(TeaModel):
    def __init__(
        self,
        container_id: str = None,
        image: str = None,
        last_start_time: str = None,
        name: str = None,
        restart_count: int = None,
        state: str = None,
        spec: ContainerSpec = None,
    ):
        # 容器id
        self.container_id = container_id
        # 容器镜像
        self.image = image
        # 最后启动时间
        self.last_start_time = last_start_time
        # 容器镜像
        self.name = name
        # 重启次数
        self.restart_count = restart_count
        # 容器运行状态
        self.state = state
        # 容器spec配置。
        self.spec = spec

    def validate(self):
        self.validate_required(self.container_id, 'container_id')
        self.validate_required(self.image, 'image')
        self.validate_required(self.last_start_time, 'last_start_time')
        if self.last_start_time is not None:
            self.validate_pattern(self.last_start_time, 'last_start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.name, 'name')
        self.validate_required(self.restart_count, 'restart_count')
        self.validate_required(self.state, 'state')
        self.validate_required(self.spec, 'spec')
        if self.spec:
            self.spec.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_id is not None:
            result['container_id'] = self.container_id
        if self.image is not None:
            result['image'] = self.image
        if self.last_start_time is not None:
            result['last_start_time'] = self.last_start_time
        if self.name is not None:
            result['name'] = self.name
        if self.restart_count is not None:
            result['restart_count'] = self.restart_count
        if self.state is not None:
            result['state'] = self.state
        if self.spec is not None:
            result['spec'] = self.spec.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('container_id') is not None:
            self.container_id = m.get('container_id')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('last_start_time') is not None:
            self.last_start_time = m.get('last_start_time')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('restart_count') is not None:
            self.restart_count = m.get('restart_count')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('spec') is not None:
            temp_model = ContainerSpec()
            self.spec = temp_model.from_map(m['spec'])
        return self


class UnireleaseSolutionExtInfoLinkeInfo(TeaModel):
    def __init__(
        self,
        release_window: str = None,
        iterations: List[str] = None,
        publisher: List[str] = None,
        release_id: str = None,
    ):
        # linke发布窗口
        self.release_window = release_window
        # ["EI61640467"]
        self.iterations = iterations
        # 发布接口人列表,要求为域账号
        self.publisher = publisher
        # inke发布Id
        self.release_id = release_id

    def validate(self):
        self.validate_required(self.release_window, 'release_window')
        self.validate_required(self.iterations, 'iterations')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.release_window is not None:
            result['release_window'] = self.release_window
        if self.iterations is not None:
            result['iterations'] = self.iterations
        if self.publisher is not None:
            result['publisher'] = self.publisher
        if self.release_id is not None:
            result['release_id'] = self.release_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('release_window') is not None:
            self.release_window = m.get('release_window')
        if m.get('iterations') is not None:
            self.iterations = m.get('iterations')
        if m.get('publisher') is not None:
            self.publisher = m.get('publisher')
        if m.get('release_id') is not None:
            self.release_id = m.get('release_id')
        return self


class OpsComputer(TeaModel):
    def __init__(
        self,
        id: str = None,
        inner_ip: str = None,
        name: str = None,
        status: str = None,
        tasks: List[OpsComputerTask] = None,
        result_msg: str = None,
    ):
        # 计算容器id
        self.id = id
        # 计算容器内网ip
        self.inner_ip = inner_ip
        # 计算容器名称
        self.name = name
        # 计算容器当前运维状态。取值列表： INITED：初始化完成； EXECUTING：执行中； SUCCESS：执行成功； FAILED：执行失败； CANCELED：已取消； IGNORED：已忽略
        self.status = status
        # 计算容器上执行的任务信息。任务信息列表中包含正在执行和执行完成的任务。
        self.tasks = tasks
        # 展示机器失败的摘要信息
        self.result_msg = result_msg

    def validate(self):
        if self.tasks:
            for k in self.tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.inner_ip is not None:
            result['inner_ip'] = self.inner_ip
        if self.name is not None:
            result['name'] = self.name
        if self.status is not None:
            result['status'] = self.status
        result['tasks'] = []
        if self.tasks is not None:
            for k in self.tasks:
                result['tasks'].append(k.to_map() if k else None)
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inner_ip') is not None:
            self.inner_ip = m.get('inner_ip')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.tasks = []
        if m.get('tasks') is not None:
            for k in m.get('tasks'):
                temp_model = OpsComputerTask()
                self.tasks.append(temp_model.from_map(k))
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GrayLabelDownstreamRule(TeaModel):
    def __init__(
        self,
        type: str = None,
        key: str = None,
        condition: str = None,
        value: str = None,
    ):
        # 判断入口流量的方式，目前支持通过header或cookie判断
        self.type = type
        # 用于判断的键
        self.key = key
        # 判断条件，目前支持相等或者不相等
        self.condition = condition
        # 用于判断的值
        self.value = value

    def validate(self):
        self.validate_required(self.type, 'type')
        self.validate_required(self.key, 'key')
        self.validate_required(self.condition, 'condition')
        self.validate_required(self.value, 'value')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.key is not None:
            result['key'] = self.key
        if self.condition is not None:
            result['condition'] = self.condition
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('condition') is not None:
            self.condition = m.get('condition')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class PodStatus(TeaModel):
    def __init__(
        self,
        host_ip: str = None,
        phase: str = None,
        pod_ip: str = None,
        container_statuses: List[ContainerStatus] = None,
    ):
        # 节点ip
        self.host_ip = host_ip
        # pod状态
        self.phase = phase
        # podip
        self.pod_ip = pod_ip
        # pod container status
        self.container_statuses = container_statuses

    def validate(self):
        self.validate_required(self.phase, 'phase')
        self.validate_required(self.container_statuses, 'container_statuses')
        if self.container_statuses:
            for k in self.container_statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host_ip is not None:
            result['host_ip'] = self.host_ip
        if self.phase is not None:
            result['phase'] = self.phase
        if self.pod_ip is not None:
            result['pod_ip'] = self.pod_ip
        result['container_statuses'] = []
        if self.container_statuses is not None:
            for k in self.container_statuses:
                result['container_statuses'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('host_ip') is not None:
            self.host_ip = m.get('host_ip')
        if m.get('phase') is not None:
            self.phase = m.get('phase')
        if m.get('pod_ip') is not None:
            self.pod_ip = m.get('pod_ip')
        self.container_statuses = []
        if m.get('container_statuses') is not None:
            for k in m.get('container_statuses'):
                temp_model = ContainerStatus()
                self.container_statuses.append(temp_model.from_map(k))
        return self


class FederatedServiceTopologyStatus(TeaModel):
    def __init__(
        self,
        topology_name: str = None,
        annotations: List[Annotation] = None,
        status: str = None,
        message: str = None,
    ):
        # 部署单元
        self.topology_name = topology_name
        # annotations
        self.annotations = annotations
        # 状态：succeed、updating、fail
        self.status = status
        # 错误信息
        self.message = message

    def validate(self):
        self.validate_required(self.topology_name, 'topology_name')
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.topology_name is not None:
            result['topology_name'] = self.topology_name
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('topology_name') is not None:
            self.topology_name = m.get('topology_name')
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = Annotation()
                self.annotations.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class SidecarOpsMachineTask(TeaModel):
    def __init__(
        self,
        id: str = None,
        status: str = None,
        properties: str = None,
        message: str = None,
        target: str = None,
        start_time: str = None,
        end_time: str = None,
        target_desc: str = None,
        status_desc: str = None,
    ):
        # 分组ID
        self.id = id
        # 执行状态
        self.status = status
        # 扩展属性 - JSON string
        self.properties = properties
        # 执行信息
        self.message = message
        # 任务名称
        self.target = target
        # 开始时间
        self.start_time = start_time
        # 结束时间
        self.end_time = end_time
        # 任务描述
        self.target_desc = target_desc
        # 状态描述
        self.status_desc = status_desc

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.status, 'status')
        if self.start_time is not None:
            self.validate_pattern(self.start_time, 'start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.end_time is not None:
            self.validate_pattern(self.end_time, 'end_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.status is not None:
            result['status'] = self.status
        if self.properties is not None:
            result['properties'] = self.properties
        if self.message is not None:
            result['message'] = self.message
        if self.target is not None:
            result['target'] = self.target
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.target_desc is not None:
            result['target_desc'] = self.target_desc
        if self.status_desc is not None:
            result['status_desc'] = self.status_desc
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('properties') is not None:
            self.properties = m.get('properties')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('target_desc') is not None:
            self.target_desc = m.get('target_desc')
        if m.get('status_desc') is not None:
            self.status_desc = m.get('status_desc')
        return self


class SidecarConfig(TeaModel):
    def __init__(
        self,
        name: str = None,
        change_feature: bool = None,
        feature_gates: str = None,
        image: str = None,
        change_envs: str = None,
        volume_mounts: List[VolumeMount] = None,
        ext: str = None,
    ):
        # Sidercar 名称
        self.name = name
        # 表达是否修改feature
        self.change_feature = change_feature
        # FEATURE_GATES
        self.feature_gates = feature_gates
        # 镜像地址
        self.image = image
        # 需要修改或自定义新增的sidecar环境变量。
        self.change_envs = change_envs
        # sidecar的pvc挂载配置
        self.volume_mounts = volume_mounts
        # 扩展字段
        self.ext = ext

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.change_feature, 'change_feature')
        self.validate_required(self.image, 'image')
        if self.volume_mounts:
            for k in self.volume_mounts:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.change_feature is not None:
            result['change_feature'] = self.change_feature
        if self.feature_gates is not None:
            result['feature_gates'] = self.feature_gates
        if self.image is not None:
            result['image'] = self.image
        if self.change_envs is not None:
            result['change_envs'] = self.change_envs
        result['volume_mounts'] = []
        if self.volume_mounts is not None:
            for k in self.volume_mounts:
                result['volume_mounts'].append(k.to_map() if k else None)
        if self.ext is not None:
            result['ext'] = self.ext
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('change_feature') is not None:
            self.change_feature = m.get('change_feature')
        if m.get('feature_gates') is not None:
            self.feature_gates = m.get('feature_gates')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('change_envs') is not None:
            self.change_envs = m.get('change_envs')
        self.volume_mounts = []
        if m.get('volume_mounts') is not None:
            for k in m.get('volume_mounts'):
                temp_model = VolumeMount()
                self.volume_mounts.append(temp_model.from_map(k))
        if m.get('ext') is not None:
            self.ext = m.get('ext')
        return self


class Workspace(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
    ):
        # workspace id
        self.id = id
        # workspace name
        self.name = name

    def validate(self):
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class OpsApplicationGroup(TeaModel):
    def __init__(
        self,
        applications: List[OpsApplication] = None,
    ):
        # 此运维应用组中包含的应用列表
        self.applications = applications

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['applications'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.applications = []
        if m.get('applications') is not None:
            for k in m.get('applications'):
                temp_model = OpsApplication()
                self.applications.append(temp_model.from_map(k))
        return self


class UnireleaseSolutionApp(TeaModel):
    def __init__(
        self,
        app: str = None,
        depends_on: List[str] = None,
        release_config: AppReleaseConfig = None,
        middleware_configs: List[str] = None,
        tenant: str = None,
        middleware_config_diffs: List[str] = None,
        workspace_group: str = None,
        namespace: str = None,
        middleware_config_diff_summary: str = None,
        risk_level: str = None,
    ):
        # 应用名称
        self.app = app
        # 应用依赖信息
        self.depends_on = depends_on
        # 应用发布配置
        self.release_config = release_config
        # 中间件配置
        self.middleware_configs = middleware_configs
        # 机构/租户信息
        self.tenant = tenant
        # 中间件配置diff信息
        self.middleware_config_diffs = middleware_config_diffs
        # 工作空间组
        self.workspace_group = workspace_group
        # 命名空间
        self.namespace = namespace
        # 中间件配置变更diff摘要
        self.middleware_config_diff_summary = middleware_config_diff_summary
        # 风险等级: ORDINARY-一般、HIGH-高危
        self.risk_level = risk_level

    def validate(self):
        self.validate_required(self.app, 'app')
        self.validate_required(self.depends_on, 'depends_on')
        self.validate_required(self.release_config, 'release_config')
        if self.release_config:
            self.release_config.validate()
        self.validate_required(self.middleware_configs, 'middleware_configs')
        self.validate_required(self.tenant, 'tenant')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app is not None:
            result['app'] = self.app
        if self.depends_on is not None:
            result['depends_on'] = self.depends_on
        if self.release_config is not None:
            result['release_config'] = self.release_config.to_map()
        if self.middleware_configs is not None:
            result['middleware_configs'] = self.middleware_configs
        if self.tenant is not None:
            result['tenant'] = self.tenant
        if self.middleware_config_diffs is not None:
            result['middleware_config_diffs'] = self.middleware_config_diffs
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.middleware_config_diff_summary is not None:
            result['middleware_config_diff_summary'] = self.middleware_config_diff_summary
        if self.risk_level is not None:
            result['risk_level'] = self.risk_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('depends_on') is not None:
            self.depends_on = m.get('depends_on')
        if m.get('release_config') is not None:
            temp_model = AppReleaseConfig()
            self.release_config = temp_model.from_map(m['release_config'])
        if m.get('middleware_configs') is not None:
            self.middleware_configs = m.get('middleware_configs')
        if m.get('tenant') is not None:
            self.tenant = m.get('tenant')
        if m.get('middleware_config_diffs') is not None:
            self.middleware_config_diffs = m.get('middleware_config_diffs')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('middleware_config_diff_summary') is not None:
            self.middleware_config_diff_summary = m.get('middleware_config_diff_summary')
        if m.get('risk_level') is not None:
            self.risk_level = m.get('risk_level')
        return self


class FederatedServiceStatus(TeaModel):
    def __init__(
        self,
        metadata: ObjectMeta = None,
        topology_status: List[FederatedServiceTopologyStatus] = None,
    ):
        # metadata
        self.metadata = metadata
        # topologyStatus
        self.topology_status = topology_status

    def validate(self):
        if self.metadata:
            self.metadata.validate()
        if self.topology_status:
            for k in self.topology_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        result['topology_status'] = []
        if self.topology_status is not None:
            for k in self.topology_status:
                result['topology_status'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('metadata') is not None:
            temp_model = ObjectMeta()
            self.metadata = temp_model.from_map(m['metadata'])
        self.topology_status = []
        if m.get('topology_status') is not None:
            for k in m.get('topology_status'):
                temp_model = FederatedServiceTopologyStatus()
                self.topology_status.append(temp_model.from_map(k))
        return self


class AppService(TeaModel):
    def __init__(
        self,
        name: str = None,
        workspace: str = None,
    ):
        # 应用服务实例名称
        self.name = name
        # 工作空间名称
        self.workspace = workspace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class OpsGroupTaskProgress(TeaModel):
    def __init__(
        self,
        action_code: str = None,
        action_name: str = None,
        state: str = None,
        started_time: str = None,
        finished_time: str = None,
    ):
        # 任务码
        self.action_code = action_code
        # 任务名称
        self.action_name = action_name
        # 任务状态
        self.state = state
        # 任务开始时间
        self.started_time = started_time
        # 任务结束时间
        self.finished_time = finished_time

    def validate(self):
        self.validate_required(self.action_code, 'action_code')
        self.validate_required(self.action_name, 'action_name')
        self.validate_required(self.state, 'state')
        self.validate_required(self.started_time, 'started_time')
        if self.started_time is not None:
            self.validate_pattern(self.started_time, 'started_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.finished_time, 'finished_time')
        if self.finished_time is not None:
            self.validate_pattern(self.finished_time, 'finished_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_code is not None:
            result['action_code'] = self.action_code
        if self.action_name is not None:
            result['action_name'] = self.action_name
        if self.state is not None:
            result['state'] = self.state
        if self.started_time is not None:
            result['started_time'] = self.started_time
        if self.finished_time is not None:
            result['finished_time'] = self.finished_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('action_code') is not None:
            self.action_code = m.get('action_code')
        if m.get('action_name') is not None:
            self.action_name = m.get('action_name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('started_time') is not None:
            self.started_time = m.get('started_time')
        if m.get('finished_time') is not None:
            self.finished_time = m.get('finished_time')
        return self


class GrayLabelApplyRule(TeaModel):
    def __init__(
        self,
        operator: str = None,
        downstream_rules: List[GrayLabelDownstreamRule] = None,
    ):
        # 多个指定条件的计算方式，目前支持AND和OR
        self.operator = operator
        # 入口流量的多个规则，将根据operator进行与、或运算
        self.downstream_rules = downstream_rules

    def validate(self):
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.downstream_rules, 'downstream_rules')
        if self.downstream_rules:
            for k in self.downstream_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['operator'] = self.operator
        result['downstream_rules'] = []
        if self.downstream_rules is not None:
            for k in self.downstream_rules:
                result['downstream_rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        self.downstream_rules = []
        if m.get('downstream_rules') is not None:
            for k in m.get('downstream_rules'):
                temp_model = GrayLabelDownstreamRule()
                self.downstream_rules.append(temp_model.from_map(k))
        return self


class FedDeploymentClusterOverride(TeaModel):
    def __init__(
        self,
        cluster: str = None,
        replica: int = None,
        env_var_override: List[EnvVarClusterOverride] = None,
    ):
        # 集群名称
        self.cluster = cluster
        # 集群Deployment replica数量
        self.replica = replica
        # 环境变量配置覆盖
        self.env_var_override = env_var_override

    def validate(self):
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.replica, 'replica')
        self.validate_required(self.env_var_override, 'env_var_override')
        if self.env_var_override:
            for k in self.env_var_override:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.replica is not None:
            result['replica'] = self.replica
        result['env_var_override'] = []
        if self.env_var_override is not None:
            for k in self.env_var_override:
                result['env_var_override'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('replica') is not None:
            self.replica = m.get('replica')
        self.env_var_override = []
        if m.get('env_var_override') is not None:
            for k in m.get('env_var_override'):
                temp_model = EnvVarClusterOverride()
                self.env_var_override.append(temp_model.from_map(k))
        return self


class AppInfo(TeaModel):
    def __init__(
        self,
        buildpack_version: str = None,
        description: str = None,
        id: str = None,
        name: str = None,
        owner: str = None,
        techstack_identity: str = None,
        owner_id: str = None,
    ):
        # buildpack版本。
        self.buildpack_version = buildpack_version
        # 应用描述。
        self.description = description
        # 应用id。
        self.id = id
        # 应用名称。
        self.name = name
        # 应用owner。
        self.owner = owner
        # 技术栈。
        self.techstack_identity = techstack_identity
        # ownerId
        self.owner_id = owner_id

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.owner, 'owner')
        self.validate_required(self.techstack_identity, 'techstack_identity')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buildpack_version is not None:
            result['buildpack_version'] = self.buildpack_version
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.owner is not None:
            result['owner'] = self.owner
        if self.techstack_identity is not None:
            result['techstack_identity'] = self.techstack_identity
        if self.owner_id is not None:
            result['owner_id'] = self.owner_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('buildpack_version') is not None:
            self.buildpack_version = m.get('buildpack_version')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        if m.get('techstack_identity') is not None:
            self.techstack_identity = m.get('techstack_identity')
        if m.get('owner_id') is not None:
            self.owner_id = m.get('owner_id')
        return self


class UnireleaseSolutionExtInfo(TeaModel):
    def __init__(
        self,
        linke_info: UnireleaseSolutionExtInfoLinkeInfo = None,
    ):
        # Linke配置信息
        self.linke_info = linke_info

    def validate(self):
        self.validate_required(self.linke_info, 'linke_info')
        if self.linke_info:
            self.linke_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.linke_info is not None:
            result['linke_info'] = self.linke_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('linke_info') is not None:
            temp_model = UnireleaseSolutionExtInfoLinkeInfo()
            self.linke_info = temp_model.from_map(m['linke_info'])
        return self


class ContainerServiceObjectMeta(TeaModel):
    def __init__(
        self,
        uid: str = None,
        namespace: str = None,
        name: str = None,
        cell_display_name: str = None,
        cluster: str = None,
        created_time: str = None,
    ):
        # UID
        self.uid = uid
        # 命名空间
        self.namespace = namespace
        # 名称
        self.name = name
        # 部署单元名称
        self.cell_display_name = cell_display_name
        # 集群名称
        self.cluster = cluster
        # 创建时间
        self.created_time = created_time

    def validate(self):
        self.validate_required(self.uid, 'uid')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.name, 'name')
        self.validate_required(self.cell_display_name, 'cell_display_name')
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.created_time, 'created_time')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uid is not None:
            result['uid'] = self.uid
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.name is not None:
            result['name'] = self.name
        if self.cell_display_name is not None:
            result['cell_display_name'] = self.cell_display_name
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.created_time is not None:
            result['created_time'] = self.created_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('cell_display_name') is not None:
            self.cell_display_name = m.get('cell_display_name')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        return self


class ContainerServiceConfig(TeaModel):
    def __init__(
        self,
        biz_monitor_paths: List[str] = None,
        cluster_ip_services: List[ClusterIpService] = None,
        container_specs: List[ContainerSpec] = None,
        deploy_config: DeployConfig = None,
        elastic_config: ElasticConfig = None,
        enable_biz_monitor: bool = None,
        enable_log_config: bool = None,
        enable_sofa_mesh: bool = None,
        ingresses: List[IngressConfig] = None,
        inner_load_balancer_services: List[LoadBalancerService] = None,
        public_load_balancer_services: List[LoadBalancerService] = None,
        sidecar_configs: List[SidecarTemplate] = None,
        use_host_network: bool = None,
        load_balancer_services: List[LoadBalancerService] = None,
        volume_claim_configs: List[VolumeClaimConfig] = None,
        tolerations: List[Toleration] = None,
        sidercars: List[SidecarConfig] = None,
        headless_services: List[HeadlessService] = None,
        resource_overrides: List[ResourceOverride] = None,
        traffic_config: TrafficConfig = None,
    ):
        # 容器服务业务实时监控路径。
        self.biz_monitor_paths = biz_monitor_paths
        # 内网访问配置。
        self.cluster_ip_services = cluster_ip_services
        # 容器配置。
        self.container_specs = container_specs
        # 容器服务部署配置。
        self.deploy_config = deploy_config
        # 弹性配置。
        self.elastic_config = elastic_config
        # 容器服务是否开启业务实时监控。
        self.enable_biz_monitor = enable_biz_monitor
        # 容器服务是否开启日志监控。
        self.enable_log_config = enable_log_config
        # 容器服务是否开启SofaMesh。
        self.enable_sofa_mesh = enable_sofa_mesh
        # 统一接入配置。
        self.ingresses = ingresses
        # 内网负载均衡访问配置（旧版）
        self.inner_load_balancer_services = inner_load_balancer_services
        # 公网访问负载均衡配置（旧版）
        self.public_load_balancer_services = public_load_balancer_services
        # sidecar 模版配置
        self.sidecar_configs = sidecar_configs
        # 容器服务关联的Pod是否使用宿主机网络。
        self.use_host_network = use_host_network
        # 负载均衡配置
        self.load_balancer_services = load_balancer_services
        # volumeClaimConfigs
        self.volume_claim_configs = volume_claim_configs
        # 容忍度配置
        self.tolerations = tolerations
        # 启用的sidercar列表，只针对首次发布生效
        self.sidercars = sidercars
        # headless service 配置
        self.headless_services = headless_services
        # 资源overrides（lks 1.24.0后开始支持）
        self.resource_overrides = resource_overrides
        # 摘流配置
        self.traffic_config = traffic_config

    def validate(self):
        if self.cluster_ip_services:
            for k in self.cluster_ip_services:
                if k:
                    k.validate()
        self.validate_required(self.container_specs, 'container_specs')
        if self.container_specs:
            for k in self.container_specs:
                if k:
                    k.validate()
        self.validate_required(self.deploy_config, 'deploy_config')
        if self.deploy_config:
            self.deploy_config.validate()
        self.validate_required(self.elastic_config, 'elastic_config')
        if self.elastic_config:
            self.elastic_config.validate()
        if self.ingresses:
            for k in self.ingresses:
                if k:
                    k.validate()
        if self.inner_load_balancer_services:
            for k in self.inner_load_balancer_services:
                if k:
                    k.validate()
        if self.public_load_balancer_services:
            for k in self.public_load_balancer_services:
                if k:
                    k.validate()
        if self.sidecar_configs:
            for k in self.sidecar_configs:
                if k:
                    k.validate()
        if self.load_balancer_services:
            for k in self.load_balancer_services:
                if k:
                    k.validate()
        if self.volume_claim_configs:
            for k in self.volume_claim_configs:
                if k:
                    k.validate()
        if self.tolerations:
            for k in self.tolerations:
                if k:
                    k.validate()
        if self.sidercars:
            for k in self.sidercars:
                if k:
                    k.validate()
        if self.headless_services:
            for k in self.headless_services:
                if k:
                    k.validate()
        if self.resource_overrides:
            for k in self.resource_overrides:
                if k:
                    k.validate()
        if self.traffic_config:
            self.traffic_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_monitor_paths is not None:
            result['biz_monitor_paths'] = self.biz_monitor_paths
        result['cluster_ip_services'] = []
        if self.cluster_ip_services is not None:
            for k in self.cluster_ip_services:
                result['cluster_ip_services'].append(k.to_map() if k else None)
        result['container_specs'] = []
        if self.container_specs is not None:
            for k in self.container_specs:
                result['container_specs'].append(k.to_map() if k else None)
        if self.deploy_config is not None:
            result['deploy_config'] = self.deploy_config.to_map()
        if self.elastic_config is not None:
            result['elastic_config'] = self.elastic_config.to_map()
        if self.enable_biz_monitor is not None:
            result['enable_biz_monitor'] = self.enable_biz_monitor
        if self.enable_log_config is not None:
            result['enable_log_config'] = self.enable_log_config
        if self.enable_sofa_mesh is not None:
            result['enable_sofa_mesh'] = self.enable_sofa_mesh
        result['ingresses'] = []
        if self.ingresses is not None:
            for k in self.ingresses:
                result['ingresses'].append(k.to_map() if k else None)
        result['inner_load_balancer_services'] = []
        if self.inner_load_balancer_services is not None:
            for k in self.inner_load_balancer_services:
                result['inner_load_balancer_services'].append(k.to_map() if k else None)
        result['public_load_balancer_services'] = []
        if self.public_load_balancer_services is not None:
            for k in self.public_load_balancer_services:
                result['public_load_balancer_services'].append(k.to_map() if k else None)
        result['sidecar_configs'] = []
        if self.sidecar_configs is not None:
            for k in self.sidecar_configs:
                result['sidecar_configs'].append(k.to_map() if k else None)
        if self.use_host_network is not None:
            result['use_host_network'] = self.use_host_network
        result['load_balancer_services'] = []
        if self.load_balancer_services is not None:
            for k in self.load_balancer_services:
                result['load_balancer_services'].append(k.to_map() if k else None)
        result['volume_claim_configs'] = []
        if self.volume_claim_configs is not None:
            for k in self.volume_claim_configs:
                result['volume_claim_configs'].append(k.to_map() if k else None)
        result['tolerations'] = []
        if self.tolerations is not None:
            for k in self.tolerations:
                result['tolerations'].append(k.to_map() if k else None)
        result['sidercars'] = []
        if self.sidercars is not None:
            for k in self.sidercars:
                result['sidercars'].append(k.to_map() if k else None)
        result['headless_services'] = []
        if self.headless_services is not None:
            for k in self.headless_services:
                result['headless_services'].append(k.to_map() if k else None)
        result['resource_overrides'] = []
        if self.resource_overrides is not None:
            for k in self.resource_overrides:
                result['resource_overrides'].append(k.to_map() if k else None)
        if self.traffic_config is not None:
            result['traffic_config'] = self.traffic_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_monitor_paths') is not None:
            self.biz_monitor_paths = m.get('biz_monitor_paths')
        self.cluster_ip_services = []
        if m.get('cluster_ip_services') is not None:
            for k in m.get('cluster_ip_services'):
                temp_model = ClusterIpService()
                self.cluster_ip_services.append(temp_model.from_map(k))
        self.container_specs = []
        if m.get('container_specs') is not None:
            for k in m.get('container_specs'):
                temp_model = ContainerSpec()
                self.container_specs.append(temp_model.from_map(k))
        if m.get('deploy_config') is not None:
            temp_model = DeployConfig()
            self.deploy_config = temp_model.from_map(m['deploy_config'])
        if m.get('elastic_config') is not None:
            temp_model = ElasticConfig()
            self.elastic_config = temp_model.from_map(m['elastic_config'])
        if m.get('enable_biz_monitor') is not None:
            self.enable_biz_monitor = m.get('enable_biz_monitor')
        if m.get('enable_log_config') is not None:
            self.enable_log_config = m.get('enable_log_config')
        if m.get('enable_sofa_mesh') is not None:
            self.enable_sofa_mesh = m.get('enable_sofa_mesh')
        self.ingresses = []
        if m.get('ingresses') is not None:
            for k in m.get('ingresses'):
                temp_model = IngressConfig()
                self.ingresses.append(temp_model.from_map(k))
        self.inner_load_balancer_services = []
        if m.get('inner_load_balancer_services') is not None:
            for k in m.get('inner_load_balancer_services'):
                temp_model = LoadBalancerService()
                self.inner_load_balancer_services.append(temp_model.from_map(k))
        self.public_load_balancer_services = []
        if m.get('public_load_balancer_services') is not None:
            for k in m.get('public_load_balancer_services'):
                temp_model = LoadBalancerService()
                self.public_load_balancer_services.append(temp_model.from_map(k))
        self.sidecar_configs = []
        if m.get('sidecar_configs') is not None:
            for k in m.get('sidecar_configs'):
                temp_model = SidecarTemplate()
                self.sidecar_configs.append(temp_model.from_map(k))
        if m.get('use_host_network') is not None:
            self.use_host_network = m.get('use_host_network')
        self.load_balancer_services = []
        if m.get('load_balancer_services') is not None:
            for k in m.get('load_balancer_services'):
                temp_model = LoadBalancerService()
                self.load_balancer_services.append(temp_model.from_map(k))
        self.volume_claim_configs = []
        if m.get('volume_claim_configs') is not None:
            for k in m.get('volume_claim_configs'):
                temp_model = VolumeClaimConfig()
                self.volume_claim_configs.append(temp_model.from_map(k))
        self.tolerations = []
        if m.get('tolerations') is not None:
            for k in m.get('tolerations'):
                temp_model = Toleration()
                self.tolerations.append(temp_model.from_map(k))
        self.sidercars = []
        if m.get('sidercars') is not None:
            for k in m.get('sidercars'):
                temp_model = SidecarConfig()
                self.sidercars.append(temp_model.from_map(k))
        self.headless_services = []
        if m.get('headless_services') is not None:
            for k in m.get('headless_services'):
                temp_model = HeadlessService()
                self.headless_services.append(temp_model.from_map(k))
        self.resource_overrides = []
        if m.get('resource_overrides') is not None:
            for k in m.get('resource_overrides'):
                temp_model = ResourceOverride()
                self.resource_overrides.append(temp_model.from_map(k))
        if m.get('traffic_config') is not None:
            temp_model = TrafficConfig()
            self.traffic_config = temp_model.from_map(m['traffic_config'])
        return self


class Cell(TeaModel):
    def __init__(
        self,
        cell_group: str = None,
        color: str = None,
        created_time: str = None,
        identity: str = None,
        is_gray: bool = None,
        name: str = None,
        press_weight: int = None,
        type: str = None,
        weight: int = None,
        workspace: str = None,
        zone: str = None,
        display_name: str = None,
        cluster: str = None,
    ):
        # 所属逻辑单元名称[单元化模式特有]。
        self.cell_group = cell_group
        # 蓝绿着色信息[单元化模式特有]。
        self.color = color
        # 创建时间。
        self.created_time = created_time
        # 部署单元标识，创建之后不允许修改。
        self.identity = identity
        # 是否灰度[单元化模式特有]。
        self.is_gray = is_gray
        # 部署单元名称，主要用作页面展示。
        self.name = name
        # 压测权重
        self.press_weight = press_weight
        # 部署单元类型[单元化模式特有]。
        self.type = type
        # 默认权重[单元化模式特有]。
        self.weight = weight
        # 所属工作空间名称。
        self.workspace = workspace
        # 所属机房信息。
        self.zone = zone
        # cell名称，与name一样，为了兼容已有代码
        self.display_name = display_name
        # 所属cluster
        self.cluster = cluster

    def validate(self):
        self.validate_required(self.created_time, 'created_time')
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace, 'workspace')
        self.validate_required(self.zone, 'zone')
        self.validate_required(self.display_name, 'display_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_group is not None:
            result['cell_group'] = self.cell_group
        if self.color is not None:
            result['color'] = self.color
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.identity is not None:
            result['identity'] = self.identity
        if self.is_gray is not None:
            result['is_gray'] = self.is_gray
        if self.name is not None:
            result['name'] = self.name
        if self.press_weight is not None:
            result['press_weight'] = self.press_weight
        if self.type is not None:
            result['type'] = self.type
        if self.weight is not None:
            result['weight'] = self.weight
        if self.workspace is not None:
            result['workspace'] = self.workspace
        if self.zone is not None:
            result['zone'] = self.zone
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.cluster is not None:
            result['cluster'] = self.cluster
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell_group') is not None:
            self.cell_group = m.get('cell_group')
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('is_gray') is not None:
            self.is_gray = m.get('is_gray')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('press_weight') is not None:
            self.press_weight = m.get('press_weight')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        if m.get('zone') is not None:
            self.zone = m.get('zone')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        return self


class ClusteCellStatus(TeaModel):
    def __init__(
        self,
        cluster: str = None,
        cell: str = None,
        status: str = None,
        message: str = None,
    ):
        # 部署单元所在集群名称
        self.cluster = cluster
        # 部署单元名称
        self.cell = cell
        # 联邦资源的分发状态，空字符串代表成功，否则为错误码
        self.status = status
        # 详细错误信息
        self.message = message

    def validate(self):
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.cell, 'cell')
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.cell is not None:
            result['cell'] = self.cell
        if self.status is not None:
            result['status'] = self.status
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class OpsUnit(TeaModel):
    def __init__(
        self,
        cell: str = None,
        computers: List[OpsComputer] = None,
        region: str = None,
        zone: str = None,
    ):
        # 单元所属部署区
        self.cell = cell
        # 包含在此单元中进行运维操作的计算容器列表
        self.computers = computers
        # 单元所属地域
        self.region = region
        # 单元所属可用区
        self.zone = zone

    def validate(self):
        if self.computers:
            for k in self.computers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell is not None:
            result['cell'] = self.cell
        result['computers'] = []
        if self.computers is not None:
            for k in self.computers:
                result['computers'].append(k.to_map() if k else None)
        if self.region is not None:
            result['region'] = self.region
        if self.zone is not None:
            result['zone'] = self.zone
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        self.computers = []
        if m.get('computers') is not None:
            for k in m.get('computers'):
                temp_model = OpsComputer()
                self.computers.append(temp_model.from_map(k))
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('zone') is not None:
            self.zone = m.get('zone')
        return self


class QuerySpannerClusterDetail(TeaModel):
    def __init__(
        self,
        address_type: str = None,
        cpu: int = None,
        create_timestamp: str = None,
        disk: int = None,
        flavor: str = None,
        host_network: bool = None,
        id: str = None,
        instances: int = None,
        mem: int = None,
        message: str = None,
        name: str = None,
        state: str = None,
        tenant: str = None,
        update_timestamp: str = None,
        workspace_group: str = None,
        expect_cluster_state: str = None,
    ):
        # 用于描述联邦spanner 集群内容器实例采用内网还是外网
        self.address_type = address_type
        # cpu 核数
        self.cpu = cpu
        # 创建时间
        self.create_timestamp = create_timestamp
        # 盘大小
        self.disk = disk
        # 将cpu,mem,disk按照单位拼接起来
        self.flavor = flavor
        # 描述集群容器是否采用了host网络
        # 
        self.host_network = host_network
        # 集群id
        self.id = id
        # 关联的实例数
        self.instances = instances
        # mem 大小
        self.mem = mem
        # 可能存在的错误信息
        self.message = message
        # 集群名称
        self.name = name
        # 描述集群状态
        # 
        self.state = state
        # 租户名称
        self.tenant = tenant
        # 最后更新的时间戳
        self.update_timestamp = update_timestamp
        # 工作空间组
        self.workspace_group = workspace_group
        # 期望集群状态
        self.expect_cluster_state = expect_cluster_state

    def validate(self):
        self.validate_required(self.address_type, 'address_type')
        if self.create_timestamp is not None:
            self.validate_pattern(self.create_timestamp, 'create_timestamp', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.flavor, 'flavor')
        self.validate_required(self.host_network, 'host_network')
        self.validate_required(self.id, 'id')
        if self.id is not None:
            self.validate_max_length(self.id, 'id', 256)
        self.validate_required(self.instances, 'instances')
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 63)
        self.validate_required(self.state, 'state')
        if self.state is not None:
            self.validate_max_length(self.state, 'state', 63)
        self.validate_required(self.tenant, 'tenant')
        if self.update_timestamp is not None:
            self.validate_pattern(self.update_timestamp, 'update_timestamp', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_type is not None:
            result['address_type'] = self.address_type
        if self.cpu is not None:
            result['cpu'] = self.cpu
        if self.create_timestamp is not None:
            result['create_timestamp'] = self.create_timestamp
        if self.disk is not None:
            result['disk'] = self.disk
        if self.flavor is not None:
            result['flavor'] = self.flavor
        if self.host_network is not None:
            result['host_network'] = self.host_network
        if self.id is not None:
            result['id'] = self.id
        if self.instances is not None:
            result['instances'] = self.instances
        if self.mem is not None:
            result['mem'] = self.mem
        if self.message is not None:
            result['message'] = self.message
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.tenant is not None:
            result['tenant'] = self.tenant
        if self.update_timestamp is not None:
            result['update_timestamp'] = self.update_timestamp
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.expect_cluster_state is not None:
            result['expect_cluster_state'] = self.expect_cluster_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address_type') is not None:
            self.address_type = m.get('address_type')
        if m.get('cpu') is not None:
            self.cpu = m.get('cpu')
        if m.get('create_timestamp') is not None:
            self.create_timestamp = m.get('create_timestamp')
        if m.get('disk') is not None:
            self.disk = m.get('disk')
        if m.get('flavor') is not None:
            self.flavor = m.get('flavor')
        if m.get('host_network') is not None:
            self.host_network = m.get('host_network')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('instances') is not None:
            self.instances = m.get('instances')
        if m.get('mem') is not None:
            self.mem = m.get('mem')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('tenant') is not None:
            self.tenant = m.get('tenant')
        if m.get('update_timestamp') is not None:
            self.update_timestamp = m.get('update_timestamp')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('expect_cluster_state') is not None:
            self.expect_cluster_state = m.get('expect_cluster_state')
        return self


class ReadinessProbe(TeaModel):
    def __init__(
        self,
        exec_action: ExecAction = None,
        failure_threshold: int = None,
        http_get_action: HttpGetAction = None,
        initial_delay_seconds: int = None,
        period_seconds: int = None,
        success_threshold: int = None,
        tcp_socket_action: TcpSocketAction = None,
        timeout_seconds: int = None,
    ):
        # 命令行方式的健康监测配置。
        self.exec_action = exec_action
        # 不健康阈值。
        self.failure_threshold = failure_threshold
        # http方式的健康监测配置。
        self.http_get_action = http_get_action
        # 首次检查延时。
        self.initial_delay_seconds = initial_delay_seconds
        # 不健康阈值。
        self.period_seconds = period_seconds
        # 健康阈值。
        self.success_threshold = success_threshold
        # tcp方式的健康监测配置。
        self.tcp_socket_action = tcp_socket_action
        # 检查超时。
        self.timeout_seconds = timeout_seconds

    def validate(self):
        if self.exec_action:
            self.exec_action.validate()
        self.validate_required(self.failure_threshold, 'failure_threshold')
        if self.http_get_action:
            self.http_get_action.validate()
        self.validate_required(self.initial_delay_seconds, 'initial_delay_seconds')
        self.validate_required(self.period_seconds, 'period_seconds')
        self.validate_required(self.success_threshold, 'success_threshold')
        if self.tcp_socket_action:
            self.tcp_socket_action.validate()
        self.validate_required(self.timeout_seconds, 'timeout_seconds')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_action is not None:
            result['exec_action'] = self.exec_action.to_map()
        if self.failure_threshold is not None:
            result['failure_threshold'] = self.failure_threshold
        if self.http_get_action is not None:
            result['http_get_action'] = self.http_get_action.to_map()
        if self.initial_delay_seconds is not None:
            result['initial_delay_seconds'] = self.initial_delay_seconds
        if self.period_seconds is not None:
            result['period_seconds'] = self.period_seconds
        if self.success_threshold is not None:
            result['success_threshold'] = self.success_threshold
        if self.tcp_socket_action is not None:
            result['tcp_socket_action'] = self.tcp_socket_action.to_map()
        if self.timeout_seconds is not None:
            result['timeout_seconds'] = self.timeout_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('exec_action') is not None:
            temp_model = ExecAction()
            self.exec_action = temp_model.from_map(m['exec_action'])
        if m.get('failure_threshold') is not None:
            self.failure_threshold = m.get('failure_threshold')
        if m.get('http_get_action') is not None:
            temp_model = HttpGetAction()
            self.http_get_action = temp_model.from_map(m['http_get_action'])
        if m.get('initial_delay_seconds') is not None:
            self.initial_delay_seconds = m.get('initial_delay_seconds')
        if m.get('period_seconds') is not None:
            self.period_seconds = m.get('period_seconds')
        if m.get('success_threshold') is not None:
            self.success_threshold = m.get('success_threshold')
        if m.get('tcp_socket_action') is not None:
            temp_model = TcpSocketAction()
            self.tcp_socket_action = temp_model.from_map(m['tcp_socket_action'])
        if m.get('timeout_seconds') is not None:
            self.timeout_seconds = m.get('timeout_seconds')
        return self


class OpsContainerServiceGroup(TeaModel):
    def __init__(
        self,
        container_services: List[OpsContainerService] = None,
    ):
        # 运维容器服务列表
        self.container_services = container_services

    def validate(self):
        self.validate_required(self.container_services, 'container_services')
        if self.container_services:
            for k in self.container_services:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['container_services'] = []
        if self.container_services is not None:
            for k in self.container_services:
                result['container_services'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.container_services = []
        if m.get('container_services') is not None:
            for k in m.get('container_services'):
                temp_model = OpsContainerService()
                self.container_services.append(temp_model.from_map(k))
        return self


class FedImagePullSecretOverrideList(TeaModel):
    def __init__(
        self,
        list: List[FedImagePullSecretOverride] = None,
    ):
        # fed image pull secret overrides
        self.list = list

    def validate(self):
        self.validate_required(self.list, 'list')
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = FedImagePullSecretOverride()
                self.list.append(temp_model.from_map(k))
        return self


class SiteCell(TeaModel):
    def __init__(
        self,
        site_name: str = None,
        name: str = None,
        region: str = None,
    ):
        # 异构机房名
        self.site_name = site_name
        # 部署单元名
        self.name = name
        # 地域
        self.region = region

    def validate(self):
        self.validate_required(self.site_name, 'site_name')
        self.validate_required(self.name, 'name')
        self.validate_required(self.region, 'region')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.site_name is not None:
            result['site_name'] = self.site_name
        if self.name is not None:
            result['name'] = self.name
        if self.region is not None:
            result['region'] = self.region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('site_name') is not None:
            self.site_name = m.get('site_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('region') is not None:
            self.region = m.get('region')
        return self


class PodInfo(TeaModel):
    def __init__(
        self,
        cell_display_name: str = None,
        cluster: str = None,
        containers: List[ContainerInfo] = None,
        created_time: str = None,
        name: str = None,
        namespace: str = None,
        status: PodStatus = None,
        uid: str = None,
        volumes: List[Volume] = None,
        pod_identity: str = None,
    ):
        # 部署单元名称
        self.cell_display_name = cell_display_name
        # 集群名称
        self.cluster = cluster
        # pod containers info
        self.containers = containers
        # create time
        self.created_time = created_time
        # pod 名称
        self.name = name
        # 命名空间名称
        self.namespace = namespace
        # pod状态
        self.status = status
        # pod uid
        self.uid = uid
        # Pod volume信息。
        self.volumes = volumes
        # pod唯一标识
        self.pod_identity = pod_identity

    def validate(self):
        self.validate_required(self.cell_display_name, 'cell_display_name')
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.containers, 'containers')
        if self.containers:
            for k in self.containers:
                if k:
                    k.validate()
        self.validate_required(self.created_time, 'created_time')
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.status, 'status')
        if self.status:
            self.status.validate()
        self.validate_required(self.uid, 'uid')
        if self.volumes:
            for k in self.volumes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_display_name is not None:
            result['cell_display_name'] = self.cell_display_name
        if self.cluster is not None:
            result['cluster'] = self.cluster
        result['containers'] = []
        if self.containers is not None:
            for k in self.containers:
                result['containers'].append(k.to_map() if k else None)
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.status is not None:
            result['status'] = self.status.to_map()
        if self.uid is not None:
            result['uid'] = self.uid
        result['volumes'] = []
        if self.volumes is not None:
            for k in self.volumes:
                result['volumes'].append(k.to_map() if k else None)
        if self.pod_identity is not None:
            result['pod_identity'] = self.pod_identity
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell_display_name') is not None:
            self.cell_display_name = m.get('cell_display_name')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        self.containers = []
        if m.get('containers') is not None:
            for k in m.get('containers'):
                temp_model = ContainerInfo()
                self.containers.append(temp_model.from_map(k))
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('status') is not None:
            temp_model = PodStatus()
            self.status = temp_model.from_map(m['status'])
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        self.volumes = []
        if m.get('volumes') is not None:
            for k in m.get('volumes'):
                temp_model = Volume()
                self.volumes.append(temp_model.from_map(k))
        if m.get('pod_identity') is not None:
            self.pod_identity = m.get('pod_identity')
        return self


class LocalLoadBalancer(TeaModel):
    def __init__(
        self,
        cell: str = None,
        iaas_id: str = None,
        vip: str = None,
        phase: str = None,
        message: str = None,
    ):
        # local lb所在部署单元
        self.cell = cell
        # local lb实例对应的iaas id
        self.iaas_id = iaas_id
        # local lb实例对应的vip
        self.vip = vip
        # 当前cell lb的phase
        self.phase = phase
        # 空代表无错误信息，非空时即报错信息
        self.message = message

    def validate(self):
        self.validate_required(self.cell, 'cell')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell is not None:
            result['cell'] = self.cell
        if self.iaas_id is not None:
            result['iaas_id'] = self.iaas_id
        if self.vip is not None:
            result['vip'] = self.vip
        if self.phase is not None:
            result['phase'] = self.phase
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('iaas_id') is not None:
            self.iaas_id = m.get('iaas_id')
        if m.get('vip') is not None:
            self.vip = m.get('vip')
        if m.get('phase') is not None:
            self.phase = m.get('phase')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class UidRange(TeaModel):
    def __init__(
        self,
        start: int = None,
        end: int = None,
        elastic: bool = None,
    ):
        # UID 起始值
        self.start = start
        # UID 终止值
        self.end = end
        # 弹性
        self.elastic = elastic

    def validate(self):
        self.validate_required(self.start, 'start')
        self.validate_required(self.end, 'end')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.start is not None:
            result['start'] = self.start
        if self.end is not None:
            result['end'] = self.end
        if self.elastic is not None:
            result['elastic'] = self.elastic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('start') is not None:
            self.start = m.get('start')
        if m.get('end') is not None:
            self.end = m.get('end')
        if m.get('elastic') is not None:
            self.elastic = m.get('elastic')
        return self


class ContainerServiceOperation(TeaModel):
    def __init__(
        self,
        container_service_name: str = None,
        depend_container_service_names: List[str] = None,
        selected_pods: List[CellPods] = None,
        batches: List[ReleaseBatchObj] = None,
        scale_replicas: List[ReplicaCount] = None,
        container_service_revision: str = None,
        graycore_batches: str = None,
    ):
        # 容器服务名称。
        self.container_service_name = container_service_name
        # 依赖的容器应用服务名称。
        self.depend_container_service_names = depend_container_service_names
        # 待操作目标pods列表
        self.selected_pods = selected_pods
        # 自定义发布批次
        self.batches = batches
        # 缩放副本数量，扩缩容时使用
        self.scale_replicas = scale_replicas
        # 应用服务当前版本
        self.container_service_revision = container_service_revision
        # [huanyu场景使用]，灰度平台pods分批序列化为json的结果
        self.graycore_batches = graycore_batches

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        if self.selected_pods:
            for k in self.selected_pods:
                if k:
                    k.validate()
        if self.batches:
            for k in self.batches:
                if k:
                    k.validate()
        if self.scale_replicas:
            for k in self.scale_replicas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.depend_container_service_names is not None:
            result['depend_container_service_names'] = self.depend_container_service_names
        result['selected_pods'] = []
        if self.selected_pods is not None:
            for k in self.selected_pods:
                result['selected_pods'].append(k.to_map() if k else None)
        result['batches'] = []
        if self.batches is not None:
            for k in self.batches:
                result['batches'].append(k.to_map() if k else None)
        result['scale_replicas'] = []
        if self.scale_replicas is not None:
            for k in self.scale_replicas:
                result['scale_replicas'].append(k.to_map() if k else None)
        if self.container_service_revision is not None:
            result['container_service_revision'] = self.container_service_revision
        if self.graycore_batches is not None:
            result['graycore_batches'] = self.graycore_batches
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('depend_container_service_names') is not None:
            self.depend_container_service_names = m.get('depend_container_service_names')
        self.selected_pods = []
        if m.get('selected_pods') is not None:
            for k in m.get('selected_pods'):
                temp_model = CellPods()
                self.selected_pods.append(temp_model.from_map(k))
        self.batches = []
        if m.get('batches') is not None:
            for k in m.get('batches'):
                temp_model = ReleaseBatchObj()
                self.batches.append(temp_model.from_map(k))
        self.scale_replicas = []
        if m.get('scale_replicas') is not None:
            for k in m.get('scale_replicas'):
                temp_model = ReplicaCount()
                self.scale_replicas.append(temp_model.from_map(k))
        if m.get('container_service_revision') is not None:
            self.container_service_revision = m.get('container_service_revision')
        if m.get('graycore_batches') is not None:
            self.graycore_batches = m.get('graycore_batches')
        return self


class FedLoadBalancerContainerServiceRel(TeaModel):
    def __init__(
        self,
        container_service_name: str = None,
        namespace: str = None,
        occupied_ports: List[int] = None,
    ):
        # 应用服务名字
        self.container_service_name = container_service_name
        # 应用服务命名空间
        self.namespace = namespace
        # 联邦负载均衡实例当前已被占用的端口
        self.occupied_ports = occupied_ports

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.occupied_ports, 'occupied_ports')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.occupied_ports is not None:
            result['occupied_ports'] = self.occupied_ports
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('occupied_ports') is not None:
            self.occupied_ports = m.get('occupied_ports')
        return self


class AppGroupSimpleView(TeaModel):
    def __init__(
        self,
        app_id_list: List[str] = None,
        id: str = None,
        state: str = None,
        bg_cell_name: str = None,
        bg_group_type: str = None,
    ):
        # 应用id列表
        self.app_id_list = app_id_list
        # 服务分组id
        self.id = id
        # 状态
        self.state = state
        # 蓝绿发布专用
        self.bg_cell_name = bg_cell_name
        # 蓝绿发布专用，traffic或release
        self.bg_group_type = bg_group_type

    def validate(self):
        self.validate_required(self.app_id_list, 'app_id_list')
        self.validate_required(self.id, 'id')
        self.validate_required(self.state, 'state')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id_list is not None:
            result['app_id_list'] = self.app_id_list
        if self.id is not None:
            result['id'] = self.id
        if self.state is not None:
            result['state'] = self.state
        if self.bg_cell_name is not None:
            result['bg_cell_name'] = self.bg_cell_name
        if self.bg_group_type is not None:
            result['bg_group_type'] = self.bg_group_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id_list') is not None:
            self.app_id_list = m.get('app_id_list')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('bg_cell_name') is not None:
            self.bg_cell_name = m.get('bg_cell_name')
        if m.get('bg_group_type') is not None:
            self.bg_group_type = m.get('bg_group_type')
        return self


class ClusterOverviewInfo(TeaModel):
    def __init__(
        self,
        available_cpu: int = None,
        available_disk: int = None,
        available_memory: int = None,
        available_node_number: int = None,
        total_cpu: int = None,
        total_disk: int = None,
        total_memory: int = None,
        total_node_number: int = None,
    ):
        # available cpu core
        self.available_cpu = available_cpu
        # available disk
        self.available_disk = available_disk
        # available memory
        self.available_memory = available_memory
        # available Node Number
        self.available_node_number = available_node_number
        # total cpu core number
        self.total_cpu = total_cpu
        # total disk
        self.total_disk = total_disk
        # total memory
        self.total_memory = total_memory
        # total node number
        self.total_node_number = total_node_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_cpu is not None:
            result['available_c_p_u'] = self.available_cpu
        if self.available_disk is not None:
            result['available_disk'] = self.available_disk
        if self.available_memory is not None:
            result['available_memory'] = self.available_memory
        if self.available_node_number is not None:
            result['available_node_number'] = self.available_node_number
        if self.total_cpu is not None:
            result['total_c_p_u'] = self.total_cpu
        if self.total_disk is not None:
            result['total_disk'] = self.total_disk
        if self.total_memory is not None:
            result['total_memory'] = self.total_memory
        if self.total_node_number is not None:
            result['total_node_number'] = self.total_node_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('available_c_p_u') is not None:
            self.available_cpu = m.get('available_c_p_u')
        if m.get('available_disk') is not None:
            self.available_disk = m.get('available_disk')
        if m.get('available_memory') is not None:
            self.available_memory = m.get('available_memory')
        if m.get('available_node_number') is not None:
            self.available_node_number = m.get('available_node_number')
        if m.get('total_c_p_u') is not None:
            self.total_cpu = m.get('total_c_p_u')
        if m.get('total_disk') is not None:
            self.total_disk = m.get('total_disk')
        if m.get('total_memory') is not None:
            self.total_memory = m.get('total_memory')
        if m.get('total_node_number') is not None:
            self.total_node_number = m.get('total_node_number')
        return self


class AppDeployPodStateSummary(TeaModel):
    def __init__(
        self,
        id: str = None,
        state: str = None,
        total: int = None,
        executing: int = None,
        succeeded: int = None,
        waiting: int = None,
        failed: int = None,
        inited: int = None,
        blocked: int = None,
    ):
        # 执行对象ID
        self.id = id
        # 执行对象状态
        self.state = state
        # 总计
        self.total = total
        # 执行中个数
        self.executing = executing
        # 成功数
        self.succeeded = succeeded
        # 等待个数
        self.waiting = waiting
        # 失败个数
        self.failed = failed
        # 初始化个数
        # 
        self.inited = inited
        # 阻塞个数
        self.blocked = blocked

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.state, 'state')
        self.validate_required(self.total, 'total')
        self.validate_required(self.executing, 'executing')
        self.validate_required(self.succeeded, 'succeeded')
        self.validate_required(self.waiting, 'waiting')
        self.validate_required(self.failed, 'failed')
        self.validate_required(self.inited, 'inited')
        self.validate_required(self.blocked, 'blocked')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.state is not None:
            result['state'] = self.state
        if self.total is not None:
            result['total'] = self.total
        if self.executing is not None:
            result['executing'] = self.executing
        if self.succeeded is not None:
            result['succeeded'] = self.succeeded
        if self.waiting is not None:
            result['waiting'] = self.waiting
        if self.failed is not None:
            result['failed'] = self.failed
        if self.inited is not None:
            result['inited'] = self.inited
        if self.blocked is not None:
            result['blocked'] = self.blocked
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('total') is not None:
            self.total = m.get('total')
        if m.get('executing') is not None:
            self.executing = m.get('executing')
        if m.get('succeeded') is not None:
            self.succeeded = m.get('succeeded')
        if m.get('waiting') is not None:
            self.waiting = m.get('waiting')
        if m.get('failed') is not None:
            self.failed = m.get('failed')
        if m.get('inited') is not None:
            self.inited = m.get('inited')
        if m.get('blocked') is not None:
            self.blocked = m.get('blocked')
        return self


class SidecarReleaseInfo(TeaModel):
    def __init__(
        self,
        sidecar_name: str = None,
        sidecar_version: str = None,
        feature_gates: str = None,
        image: str = None,
        change_envs: str = None,
        release_version: str = None,
        last_release_version: str = None,
    ):
        # sidecar类型名称
        self.sidecar_name = sidecar_name
        # sidecar的发布版本
        self.sidecar_version = sidecar_version
        # mosn对应打开的feature-gates配置。
        self.feature_gates = feature_gates
        # 所用的image
        self.image = image
        # 应用基线当前所用的自定义env
        self.change_envs = change_envs
        # sidecar的发布版本号
        self.release_version = release_version
        # 上一次的发布版本号
        self.last_release_version = last_release_version

    def validate(self):
        self.validate_required(self.sidecar_name, 'sidecar_name')
        self.validate_required(self.sidecar_version, 'sidecar_version')
        self.validate_required(self.image, 'image')
        self.validate_required(self.release_version, 'release_version')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.feature_gates is not None:
            result['feature_gates'] = self.feature_gates
        if self.image is not None:
            result['image'] = self.image
        if self.change_envs is not None:
            result['change_envs'] = self.change_envs
        if self.release_version is not None:
            result['release_version'] = self.release_version
        if self.last_release_version is not None:
            result['last_release_version'] = self.last_release_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('feature_gates') is not None:
            self.feature_gates = m.get('feature_gates')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('change_envs') is not None:
            self.change_envs = m.get('change_envs')
        if m.get('release_version') is not None:
            self.release_version = m.get('release_version')
        if m.get('last_release_version') is not None:
            self.last_release_version = m.get('last_release_version')
        return self


class ContainerServiceDeployment(TeaModel):
    def __init__(
        self,
        container_service_name: str = None,
        container_service_revision: str = None,
        depend_container_service_names: List[str] = None,
        restricted_cells: List[str] = None,
        batches: List[ReleaseBatchObj] = None,
        upgrade_policy: str = None,
        deployment_template_name: str = None,
        deployment_template_hooks: List[CustomHook] = None,
    ):
        # 容器服务名称。
        self.container_service_name = container_service_name
        # 容器服务版本号。
        self.container_service_revision = container_service_revision
        # 依赖的容器应用服务名称。
        self.depend_container_service_names = depend_container_service_names
        # 限定需要发布的部署单元
        self.restricted_cells = restricted_cells
        # 自定义发布批次
        self.batches = batches
        # 默认ByIndex
        self.upgrade_policy = upgrade_policy
        # 发布模板名称
        self.deployment_template_name = deployment_template_name
        # 发布模板卡点规则
        self.deployment_template_hooks = deployment_template_hooks

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.container_service_revision, 'container_service_revision')
        self.validate_required(self.depend_container_service_names, 'depend_container_service_names')
        if self.batches:
            for k in self.batches:
                if k:
                    k.validate()
        if self.deployment_template_hooks:
            for k in self.deployment_template_hooks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.container_service_revision is not None:
            result['container_service_revision'] = self.container_service_revision
        if self.depend_container_service_names is not None:
            result['depend_container_service_names'] = self.depend_container_service_names
        if self.restricted_cells is not None:
            result['restricted_cells'] = self.restricted_cells
        result['batches'] = []
        if self.batches is not None:
            for k in self.batches:
                result['batches'].append(k.to_map() if k else None)
        if self.upgrade_policy is not None:
            result['upgrade_policy'] = self.upgrade_policy
        if self.deployment_template_name is not None:
            result['deployment_template_name'] = self.deployment_template_name
        result['deployment_template_hooks'] = []
        if self.deployment_template_hooks is not None:
            for k in self.deployment_template_hooks:
                result['deployment_template_hooks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('container_service_revision') is not None:
            self.container_service_revision = m.get('container_service_revision')
        if m.get('depend_container_service_names') is not None:
            self.depend_container_service_names = m.get('depend_container_service_names')
        if m.get('restricted_cells') is not None:
            self.restricted_cells = m.get('restricted_cells')
        self.batches = []
        if m.get('batches') is not None:
            for k in m.get('batches'):
                temp_model = ReleaseBatchObj()
                self.batches.append(temp_model.from_map(k))
        if m.get('upgrade_policy') is not None:
            self.upgrade_policy = m.get('upgrade_policy')
        if m.get('deployment_template_name') is not None:
            self.deployment_template_name = m.get('deployment_template_name')
        self.deployment_template_hooks = []
        if m.get('deployment_template_hooks') is not None:
            for k in m.get('deployment_template_hooks'):
                temp_model = CustomHook()
                self.deployment_template_hooks.append(temp_model.from_map(k))
        return self


class MasterCluster(TeaModel):
    def __init__(
        self,
        name: str = None,
        workspace_id: str = None,
        workspace_name: str = None,
        region_id: str = None,
        region_name: str = None,
        zone_id: str = None,
        zone_name: str = None,
    ):
        # master cluster name
        self.name = name
        # workspace id
        self.workspace_id = workspace_id
        # workspace name
        self.workspace_name = workspace_name
        # region id
        self.region_id = region_id
        # region name
        self.region_name = region_name
        # zone id
        self.zone_id = zone_id
        # zone name
        self.zone_name = zone_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.region_id, 'region_id')
        self.validate_required(self.zone_id, 'zone_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        if self.region_id is not None:
            result['region_id'] = self.region_id
        if self.region_name is not None:
            result['region_name'] = self.region_name
        if self.zone_id is not None:
            result['zone_id'] = self.zone_id
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        if m.get('region_id') is not None:
            self.region_id = m.get('region_id')
        if m.get('region_name') is not None:
            self.region_name = m.get('region_name')
        if m.get('zone_id') is not None:
            self.zone_id = m.get('zone_id')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        return self


class FedSecretOverride(TeaModel):
    def __init__(
        self,
        data: List[SecretData] = None,
        name: str = None,
        name_override: str = None,
    ):
        # 要覆盖的保密字典数据
        self.data = data
        # 部署单元的名称
        self.name = name
        # 覆盖的名称，必须为：保密字典名称-cell-部署单元名称
        self.name_override = name_override

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.name_override, 'name_override')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.name_override is not None:
            result['name_override'] = self.name_override
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = SecretData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('name_override') is not None:
            self.name_override = m.get('name_override')
        return self


class EntrySettings(TeaModel):
    def __init__(
        self,
        customized: bool = None,
        entry_ids: List[MapStringToString] = None,
        entry_vips: List[MapStringToString] = None,
    ):
        # 是否自定义uai entry
        self.customized = customized
        # 统一接入实例每个datacenter的用户自定义入口负载均衡实例id列表
        self.entry_ids = entry_ids
        # 统一接入实例每个datacenter用户自定义入口负载均衡实例的vip
        self.entry_vips = entry_vips

    def validate(self):
        if self.entry_ids:
            for k in self.entry_ids:
                if k:
                    k.validate()
        if self.entry_vips:
            for k in self.entry_vips:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.customized is not None:
            result['customized'] = self.customized
        result['entry_ids'] = []
        if self.entry_ids is not None:
            for k in self.entry_ids:
                result['entry_ids'].append(k.to_map() if k else None)
        result['entry_vips'] = []
        if self.entry_vips is not None:
            for k in self.entry_vips:
                result['entry_vips'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('customized') is not None:
            self.customized = m.get('customized')
        self.entry_ids = []
        if m.get('entry_ids') is not None:
            for k in m.get('entry_ids'):
                temp_model = MapStringToString()
                self.entry_ids.append(temp_model.from_map(k))
        self.entry_vips = []
        if m.get('entry_vips') is not None:
            for k in m.get('entry_vips'):
                temp_model = MapStringToString()
                self.entry_vips.append(temp_model.from_map(k))
        return self


class OpsParam(TeaModel):
    def __init__(
        self,
        key: str = None,
        value: str = None,
    ):
        # 部署参数键值
        self.key = key
        # 部署参数值
        self.value = value

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['key'] = self.key
        if self.value is not None:
            result['value'] = self.value
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('key') is not None:
            self.key = m.get('key')
        if m.get('value') is not None:
            self.value = m.get('value')
        return self


class UnifiedAccessInstanceLocalDetailInfo(TeaModel):
    def __init__(
        self,
        cluster_name: str = None,
        data_center: str = None,
        message_details: str = None,
        status: str = None,
        vip: str = None,
        http_entry_status: HttpEntryStatus = None,
        https_entry_status: HttpsEntryStatus = None,
    ):
        # 所属集群名称
        self.cluster_name = cluster_name
        # 所在可用区，即AZ信息
        self.data_center = data_center
        # local实例详细信息显示，包含错误状态信息等
        self.message_details = message_details
        # local实例状态描述：创建中、创建成功、创建失败
        self.status = status
        # vip信息
        self.vip = vip
        # http entry的状态
        self.http_entry_status = http_entry_status
        # https entry的状态
        self.https_entry_status = https_entry_status

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.data_center, 'data_center')
        self.validate_required(self.status, 'status')
        self.validate_required(self.vip, 'vip')
        if self.http_entry_status:
            self.http_entry_status.validate()
        if self.https_entry_status:
            self.https_entry_status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.data_center is not None:
            result['data_center'] = self.data_center
        if self.message_details is not None:
            result['message_details'] = self.message_details
        if self.status is not None:
            result['status'] = self.status
        if self.vip is not None:
            result['vip'] = self.vip
        if self.http_entry_status is not None:
            result['http_entry_status'] = self.http_entry_status.to_map()
        if self.https_entry_status is not None:
            result['https_entry_status'] = self.https_entry_status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('data_center') is not None:
            self.data_center = m.get('data_center')
        if m.get('message_details') is not None:
            self.message_details = m.get('message_details')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('vip') is not None:
            self.vip = m.get('vip')
        if m.get('http_entry_status') is not None:
            temp_model = HttpEntryStatus()
            self.http_entry_status = temp_model.from_map(m['http_entry_status'])
        if m.get('https_entry_status') is not None:
            temp_model = HttpsEntryStatus()
            self.https_entry_status = temp_model.from_map(m['https_entry_status'])
        return self


class ZoneInfo(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        region: str = None,
        display_name: str = None,
    ):
        # zone identity
        self.id = id
        # zone name
        self.name = name
        # 所属region信息。
        self.region = region
        # zone display name
        self.display_name = display_name

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.display_name, 'display_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.region is not None:
            result['region'] = self.region
        if self.display_name is not None:
            result['display_name'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        return self


class CellFlow(TeaModel):
    def __init__(
        self,
        name: str = None,
        color: str = None,
        percent: int = None,
    ):
        # 部署单元名称
        self.name = name
        # 蓝绿着色。
        # BLUE：蓝
        # GREEN：绿
        # 非着色单元为 null
        self.color = color
        # 部署单元所占单元组的流量比。
        self.percent = percent

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.percent, 'percent')
        if self.percent is not None:
            self.validate_maximum(self.percent, 'percent', 100)
            self.validate_minimum(self.percent, 'percent', 0)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.color is not None:
            result['color'] = self.color
        if self.percent is not None:
            result['percent'] = self.percent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('percent') is not None:
            self.percent = m.get('percent')
        return self


class LocalSpannerClusterDetail(TeaModel):
    def __init__(
        self,
        az: str = None,
        cluster_name: str = None,
        message: str = None,
        phase: str = None,
        spanner_cluster_id: str = None,
        state: str = None,
        sub_clusters_details: List[LocalSubClusterDetail] = None,
    ):
        # 可用区
        self.az = az
        # 本地集群名称
        self.cluster_name = cluster_name
        # 可能存在的错误信息
        self.message = message
        # 集群状态
        self.phase = phase
        # spanner cluster 集群id
        self.spanner_cluster_id = spanner_cluster_id
        # 描述spanner cluster健康状态
        self.state = state
        # 若干组容器信息
        self.sub_clusters_details = sub_clusters_details

    def validate(self):
        self.validate_required(self.az, 'az')
        self.validate_required(self.cluster_name, 'cluster_name')
        if self.sub_clusters_details:
            for k in self.sub_clusters_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.az is not None:
            result['az'] = self.az
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.message is not None:
            result['message'] = self.message
        if self.phase is not None:
            result['phase'] = self.phase
        if self.spanner_cluster_id is not None:
            result['spanner_cluster_id'] = self.spanner_cluster_id
        if self.state is not None:
            result['state'] = self.state
        result['sub_clusters_details'] = []
        if self.sub_clusters_details is not None:
            for k in self.sub_clusters_details:
                result['sub_clusters_details'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('az') is not None:
            self.az = m.get('az')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('phase') is not None:
            self.phase = m.get('phase')
        if m.get('spanner_cluster_id') is not None:
            self.spanner_cluster_id = m.get('spanner_cluster_id')
        if m.get('state') is not None:
            self.state = m.get('state')
        self.sub_clusters_details = []
        if m.get('sub_clusters_details') is not None:
            for k in m.get('sub_clusters_details'):
                temp_model = LocalSubClusterDetail()
                self.sub_clusters_details.append(temp_model.from_map(k))
        return self


class FederatedDeploymentStatus(TeaModel):
    def __init__(
        self,
        conditions: List[DeploymentCondition] = None,
        topologies: List[FederatedDeploymentStatusTopologies] = None,
    ):
        # Federated Deployment Conditions
        self.conditions = conditions
        # V1FederatedDeploymentStatus Topologies
        self.topologies = topologies

    def validate(self):
        self.validate_required(self.conditions, 'conditions')
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()
        self.validate_required(self.topologies, 'topologies')
        if self.topologies:
            for k in self.topologies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['conditions'].append(k.to_map() if k else None)
        result['topologies'] = []
        if self.topologies is not None:
            for k in self.topologies:
                result['topologies'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.conditions = []
        if m.get('conditions') is not None:
            for k in m.get('conditions'):
                temp_model = DeploymentCondition()
                self.conditions.append(temp_model.from_map(k))
        self.topologies = []
        if m.get('topologies') is not None:
            for k in m.get('topologies'):
                temp_model = FederatedDeploymentStatusTopologies()
                self.topologies.append(temp_model.from_map(k))
        return self


class HttpsEntry(TeaModel):
    def __init__(
        self,
        port: int = None,
        websocket_connect: bool = None,
        ca_certificate_id: str = None,
    ):
        # 端口
        self.port = port
        # 是否使用websocket连接方式
        self.websocket_connect = websocket_connect
        # CA证书ID
        self.ca_certificate_id = ca_certificate_id

    def validate(self):
        self.validate_required(self.port, 'port')
        self.validate_required(self.websocket_connect, 'websocket_connect')
        self.validate_required(self.ca_certificate_id, 'ca_certificate_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['port'] = self.port
        if self.websocket_connect is not None:
            result['websocket_connect'] = self.websocket_connect
        if self.ca_certificate_id is not None:
            result['ca_certificate_id'] = self.ca_certificate_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('websocket_connect') is not None:
            self.websocket_connect = m.get('websocket_connect')
        if m.get('ca_certificate_id') is not None:
            self.ca_certificate_id = m.get('ca_certificate_id')
        return self


class ServicePort(TeaModel):
    def __init__(
        self,
        name: str = None,
        protocol: str = None,
        port: int = None,
        node_port: int = None,
        target_port: int = None,
    ):
        # 此端口映射名称
        self.name = name
        # service端口映射在k8s层面的协议名，包括"TCP", "UDP", and "SCTP".
        self.protocol = protocol
        # service端口映射前端端口
        self.port = port
        # service分配到的节点端口
        self.node_port = node_port
        # 后端端口，这里仅支持整数类型
        self.target_port = target_port

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.port, 'port')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.port is not None:
            result['port'] = self.port
        if self.node_port is not None:
            result['node_port'] = self.node_port
        if self.target_port is not None:
            result['target_port'] = self.target_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('node_port') is not None:
            self.node_port = m.get('node_port')
        if m.get('target_port') is not None:
            self.target_port = m.get('target_port')
        return self


class KubernetesEvents(TeaModel):
    def __init__(
        self,
        creation_timestamp: str = None,
        count: int = None,
        message: str = None,
    ):
        # 事件发生时间
        self.creation_timestamp = creation_timestamp
        # 事件数目
        self.count = count
        # 事件内容
        self.message = message

    def validate(self):
        self.validate_required(self.creation_timestamp, 'creation_timestamp')
        self.validate_required(self.count, 'count')
        self.validate_required(self.message, 'message')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_timestamp is not None:
            result['creation_timestamp'] = self.creation_timestamp
        if self.count is not None:
            result['count'] = self.count
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('creation_timestamp') is not None:
            self.creation_timestamp = m.get('creation_timestamp')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class SpannerClusterUnitInfo(TeaModel):
    def __init__(
        self,
        address: str = None,
        cluster_id: str = None,
        container_id: str = None,
        gmt_create: str = None,
        gmt_modify: str = None,
        status: int = None,
        extend_properties: str = None,
    ):
        # 单元IP地址
        self.address = address
        # 所属集群id
        self.cluster_id = cluster_id
        # 容器id
        self.container_id = container_id
        # 创建时间
        self.gmt_create = gmt_create
        # 修改时间
        self.gmt_modify = gmt_modify
        # 集群单元状态 ： 1-下线状态 2- 上线状态 3-删除状态
        self.status = status
        # 扩展信息，json字符串格式
        self.extend_properties = extend_properties

    def validate(self):
        self.validate_required(self.address, 'address')
        self.validate_required(self.cluster_id, 'cluster_id')
        self.validate_required(self.container_id, 'container_id')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.gmt_modify, 'gmt_modify')
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['address'] = self.address
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.container_id is not None:
            result['container_id'] = self.container_id
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.gmt_modify is not None:
            result['gmt_modify'] = self.gmt_modify
        if self.status is not None:
            result['status'] = self.status
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('address') is not None:
            self.address = m.get('address')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('container_id') is not None:
            self.container_id = m.get('container_id')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('gmt_modify') is not None:
            self.gmt_modify = m.get('gmt_modify')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        return self


class LivenessProbe(TeaModel):
    def __init__(
        self,
        exec_action: ExecAction = None,
        failure_threshold: int = None,
        http_get_action: HttpGetAction = None,
        initial_delay_seconds: int = None,
        period_seconds: int = None,
        success_threshold: int = None,
        tcp_socket_action: TcpSocketAction = None,
        timeout_seconds: int = None,
    ):
        # 命令行方式的健康监测配置。
        self.exec_action = exec_action
        # 不健康阈值。
        self.failure_threshold = failure_threshold
        # http方式的健康监测配置。
        self.http_get_action = http_get_action
        # 首次检查延时。
        self.initial_delay_seconds = initial_delay_seconds
        # 检查间隔。
        self.period_seconds = period_seconds
        # 健康阈值。
        # 
        self.success_threshold = success_threshold
        # tcp方式的健康监测配置。
        self.tcp_socket_action = tcp_socket_action
        # 检查超时。
        self.timeout_seconds = timeout_seconds

    def validate(self):
        if self.exec_action:
            self.exec_action.validate()
        self.validate_required(self.failure_threshold, 'failure_threshold')
        if self.http_get_action:
            self.http_get_action.validate()
        self.validate_required(self.initial_delay_seconds, 'initial_delay_seconds')
        self.validate_required(self.period_seconds, 'period_seconds')
        self.validate_required(self.success_threshold, 'success_threshold')
        if self.tcp_socket_action:
            self.tcp_socket_action.validate()
        self.validate_required(self.timeout_seconds, 'timeout_seconds')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.exec_action is not None:
            result['exec_action'] = self.exec_action.to_map()
        if self.failure_threshold is not None:
            result['failure_threshold'] = self.failure_threshold
        if self.http_get_action is not None:
            result['http_get_action'] = self.http_get_action.to_map()
        if self.initial_delay_seconds is not None:
            result['initial_delay_seconds'] = self.initial_delay_seconds
        if self.period_seconds is not None:
            result['period_seconds'] = self.period_seconds
        if self.success_threshold is not None:
            result['success_threshold'] = self.success_threshold
        if self.tcp_socket_action is not None:
            result['tcp_socket_action'] = self.tcp_socket_action.to_map()
        if self.timeout_seconds is not None:
            result['timeout_seconds'] = self.timeout_seconds
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('exec_action') is not None:
            temp_model = ExecAction()
            self.exec_action = temp_model.from_map(m['exec_action'])
        if m.get('failure_threshold') is not None:
            self.failure_threshold = m.get('failure_threshold')
        if m.get('http_get_action') is not None:
            temp_model = HttpGetAction()
            self.http_get_action = temp_model.from_map(m['http_get_action'])
        if m.get('initial_delay_seconds') is not None:
            self.initial_delay_seconds = m.get('initial_delay_seconds')
        if m.get('period_seconds') is not None:
            self.period_seconds = m.get('period_seconds')
        if m.get('success_threshold') is not None:
            self.success_threshold = m.get('success_threshold')
        if m.get('tcp_socket_action') is not None:
            temp_model = TcpSocketAction()
            self.tcp_socket_action = temp_model.from_map(m['tcp_socket_action'])
        if m.get('timeout_seconds') is not None:
            self.timeout_seconds = m.get('timeout_seconds')
        return self


class ClusterState(TeaModel):
    def __init__(
        self,
        cluster_name: str = None,
        state: str = None,
        message: str = None,
    ):
        # 集群名称
        self.cluster_name = cluster_name
        # 联邦资源的分发状态，空字符串代表成功，否则为错误码
        self.state = state
        # 详细错误信息
        self.message = message

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.state, 'state')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.state is not None:
            result['state'] = self.state
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class ContainerServiceReleaseInfo(TeaModel):
    def __init__(
        self,
        created_plan_id: str = None,
        latest_deployment_start_time: str = None,
        latest_deployment_end_time: str = None,
    ):
        # 发布单id
        self.created_plan_id = created_plan_id
        # 发布开始时间
        self.latest_deployment_start_time = latest_deployment_start_time
        # 发布完成时间
        self.latest_deployment_end_time = latest_deployment_end_time

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_plan_id is not None:
            result['created_plan_id'] = self.created_plan_id
        if self.latest_deployment_start_time is not None:
            result['latest_deployment_start_time'] = self.latest_deployment_start_time
        if self.latest_deployment_end_time is not None:
            result['latest_deployment_end_time'] = self.latest_deployment_end_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_plan_id') is not None:
            self.created_plan_id = m.get('created_plan_id')
        if m.get('latest_deployment_start_time') is not None:
            self.latest_deployment_start_time = m.get('latest_deployment_start_time')
        if m.get('latest_deployment_end_time') is not None:
            self.latest_deployment_end_time = m.get('latest_deployment_end_time')
        return self


class ServiceStatus(TeaModel):
    def __init__(
        self,
        load_balancer_ip: str = None,
    ):
        # 负载均衡地址
        self.load_balancer_ip = load_balancer_ip

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.load_balancer_ip is not None:
            result['load_balancer_ip'] = self.load_balancer_ip
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('load_balancer_ip') is not None:
            self.load_balancer_ip = m.get('load_balancer_ip')
        return self


class Deployment(TeaModel):
    def __init__(
        self,
        metadata: ObjectMeta = None,
        spec: DeploymentSpec = None,
        status: DeploymentStatus = None,
    ):
        # Standard object metadata.
        # 
        self.metadata = metadata
        # Specification of the desired behavior of the Deployment.
        # 
        self.spec = spec
        # Most recently observed status of the Deployment.
        # 
        self.status = status

    def validate(self):
        self.validate_required(self.metadata, 'metadata')
        if self.metadata:
            self.metadata.validate()
        self.validate_required(self.spec, 'spec')
        if self.spec:
            self.spec.validate()
        self.validate_required(self.status, 'status')
        if self.status:
            self.status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        if self.spec is not None:
            result['spec'] = self.spec.to_map()
        if self.status is not None:
            result['status'] = self.status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('metadata') is not None:
            temp_model = ObjectMeta()
            self.metadata = temp_model.from_map(m['metadata'])
        if m.get('spec') is not None:
            temp_model = DeploymentSpec()
            self.spec = temp_model.from_map(m['spec'])
        if m.get('status') is not None:
            temp_model = DeploymentStatus()
            self.status = temp_model.from_map(m['status'])
        return self


class FedConfigmapOverride(TeaModel):
    def __init__(
        self,
        data: List[ConfigMapData] = None,
        name: str = None,
        name_override: str = None,
    ):
        # 要覆盖的配置项数据
        self.data = data
        # 部署单元名称
        self.name = name
        # 覆盖的名称，必须为：配置项名称-cell-部署单元名称
        self.name_override = name_override

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.name_override, 'name_override')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.name_override is not None:
            result['name_override'] = self.name_override
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ConfigMapData()
                self.data.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('name_override') is not None:
            self.name_override = m.get('name_override')
        return self


class CellWeightInfo(TeaModel):
    def __init__(
        self,
        workspace: str = None,
        name: str = None,
        weight: int = None,
    ):
        # 部署单元所属工作空间
        self.workspace = workspace
        # 部署单元名称
        self.name = name
        # 部署单元所占单元组流量比重
        self.weight = weight

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.weight, 'weight')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace is not None:
            result['workspace'] = self.workspace
        if self.name is not None:
            result['name'] = self.name
        if self.weight is not None:
            result['weight'] = self.weight
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        return self


class DisasterInfo(TeaModel):
    def __init__(
        self,
        local_failover_target: str = None,
        remote_failover_target: str = None,
        source: str = None,
        type: str = None,
        disaster_recovery_state: str = None,
        press_disaster_recovery_state: str = None,
    ):
        # 同城灾备单元(组)
        self.local_failover_target = local_failover_target
        # 异地灾备单元(组)
        self.remote_failover_target = remote_failover_target
        # 逻辑单元&部署单元名称
        self.source = source
        # 容灾类型
        self.type = type
        # 正常容灾状态。
        self.disaster_recovery_state = disaster_recovery_state
        # 压测容灾状态。
        self.press_disaster_recovery_state = press_disaster_recovery_state

    def validate(self):
        self.validate_required(self.local_failover_target, 'local_failover_target')
        self.validate_required(self.remote_failover_target, 'remote_failover_target')
        self.validate_required(self.source, 'source')
        self.validate_required(self.type, 'type')
        self.validate_required(self.disaster_recovery_state, 'disaster_recovery_state')
        self.validate_required(self.press_disaster_recovery_state, 'press_disaster_recovery_state')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.local_failover_target is not None:
            result['local_failover_target'] = self.local_failover_target
        if self.remote_failover_target is not None:
            result['remote_failover_target'] = self.remote_failover_target
        if self.source is not None:
            result['source'] = self.source
        if self.type is not None:
            result['type'] = self.type
        if self.disaster_recovery_state is not None:
            result['disaster_recovery_state'] = self.disaster_recovery_state
        if self.press_disaster_recovery_state is not None:
            result['press_disaster_recovery_state'] = self.press_disaster_recovery_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('local_failover_target') is not None:
            self.local_failover_target = m.get('local_failover_target')
        if m.get('remote_failover_target') is not None:
            self.remote_failover_target = m.get('remote_failover_target')
        if m.get('source') is not None:
            self.source = m.get('source')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('disaster_recovery_state') is not None:
            self.disaster_recovery_state = m.get('disaster_recovery_state')
        if m.get('press_disaster_recovery_state') is not None:
            self.press_disaster_recovery_state = m.get('press_disaster_recovery_state')
        return self


class AppDeployGroup(TeaModel):
    def __init__(
        self,
        deploy_task: AppDeployTask = None,
        post_tasks: List[AppDeployTask] = None,
        pre_tasks: List[AppDeployTask] = None,
    ):
        # 发布任务
        self.deploy_task = deploy_task
        # 后置任务列表
        self.post_tasks = post_tasks
        # 前置任务列表
        self.pre_tasks = pre_tasks

    def validate(self):
        self.validate_required(self.deploy_task, 'deploy_task')
        if self.deploy_task:
            self.deploy_task.validate()
        self.validate_required(self.post_tasks, 'post_tasks')
        if self.post_tasks:
            for k in self.post_tasks:
                if k:
                    k.validate()
        self.validate_required(self.pre_tasks, 'pre_tasks')
        if self.pre_tasks:
            for k in self.pre_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deploy_task is not None:
            result['deploy_task'] = self.deploy_task.to_map()
        result['post_tasks'] = []
        if self.post_tasks is not None:
            for k in self.post_tasks:
                result['post_tasks'].append(k.to_map() if k else None)
        result['pre_tasks'] = []
        if self.pre_tasks is not None:
            for k in self.pre_tasks:
                result['pre_tasks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('deploy_task') is not None:
            temp_model = AppDeployTask()
            self.deploy_task = temp_model.from_map(m['deploy_task'])
        self.post_tasks = []
        if m.get('post_tasks') is not None:
            for k in m.get('post_tasks'):
                temp_model = AppDeployTask()
                self.post_tasks.append(temp_model.from_map(k))
        self.pre_tasks = []
        if m.get('pre_tasks') is not None:
            for k in m.get('pre_tasks'):
                temp_model = AppDeployTask()
                self.pre_tasks.append(temp_model.from_map(k))
        return self


class UnifiedAccessInstanceContainerServiceInfo(TeaModel):
    def __init__(
        self,
        container_service_name: str = None,
        namespace: str = None,
    ):
        # 应用服务名称
        self.container_service_name = container_service_name
        # 命名空间
        self.namespace = namespace

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class SidecarOperationTaskContext(TeaModel):
    def __init__(
        self,
        enabled_features: str = None,
        sidecar_types: List[str] = None,
        sidecar_version_map: str = None,
        supported_features: str = None,
        change_instances: List[OperationChangeInstance] = None,
        app_name: str = None,
    ):
        # sidecar开启特性
        self.enabled_features = enabled_features
        # sidecar类型
        self.sidecar_types = sidecar_types
        # sidecar版本
        self.sidecar_version_map = sidecar_version_map
        # sidecar支持特性
        self.supported_features = supported_features
        # 变更资源列表
        self.change_instances = change_instances
        # 应用名称
        self.app_name = app_name

    def validate(self):
        self.validate_required(self.sidecar_types, 'sidecar_types')
        self.validate_required(self.sidecar_version_map, 'sidecar_version_map')
        self.validate_required(self.change_instances, 'change_instances')
        if self.change_instances:
            for k in self.change_instances:
                if k:
                    k.validate()
        self.validate_required(self.app_name, 'app_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled_features is not None:
            result['enabled_features'] = self.enabled_features
        if self.sidecar_types is not None:
            result['sidecar_types'] = self.sidecar_types
        if self.sidecar_version_map is not None:
            result['sidecar_version_map'] = self.sidecar_version_map
        if self.supported_features is not None:
            result['supported_features'] = self.supported_features
        result['change_instances'] = []
        if self.change_instances is not None:
            for k in self.change_instances:
                result['change_instances'].append(k.to_map() if k else None)
        if self.app_name is not None:
            result['app_name'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('enabled_features') is not None:
            self.enabled_features = m.get('enabled_features')
        if m.get('sidecar_types') is not None:
            self.sidecar_types = m.get('sidecar_types')
        if m.get('sidecar_version_map') is not None:
            self.sidecar_version_map = m.get('sidecar_version_map')
        if m.get('supported_features') is not None:
            self.supported_features = m.get('supported_features')
        self.change_instances = []
        if m.get('change_instances') is not None:
            for k in m.get('change_instances'):
                temp_model = OperationChangeInstance()
                self.change_instances.append(temp_model.from_map(k))
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        return self


class UidShard(TeaModel):
    def __init__(
        self,
        min_uid: int = None,
        max_uid: int = None,
    ):
        # UID 起始值
        self.min_uid = min_uid
        # UID 终止值
        self.max_uid = max_uid

    def validate(self):
        self.validate_required(self.min_uid, 'min_uid')
        self.validate_required(self.max_uid, 'max_uid')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.min_uid is not None:
            result['min_uid'] = self.min_uid
        if self.max_uid is not None:
            result['max_uid'] = self.max_uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('min_uid') is not None:
            self.min_uid = m.get('min_uid')
        if m.get('max_uid') is not None:
            self.max_uid = m.get('max_uid')
        return self


class HttpEntry(TeaModel):
    def __init__(
        self,
        port: int = None,
        websocket_connect: bool = None,
    ):
        # 端口
        self.port = port
        # 是否使用websocket连接方式
        self.websocket_connect = websocket_connect

    def validate(self):
        self.validate_required(self.port, 'port')
        self.validate_required(self.websocket_connect, 'websocket_connect')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.port is not None:
            result['port'] = self.port
        if self.websocket_connect is not None:
            result['websocket_connect'] = self.websocket_connect
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('websocket_connect') is not None:
            self.websocket_connect = m.get('websocket_connect')
        return self


class SidecarOpsMachine(TeaModel):
    def __init__(
        self,
        id: str = None,
        target: str = None,
        status: str = None,
        status_desc: str = None,
        properties: str = None,
        message: str = None,
        sub_targets: List[SidecarOpsMachineTask] = None,
    ):
        # 机器运维流程ID
        self.id = id
        # 运维机器名称
        self.target = target
        # 执行状态
        self.status = status
        # 执行状态描述
        self.status_desc = status_desc
        # 扩展属性
        self.properties = properties
        # 执行消息日志
        self.message = message
        # 机器sidecar运维任务列表
        self.sub_targets = sub_targets

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.target, 'target')
        self.validate_required(self.status, 'status')
        self.validate_required(self.sub_targets, 'sub_targets')
        if self.sub_targets:
            for k in self.sub_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.target is not None:
            result['target'] = self.target
        if self.status is not None:
            result['status'] = self.status
        if self.status_desc is not None:
            result['status_desc'] = self.status_desc
        if self.properties is not None:
            result['properties'] = self.properties
        if self.message is not None:
            result['message'] = self.message
        result['sub_targets'] = []
        if self.sub_targets is not None:
            for k in self.sub_targets:
                result['sub_targets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('status_desc') is not None:
            self.status_desc = m.get('status_desc')
        if m.get('properties') is not None:
            self.properties = m.get('properties')
        if m.get('message') is not None:
            self.message = m.get('message')
        self.sub_targets = []
        if m.get('sub_targets') is not None:
            for k in m.get('sub_targets'):
                temp_model = SidecarOpsMachineTask()
                self.sub_targets.append(temp_model.from_map(k))
        return self


class ServiceProcessLog(TeaModel):
    def __init__(
        self,
        attributes: str = None,
        error_stack_traces: str = None,
        exec_phase: str = None,
        inv_object_kind: str = None,
        inv_object_name: str = None,
        inv_object_namespace: str = None,
        log_time: str = None,
        message: str = None,
        reason: str = None,
        ref_plan: str = None,
        ref_service: str = None,
        source: str = None,
    ):
        # Logs属性
        self.attributes = attributes
        # 错误追溯
        self.error_stack_traces = error_stack_traces
        # 发布阶段，INIT，PARSE， EXECUTE
        self.exec_phase = exec_phase
        # 关联对象类型，RPV2，RP_STAGE，POD
        self.inv_object_kind = inv_object_kind
        # 对应object的name
        self.inv_object_name = inv_object_name
        # 对应object的namespace
        self.inv_object_namespace = inv_object_namespace
        # log_time
        self.log_time = log_time
        # Logs详情
        self.message = message
        # Logs原因
        self.reason = reason
        # 关联的ldc_plan id
        self.ref_plan = ref_plan
        # 关联的lks_service id
        self.ref_service = ref_service
        # Logs的来源，ldcconsole，orch_event，opsware_event
        self.source = source

    def validate(self):
        self.validate_required(self.attributes, 'attributes')
        self.validate_required(self.error_stack_traces, 'error_stack_traces')
        self.validate_required(self.exec_phase, 'exec_phase')
        self.validate_required(self.inv_object_kind, 'inv_object_kind')
        self.validate_required(self.inv_object_name, 'inv_object_name')
        self.validate_required(self.inv_object_namespace, 'inv_object_namespace')
        self.validate_required(self.log_time, 'log_time')
        if self.log_time is not None:
            self.validate_pattern(self.log_time, 'log_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.message, 'message')
        self.validate_required(self.reason, 'reason')
        self.validate_required(self.ref_plan, 'ref_plan')
        self.validate_required(self.ref_service, 'ref_service')
        self.validate_required(self.source, 'source')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attributes is not None:
            result['attributes'] = self.attributes
        if self.error_stack_traces is not None:
            result['error_stack_traces'] = self.error_stack_traces
        if self.exec_phase is not None:
            result['exec_phase'] = self.exec_phase
        if self.inv_object_kind is not None:
            result['inv_object_kind'] = self.inv_object_kind
        if self.inv_object_name is not None:
            result['inv_object_name'] = self.inv_object_name
        if self.inv_object_namespace is not None:
            result['inv_object_namespace'] = self.inv_object_namespace
        if self.log_time is not None:
            result['log_time'] = self.log_time
        if self.message is not None:
            result['message'] = self.message
        if self.reason is not None:
            result['reason'] = self.reason
        if self.ref_plan is not None:
            result['ref_plan'] = self.ref_plan
        if self.ref_service is not None:
            result['ref_service'] = self.ref_service
        if self.source is not None:
            result['source'] = self.source
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('attributes') is not None:
            self.attributes = m.get('attributes')
        if m.get('error_stack_traces') is not None:
            self.error_stack_traces = m.get('error_stack_traces')
        if m.get('exec_phase') is not None:
            self.exec_phase = m.get('exec_phase')
        if m.get('inv_object_kind') is not None:
            self.inv_object_kind = m.get('inv_object_kind')
        if m.get('inv_object_name') is not None:
            self.inv_object_name = m.get('inv_object_name')
        if m.get('inv_object_namespace') is not None:
            self.inv_object_namespace = m.get('inv_object_namespace')
        if m.get('log_time') is not None:
            self.log_time = m.get('log_time')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('ref_plan') is not None:
            self.ref_plan = m.get('ref_plan')
        if m.get('ref_service') is not None:
            self.ref_service = m.get('ref_service')
        if m.get('source') is not None:
            self.source = m.get('source')
        return self


class OpsApplicationChain(TeaModel):
    def __init__(
        self,
        groups: List[OpsApplicationGroup] = None,
    ):
        # 此运维应用链中包含的应用组列表
        self.groups = groups

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = OpsApplicationGroup()
                self.groups.append(temp_model.from_map(k))
        return self


class AppGroupSimpleViewList(TeaModel):
    def __init__(
        self,
        app_group_list: List[AppGroupSimpleView] = None,
    ):
        # 应用分组列表
        self.app_group_list = app_group_list

    def validate(self):
        self.validate_required(self.app_group_list, 'app_group_list')
        if self.app_group_list:
            for k in self.app_group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['app_group_list'] = []
        if self.app_group_list is not None:
            for k in self.app_group_list:
                result['app_group_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.app_group_list = []
        if m.get('app_group_list') is not None:
            for k in m.get('app_group_list'):
                temp_model = AppGroupSimpleView()
                self.app_group_list.append(temp_model.from_map(k))
        return self


class AppReleaseConfigDependOn(TeaModel):
    def __init__(
        self,
        kind: str = None,
        name: str = None,
    ):
        # 类型
        self.kind = kind
        # 名称
        self.name = name

    def validate(self):
        self.validate_required(self.kind, 'kind')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.kind is not None:
            result['kind'] = self.kind
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('kind') is not None:
            self.kind = m.get('kind')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class Zone(TeaModel):
    def __init__(
        self,
        data_center: str = None,
        display_name: str = None,
        name: str = None,
        region: str = None,
        zone_id: str = None,
        region_id: str = None,
    ):
        # 数据中心名
        self.data_center = data_center
        # 可用区展示名
        self.display_name = display_name
        # 可用区名
        self.name = name
        # 所属地域
        self.region = region
        # 可用区id
        self.zone_id = zone_id
        # 地域id
        self.region_id = region_id

    def validate(self):
        self.validate_required(self.data_center, 'data_center')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.name, 'name')
        self.validate_required(self.region, 'region')
        self.validate_required(self.zone_id, 'zone_id')
        self.validate_required(self.region_id, 'region_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_center is not None:
            result['data_center'] = self.data_center
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.name is not None:
            result['name'] = self.name
        if self.region is not None:
            result['region'] = self.region
        if self.zone_id is not None:
            result['zone_id'] = self.zone_id
        if self.region_id is not None:
            result['region_id'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('data_center') is not None:
            self.data_center = m.get('data_center')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('zone_id') is not None:
            self.zone_id = m.get('zone_id')
        if m.get('region_id') is not None:
            self.region_id = m.get('region_id')
        return self


class DrmOpsRecord(TeaModel):
    def __init__(
        self,
        apps: List[str] = None,
        operator: str = None,
        push_time: str = None,
        result_code: str = None,
        result_msg: str = None,
        targets: List[str] = None,
        value: str = None,
        rule_type: str = None,
    ):
        # 应用
        self.apps = apps
        # 操作人
        self.operator = operator
        # 推送时间
        self.push_time = push_time
        # 推送结果，包括（SUCCESS，FAILED，INVALID_REQUEST，NO_RECORD，SYSTEM_EXCEPTION，PARAM_QUERY_ERROR，PARAM_INVALID）
        self.result_code = result_code
        # 结果信息
        self.result_msg = result_msg
        # 推送目标
        self.targets = targets
        # 推送值
        self.value = value
        # 规则类型
        self.rule_type = rule_type

    def validate(self):
        self.validate_required(self.operator, 'operator')
        if self.push_time is not None:
            self.validate_pattern(self.push_time, 'push_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.result_code, 'result_code')
        self.validate_required(self.rule_type, 'rule_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apps is not None:
            result['apps'] = self.apps
        if self.operator is not None:
            result['operator'] = self.operator
        if self.push_time is not None:
            result['push_time'] = self.push_time
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.targets is not None:
            result['targets'] = self.targets
        if self.value is not None:
            result['value'] = self.value
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('apps') is not None:
            self.apps = m.get('apps')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('push_time') is not None:
            self.push_time = m.get('push_time')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('targets') is not None:
            self.targets = m.get('targets')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        return self


class ContainerServiceRevision(TeaModel):
    def __init__(
        self,
        app_info: AppInfo = None,
        container_service_config: ContainerServiceConfig = None,
        container_service_name: str = None,
        container_service_release_info: ContainerServiceReleaseInfo = None,
        created_time: str = None,
        deploy_status: str = None,
        description: str = None,
        last_plan_id: str = None,
        meta_status: str = None,
        modified_time: str = None,
        namespace: str = None,
        operator: str = None,
        remarks: str = None,
        revision: str = None,
    ):
        # 应用信息。
        self.app_info = app_info
        # 容器服务配置。
        self.container_service_config = container_service_config
        # 容器服务服务名称。
        self.container_service_name = container_service_name
        # 容器服务发布信息
        self.container_service_release_info = container_service_release_info
        # 创建时间。
        self.created_time = created_time
        # 发布状态。
        self.deploy_status = deploy_status
        # container service description
        self.description = description
        # 关联的最近一次发布单。
        self.last_plan_id = last_plan_id
        # 元数据状态。
        self.meta_status = meta_status
        # 更新时间。
        self.modified_time = modified_time
        # 所属命名空间名称。
        self.namespace = namespace
        # 版本提交人。
        self.operator = operator
        # 版本备注。
        self.remarks = remarks
        # 版本号。
        self.revision = revision

    def validate(self):
        self.validate_required(self.app_info, 'app_info')
        if self.app_info:
            self.app_info.validate()
        self.validate_required(self.container_service_config, 'container_service_config')
        if self.container_service_config:
            self.container_service_config.validate()
        self.validate_required(self.container_service_name, 'container_service_name')
        if self.container_service_release_info:
            self.container_service_release_info.validate()
        self.validate_required(self.created_time, 'created_time')
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.modified_time, 'modified_time')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.revision, 'revision')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_info is not None:
            result['app_info'] = self.app_info.to_map()
        if self.container_service_config is not None:
            result['container_service_config'] = self.container_service_config.to_map()
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.container_service_release_info is not None:
            result['container_service_release_info'] = self.container_service_release_info.to_map()
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.deploy_status is not None:
            result['deploy_status'] = self.deploy_status
        if self.description is not None:
            result['description'] = self.description
        if self.last_plan_id is not None:
            result['last_plan_id'] = self.last_plan_id
        if self.meta_status is not None:
            result['meta_status'] = self.meta_status
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operator is not None:
            result['operator'] = self.operator
        if self.remarks is not None:
            result['remarks'] = self.remarks
        if self.revision is not None:
            result['revision'] = self.revision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_info') is not None:
            temp_model = AppInfo()
            self.app_info = temp_model.from_map(m['app_info'])
        if m.get('container_service_config') is not None:
            temp_model = ContainerServiceConfig()
            self.container_service_config = temp_model.from_map(m['container_service_config'])
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('container_service_release_info') is not None:
            temp_model = ContainerServiceReleaseInfo()
            self.container_service_release_info = temp_model.from_map(m['container_service_release_info'])
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('deploy_status') is not None:
            self.deploy_status = m.get('deploy_status')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('last_plan_id') is not None:
            self.last_plan_id = m.get('last_plan_id')
        if m.get('meta_status') is not None:
            self.meta_status = m.get('meta_status')
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('remarks') is not None:
            self.remarks = m.get('remarks')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        return self


class AppServiceSidecarReleaseInfo(TeaModel):
    def __init__(
        self,
        app_name: str = None,
        container_service_name: str = None,
        release_infos: List[SidecarReleaseInfo] = None,
    ):
        # 服务所属app名称
        self.app_name = app_name
        # 应用服务名
        self.container_service_name = container_service_name
        # 应用服务所包含的sidecar配置信息，可以有mosn，odp等等不同sidecar类型的配置
        self.release_infos = release_infos

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.release_infos, 'release_infos')
        if self.release_infos:
            for k in self.release_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        result['release_infos'] = []
        if self.release_infos is not None:
            for k in self.release_infos:
                result['release_infos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        self.release_infos = []
        if m.get('release_infos') is not None:
            for k in m.get('release_infos'):
                temp_model = SidecarReleaseInfo()
                self.release_infos.append(temp_model.from_map(k))
        return self


class FedSecretOverrideList(TeaModel):
    def __init__(
        self,
        list: List[FedSecretOverride] = None,
    ):
        # fed configmap override list
        self.list = list

    def validate(self):
        self.validate_required(self.list, 'list')
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = FedSecretOverride()
                self.list.append(temp_model.from_map(k))
        return self


class FlowCellGroup(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        default_gzone: str = None,
        valid: bool = None,
        disaster_state: str = None,
    ):
        # 单元组名称
        self.name = name
        # 单元组类型，枚举，GZG、RZG
        self.type = type
        # 默认GZone，一般为 GZ00
        self.default_gzone = default_gzone
        # 单元组是否有效
        self.valid = valid
        # 单元组容灾状态，枚举，NORMAL（正常）、LOCAL（同城容灾）、REMOTE（异地容灾）
        self.disaster_state = disaster_state

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')
        self.validate_required(self.valid, 'valid')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.default_gzone is not None:
            result['default_gzone'] = self.default_gzone
        if self.valid is not None:
            result['valid'] = self.valid
        if self.disaster_state is not None:
            result['disaster_state'] = self.disaster_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('default_gzone') is not None:
            self.default_gzone = m.get('default_gzone')
        if m.get('valid') is not None:
            self.valid = m.get('valid')
        if m.get('disaster_state') is not None:
            self.disaster_state = m.get('disaster_state')
        return self


class FederatedDeployment(TeaModel):
    def __init__(
        self,
        metadata: ObjectMeta = None,
        overrides: List[FedDeploymentClusterOverride] = None,
        template: Deployment = None,
        status: FederatedDeploymentStatus = None,
    ):
        # Standard object metadata.
        # 
        self.metadata = metadata
        # Federated Deployment Override
        self.overrides = overrides
        # Federated Deployment Template
        self.template = template
        # 联邦无状态工作负载状态
        self.status = status

    def validate(self):
        self.validate_required(self.metadata, 'metadata')
        if self.metadata:
            self.metadata.validate()
        self.validate_required(self.overrides, 'overrides')
        if self.overrides:
            for k in self.overrides:
                if k:
                    k.validate()
        self.validate_required(self.template, 'template')
        if self.template:
            self.template.validate()
        self.validate_required(self.status, 'status')
        if self.status:
            self.status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        result['overrides'] = []
        if self.overrides is not None:
            for k in self.overrides:
                result['overrides'].append(k.to_map() if k else None)
        if self.template is not None:
            result['template'] = self.template.to_map()
        if self.status is not None:
            result['status'] = self.status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('metadata') is not None:
            temp_model = ObjectMeta()
            self.metadata = temp_model.from_map(m['metadata'])
        self.overrides = []
        if m.get('overrides') is not None:
            for k in m.get('overrides'):
                temp_model = FedDeploymentClusterOverride()
                self.overrides.append(temp_model.from_map(k))
        if m.get('template') is not None:
            temp_model = Deployment()
            self.template = temp_model.from_map(m['template'])
        if m.get('status') is not None:
            temp_model = FederatedDeploymentStatus()
            self.status = temp_model.from_map(m['status'])
        return self


class RegionInfo(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # region name
        self.name = name

    def validate(self):
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class RpReleaseEvent(TeaModel):
    def __init__(
        self,
        cluster: str = None,
        end_time: str = None,
        inv_obj_kind: str = None,
        inv_obj_name: str = None,
        inv_obj_namespace: str = None,
        inv_obj_version: str = None,
        message: str = None,
        reason: str = None,
        source_comp: str = None,
        start_time: str = None,
    ):
        # 集群名
        self.cluster = cluster
        # 结束时间
        self.end_time = end_time
        # 事件关联的对象类型
        # 
        self.inv_obj_kind = inv_obj_kind
        # 事件关联对象名字
        # 
        self.inv_obj_name = inv_obj_name
        # 事件关联对象的namespace
        # 
        self.inv_obj_namespace = inv_obj_namespace
        # 事件关联对象版本
        # 
        self.inv_obj_version = inv_obj_version
        # 事件详情
        # 
        self.message = message
        # 事件原因
        # 
        self.reason = reason
        # 事件来源组件
        # 
        self.source_comp = source_comp
        # start_time
        self.start_time = start_time

    def validate(self):
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.end_time, 'end_time')
        if self.end_time is not None:
            self.validate_pattern(self.end_time, 'end_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.inv_obj_kind, 'inv_obj_kind')
        self.validate_required(self.inv_obj_name, 'inv_obj_name')
        self.validate_required(self.inv_obj_namespace, 'inv_obj_namespace')
        self.validate_required(self.inv_obj_version, 'inv_obj_version')
        self.validate_required(self.message, 'message')
        self.validate_required(self.reason, 'reason')
        self.validate_required(self.source_comp, 'source_comp')
        self.validate_required(self.start_time, 'start_time')
        if self.start_time is not None:
            self.validate_pattern(self.start_time, 'start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.inv_obj_kind is not None:
            result['inv_obj_kind'] = self.inv_obj_kind
        if self.inv_obj_name is not None:
            result['inv_obj_name'] = self.inv_obj_name
        if self.inv_obj_namespace is not None:
            result['inv_obj_namespace'] = self.inv_obj_namespace
        if self.inv_obj_version is not None:
            result['inv_obj_version'] = self.inv_obj_version
        if self.message is not None:
            result['message'] = self.message
        if self.reason is not None:
            result['reason'] = self.reason
        if self.source_comp is not None:
            result['source_comp'] = self.source_comp
        if self.start_time is not None:
            result['start_time'] = self.start_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('inv_obj_kind') is not None:
            self.inv_obj_kind = m.get('inv_obj_kind')
        if m.get('inv_obj_name') is not None:
            self.inv_obj_name = m.get('inv_obj_name')
        if m.get('inv_obj_namespace') is not None:
            self.inv_obj_namespace = m.get('inv_obj_namespace')
        if m.get('inv_obj_version') is not None:
            self.inv_obj_version = m.get('inv_obj_version')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('source_comp') is not None:
            self.source_comp = m.get('source_comp')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        return self


class ContainerServiceOperationList(TeaModel):
    def __init__(
        self,
        list: List[ContainerServiceOperation] = None,
    ):
        # ContainerServiceOperationList
        self.list = list

    def validate(self):
        self.validate_required(self.list, 'list')
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = ContainerServiceOperation()
                self.list.append(temp_model.from_map(k))
        return self


class DeploymentTemplate(TeaModel):
    def __init__(
        self,
        name: str = None,
        display_name: str = None,
        description: str = None,
        override_deploy_config: bool = None,
        deploy_config: DeployConfig = None,
        enable_custom_hook: bool = None,
        hook_type: str = None,
        custom_hooks: List[CustomHook] = None,
        operator: str = None,
        created_time: str = None,
        modified_time: str = None,
        version: int = None,
    ):
        # 模板编码
        self.name = name
        # 中文名称
        self.display_name = display_name
        # 模板描述
        self.description = description
        # 是否覆盖版本中的发布策略
        self.override_deploy_config = override_deploy_config
        # 发布策略
        self.deploy_config = deploy_config
        # 是否开启变更卡点
        self.enable_custom_hook = enable_custom_hook
        # 卡点类型：api或has
        self.hook_type = hook_type
        # 自定义卡点配置列表
        # 
        self.custom_hooks = custom_hooks
        # 操作人
        self.operator = operator
        # 创建时间
        self.created_time = created_time
        # 更新时间
        self.modified_time = modified_time
        # 版本号
        self.version = version

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.override_deploy_config, 'override_deploy_config')
        if self.deploy_config:
            self.deploy_config.validate()
        self.validate_required(self.enable_custom_hook, 'enable_custom_hook')
        if self.custom_hooks:
            for k in self.custom_hooks:
                if k:
                    k.validate()
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.description is not None:
            result['description'] = self.description
        if self.override_deploy_config is not None:
            result['override_deploy_config'] = self.override_deploy_config
        if self.deploy_config is not None:
            result['deploy_config'] = self.deploy_config.to_map()
        if self.enable_custom_hook is not None:
            result['enable_custom_hook'] = self.enable_custom_hook
        if self.hook_type is not None:
            result['hook_type'] = self.hook_type
        result['custom_hooks'] = []
        if self.custom_hooks is not None:
            for k in self.custom_hooks:
                result['custom_hooks'].append(k.to_map() if k else None)
        if self.operator is not None:
            result['operator'] = self.operator
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('override_deploy_config') is not None:
            self.override_deploy_config = m.get('override_deploy_config')
        if m.get('deploy_config') is not None:
            temp_model = DeployConfig()
            self.deploy_config = temp_model.from_map(m['deploy_config'])
        if m.get('enable_custom_hook') is not None:
            self.enable_custom_hook = m.get('enable_custom_hook')
        if m.get('hook_type') is not None:
            self.hook_type = m.get('hook_type')
        self.custom_hooks = []
        if m.get('custom_hooks') is not None:
            for k in m.get('custom_hooks'):
                temp_model = CustomHook()
                self.custom_hooks.append(temp_model.from_map(k))
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class UidInfo(TeaModel):
    def __init__(
        self,
        uid: int = None,
        current_group: str = None,
        default_group: str = None,
        elastic: bool = None,
        press: bool = None,
        gray: bool = None,
        disaster_state: str = None,
    ):
        # UID
        self.uid = uid
        # 当前分组
        self.current_group = current_group
        # 默认分组
        self.default_group = default_group
        # 是否弹性
        self.elastic = elastic
        # 是否压测
        self.press = press
        # 是否灰度
        self.gray = gray
        # 单元分片容灾状态，枚举，NORMAL（正常）、LOCAL（同城容灾）、REMOTE（异地容灾）
        self.disaster_state = disaster_state

    def validate(self):
        self.validate_required(self.uid, 'uid')
        self.validate_required(self.current_group, 'current_group')
        self.validate_required(self.default_group, 'default_group')
        self.validate_required(self.disaster_state, 'disaster_state')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.uid is not None:
            result['uid'] = self.uid
        if self.current_group is not None:
            result['current_group'] = self.current_group
        if self.default_group is not None:
            result['default_group'] = self.default_group
        if self.elastic is not None:
            result['elastic'] = self.elastic
        if self.press is not None:
            result['press'] = self.press
        if self.gray is not None:
            result['gray'] = self.gray
        if self.disaster_state is not None:
            result['disaster_state'] = self.disaster_state
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        if m.get('current_group') is not None:
            self.current_group = m.get('current_group')
        if m.get('default_group') is not None:
            self.default_group = m.get('default_group')
        if m.get('elastic') is not None:
            self.elastic = m.get('elastic')
        if m.get('press') is not None:
            self.press = m.get('press')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        if m.get('disaster_state') is not None:
            self.disaster_state = m.get('disaster_state')
        return self


class GetSpannerClusterDetail(TeaModel):
    def __init__(
        self,
        cluster_detail: QuerySpannerClusterDetail = None,
        local_clusters: List[LocalSpannerClusterDetail] = None,
    ):
        # 联邦 spanner cluster 详细信息
        self.cluster_detail = cluster_detail
        # 若干组本地集群信息
        self.local_clusters = local_clusters

    def validate(self):
        self.validate_required(self.cluster_detail, 'cluster_detail')
        if self.cluster_detail:
            self.cluster_detail.validate()
        self.validate_required(self.local_clusters, 'local_clusters')
        if self.local_clusters:
            for k in self.local_clusters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_detail is not None:
            result['cluster_detail'] = self.cluster_detail.to_map()
        result['local_clusters'] = []
        if self.local_clusters is not None:
            for k in self.local_clusters:
                result['local_clusters'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster_detail') is not None:
            temp_model = QuerySpannerClusterDetail()
            self.cluster_detail = temp_model.from_map(m['cluster_detail'])
        self.local_clusters = []
        if m.get('local_clusters') is not None:
            for k in m.get('local_clusters'):
                temp_model = LocalSpannerClusterDetail()
                self.local_clusters.append(temp_model.from_map(k))
        return self


class CellWeightInfoList(TeaModel):
    def __init__(
        self,
        data: List[CellWeightInfo] = None,
    ):
        # weight info list.
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = CellWeightInfo()
                self.data.append(temp_model.from_map(k))
        return self


class FedSecret(TeaModel):
    def __init__(
        self,
        annotations: List[Annotation] = None,
        cell_status: List[ClusteCellStatus] = None,
        clusters: List[str] = None,
        create_time_stamp: str = None,
        data: List[SecretData] = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
        overrides: List[FedSecretOverride] = None,
        reason: str = None,
        status: str = None,
        type: str = None,
    ):
        # 保密字典的注解
        # 
        self.annotations = annotations
        # 分发状态
        self.cell_status = cell_status
        # 分发的 cell 列表
        self.clusters = clusters
        # 创建时间
        self.create_time_stamp = create_time_stamp
        # 保密字典数据
        self.data = data
        # 保密字典的标签
        self.labels = labels
        # 名称
        self.name = name
        # 命名空间
        # 
        self.namespace = namespace
        # 保密字典数据在不同 cell 下的自定义覆盖配置
        self.overrides = overrides
        # 导致该分发状态的原因
        self.reason = reason
        # 分发状态，成功 True，失败 False，删除中 Deleting
        self.status = status
        # 保密字典类型
        self.type = type

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        self.validate_required(self.cell_status, 'cell_status')
        if self.cell_status:
            for k in self.cell_status:
                if k:
                    k.validate()
        self.validate_required(self.clusters, 'clusters')
        self.validate_required(self.create_time_stamp, 'create_time_stamp')
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.overrides, 'overrides')
        if self.overrides:
            for k in self.overrides:
                if k:
                    k.validate()
        self.validate_required(self.status, 'status')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        result['cell_status'] = []
        if self.cell_status is not None:
            for k in self.cell_status:
                result['cell_status'].append(k.to_map() if k else None)
        if self.clusters is not None:
            result['clusters'] = self.clusters
        if self.create_time_stamp is not None:
            result['create_time_stamp'] = self.create_time_stamp
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        result['overrides'] = []
        if self.overrides is not None:
            for k in self.overrides:
                result['overrides'].append(k.to_map() if k else None)
        if self.reason is not None:
            result['reason'] = self.reason
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = Annotation()
                self.annotations.append(temp_model.from_map(k))
        self.cell_status = []
        if m.get('cell_status') is not None:
            for k in m.get('cell_status'):
                temp_model = ClusteCellStatus()
                self.cell_status.append(temp_model.from_map(k))
        if m.get('clusters') is not None:
            self.clusters = m.get('clusters')
        if m.get('create_time_stamp') is not None:
            self.create_time_stamp = m.get('create_time_stamp')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = SecretData()
                self.data.append(temp_model.from_map(k))
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        self.overrides = []
        if m.get('overrides') is not None:
            for k in m.get('overrides'):
                temp_model = FedSecretOverride()
                self.overrides.append(temp_model.from_map(k))
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class OpsPrePostTask(TeaModel):
    def __init__(
        self,
        type: str = None,
        operation_type: str = None,
        detail: str = None,
        status: str = None,
    ):
        # 
        # 任务类型。
        # 中间件任务：
        # MESSAGE_BROKER_TOPIC：消息中间件TOPIC；
        # MESSAGE_BROKER_TOPIC_SUB：消息中间件绑定关系；
        # DRM_RESOURCE：DRM资源；
        # SCHEDULER_TASK：定时任务；
        # 其他类型任务待定。
        # 
        self.type = type
        # 
        # 操作类型。取值列表：
        # CREATE：新建；
        # UPDATE：更新；
        # DELETE：删除；
        # UNDEFINED：未定义；
        # 
        self.operation_type = operation_type
        # 
        # 任务详情，JSON字符串
        # 
        self.detail = detail
        # 
        # 任务状态。取值列表：EXECUTING：执行中；SUCCEEDED：执行成功；FAILED：执行失败；IGNORED：已忽略
        # 
        self.status = status

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.operation_type is not None:
            result['operation_type'] = self.operation_type
        if self.detail is not None:
            result['detail'] = self.detail
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('operation_type') is not None:
            self.operation_type = m.get('operation_type')
        if m.get('detail') is not None:
            self.detail = m.get('detail')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class LdcPlanStateCount(TeaModel):
    def __init__(
        self,
        state: str = None,
        count: int = None,
    ):
        # 发布单状态类型
        self.state = state
        # 数量
        self.count = count

    def validate(self):
        self.validate_required(self.state, 'state')
        self.validate_required(self.count, 'count')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.state is not None:
            result['state'] = self.state
        if self.count is not None:
            result['count'] = self.count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('count') is not None:
            self.count = m.get('count')
        return self


class UnireleaseSolution(TeaModel):
    def __init__(
        self,
        id: str = None,
        title: str = None,
        source_system: str = None,
        type: str = None,
        submitter: str = None,
        state: str = None,
        create_time_stamp: str = None,
        auto_execute: bool = None,
        env: str = None,
        operator: str = None,
        ext_info: UnireleaseSolutionExtInfo = None,
        apps: List[UnireleaseSolutionApp] = None,
        tenants: List[str] = None,
        message: str = None,
        ac_id: str = None,
        emergent: bool = None,
    ):
        # 发布单ID
        self.id = id
        # 发布单标题
        self.title = title
        # 解决方案平台源
        self.source_system = source_system
        # 发布类型，容器/经典
        self.type = type
        # 需求人/操作者
        self.submitter = submitter
        # 解决方案状态
        self.state = state
        # 解决方案提出时间
        self.create_time_stamp = create_time_stamp
        # 是否自动执行
        self.auto_execute = auto_execute
        # 环境信息
        self.env = env
        # 变更人员
        self.operator = operator
        # 解决方案拓展信息
        self.ext_info = ext_info
        # 解决方案包含的应用配置信息
        self.apps = apps
        # 租户列表
        self.tenants = tenants
        # 错误信息
        self.message = message
        # AC ID
        self.ac_id = ac_id
        # 是否是紧急发布
        self.emergent = emergent

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.title, 'title')
        self.validate_required(self.source_system, 'source_system')
        self.validate_required(self.type, 'type')
        self.validate_required(self.submitter, 'submitter')
        self.validate_required(self.state, 'state')
        self.validate_required(self.create_time_stamp, 'create_time_stamp')
        if self.create_time_stamp is not None:
            self.validate_pattern(self.create_time_stamp, 'create_time_stamp', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.auto_execute, 'auto_execute')
        self.validate_required(self.env, 'env')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.ext_info, 'ext_info')
        if self.ext_info:
            self.ext_info.validate()
        self.validate_required(self.apps, 'apps')
        if self.apps:
            for k in self.apps:
                if k:
                    k.validate()
        self.validate_required(self.tenants, 'tenants')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.title is not None:
            result['title'] = self.title
        if self.source_system is not None:
            result['source_system'] = self.source_system
        if self.type is not None:
            result['type'] = self.type
        if self.submitter is not None:
            result['submitter'] = self.submitter
        if self.state is not None:
            result['state'] = self.state
        if self.create_time_stamp is not None:
            result['create_time_stamp'] = self.create_time_stamp
        if self.auto_execute is not None:
            result['auto_execute'] = self.auto_execute
        if self.env is not None:
            result['env'] = self.env
        if self.operator is not None:
            result['operator'] = self.operator
        if self.ext_info is not None:
            result['ext_info'] = self.ext_info.to_map()
        result['apps'] = []
        if self.apps is not None:
            for k in self.apps:
                result['apps'].append(k.to_map() if k else None)
        if self.tenants is not None:
            result['tenants'] = self.tenants
        if self.message is not None:
            result['message'] = self.message
        if self.ac_id is not None:
            result['ac_id'] = self.ac_id
        if self.emergent is not None:
            result['emergent'] = self.emergent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('source_system') is not None:
            self.source_system = m.get('source_system')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('submitter') is not None:
            self.submitter = m.get('submitter')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('create_time_stamp') is not None:
            self.create_time_stamp = m.get('create_time_stamp')
        if m.get('auto_execute') is not None:
            self.auto_execute = m.get('auto_execute')
        if m.get('env') is not None:
            self.env = m.get('env')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('ext_info') is not None:
            temp_model = UnireleaseSolutionExtInfo()
            self.ext_info = temp_model.from_map(m['ext_info'])
        self.apps = []
        if m.get('apps') is not None:
            for k in m.get('apps'):
                temp_model = UnireleaseSolutionApp()
                self.apps.append(temp_model.from_map(k))
        if m.get('tenants') is not None:
            self.tenants = m.get('tenants')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('ac_id') is not None:
            self.ac_id = m.get('ac_id')
        if m.get('emergent') is not None:
            self.emergent = m.get('emergent')
        return self


class MasterClustersOfZone(TeaModel):
    def __init__(
        self,
        clusters: List[MasterCluster] = None,
        zone_name: str = None,
        has_imported: bool = None,
    ):
        # master clusters of specific zone
        self.clusters = clusters
        # zone name
        self.zone_name = zone_name
        # if the az has imported cluster
        self.has_imported = has_imported

    def validate(self):
        self.validate_required(self.clusters, 'clusters')
        if self.clusters:
            for k in self.clusters:
                if k:
                    k.validate()
        self.validate_required(self.zone_name, 'zone_name')
        self.validate_required(self.has_imported, 'has_imported')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['clusters'] = []
        if self.clusters is not None:
            for k in self.clusters:
                result['clusters'].append(k.to_map() if k else None)
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        if self.has_imported is not None:
            result['has_imported'] = self.has_imported
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.clusters = []
        if m.get('clusters') is not None:
            for k in m.get('clusters'):
                temp_model = MasterCluster()
                self.clusters.append(temp_model.from_map(k))
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        if m.get('has_imported') is not None:
            self.has_imported = m.get('has_imported')
        return self


class PopOutUid(TeaModel):
    def __init__(
        self,
        value: int = None,
        cell: str = None,
    ):
        # 弹出的 UID 值
        self.value = value
        # 弹出的目标部署单元
        self.cell = cell

    def validate(self):
        self.validate_required(self.value, 'value')
        self.validate_required(self.cell, 'cell')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['value'] = self.value
        if self.cell is not None:
            result['cell'] = self.cell
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        return self


class SontainerServicesList(TeaModel):
    def __init__(
        self,
        list: List[ContainerServiceDeployment] = None,
    ):
        # ContainerServiceDeployment
        self.list = list

    def validate(self):
        self.validate_required(self.list, 'list')
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = ContainerServiceDeployment()
                self.list.append(temp_model.from_map(k))
        return self


class FederatedService(TeaModel):
    def __init__(
        self,
        metadata: ObjectMeta = None,
        status: FederatedServiceStatus = None,
    ):
        # metadata
        self.metadata = metadata
        # status
        self.status = status

    def validate(self):
        if self.metadata:
            self.metadata.validate()
        if self.status:
            self.status.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metadata is not None:
            result['metadata'] = self.metadata.to_map()
        if self.status is not None:
            result['status'] = self.status.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('metadata') is not None:
            temp_model = ObjectMeta()
            self.metadata = temp_model.from_map(m['metadata'])
        if m.get('status') is not None:
            temp_model = FederatedServiceStatus()
            self.status = temp_model.from_map(m['status'])
        return self


class FedLoadBalancer(TeaModel):
    def __init__(
        self,
        name: str = None,
        addr_type: str = None,
        state: str = None,
        create_time: str = None,
        container_services_info: List[FedLoadBalancerContainerServiceRel] = None,
        local_loadbalancer_instances: List[LocalLoadBalancer] = None,
    ):
        # 联邦负载均衡实例名称
        self.name = name
        # 地址类型，比如公网、内网
        self.addr_type = addr_type
        # 联邦负载均衡实例的状态，由多个local 负载均衡实例的状态汇聚计算而来
        self.state = state
        # 创建时间
        self.create_time = create_time
        # 关联的应用服务情况
        self.container_services_info = container_services_info
        # local lb实例信息
        self.local_loadbalancer_instances = local_loadbalancer_instances

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.addr_type, 'addr_type')
        self.validate_required(self.create_time, 'create_time')
        if self.create_time is not None:
            self.validate_pattern(self.create_time, 'create_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.container_services_info:
            for k in self.container_services_info:
                if k:
                    k.validate()
        if self.local_loadbalancer_instances:
            for k in self.local_loadbalancer_instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.addr_type is not None:
            result['addr_type'] = self.addr_type
        if self.state is not None:
            result['state'] = self.state
        if self.create_time is not None:
            result['create_time'] = self.create_time
        result['container_services_info'] = []
        if self.container_services_info is not None:
            for k in self.container_services_info:
                result['container_services_info'].append(k.to_map() if k else None)
        result['local_loadbalancer_instances'] = []
        if self.local_loadbalancer_instances is not None:
            for k in self.local_loadbalancer_instances:
                result['local_loadbalancer_instances'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('addr_type') is not None:
            self.addr_type = m.get('addr_type')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('create_time') is not None:
            self.create_time = m.get('create_time')
        self.container_services_info = []
        if m.get('container_services_info') is not None:
            for k in m.get('container_services_info'):
                temp_model = FedLoadBalancerContainerServiceRel()
                self.container_services_info.append(temp_model.from_map(k))
        self.local_loadbalancer_instances = []
        if m.get('local_loadbalancer_instances') is not None:
            for k in m.get('local_loadbalancer_instances'):
                temp_model = LocalLoadBalancer()
                self.local_loadbalancer_instances.append(temp_model.from_map(k))
        return self


class SideCar(TeaModel):
    def __init__(
        self,
        region_id: str = None,
        description: str = None,
        scope: str = None,
        sidecar_name: str = None,
        workspace_group_id: str = None,
        workspace_id: str = None,
    ):
        # region id
        self.region_id = region_id
        # sidecar description
        self.description = description
        # sidecar生效范围：workspace、workspace_group、region
        self.scope = scope
        # sidecar_name
        self.sidecar_name = sidecar_name
        # workspace_group_id
        self.workspace_group_id = workspace_group_id
        # workspace_id
        self.workspace_id = workspace_id

    def validate(self):
        self.validate_required(self.description, 'description')
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.sidecar_name, 'sidecar_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['region_id'] = self.region_id
        if self.description is not None:
            result['description'] = self.description
        if self.scope is not None:
            result['scope'] = self.scope
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('region_id') is not None:
            self.region_id = m.get('region_id')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        return self


class CellGroup(TeaModel):
    def __init__(
        self,
        cells: List[Cell] = None,
        datacenter: str = None,
        default_gzone: str = None,
        disaster_info: List[DisasterInfo] = None,
        modified_time: str = None,
        name: str = None,
        operator: str = None,
        type: str = None,
        region: str = None,
    ):
        # 包含部署单元列表。
        self.cells = cells
        # 机房名称。
        self.datacenter = datacenter
        # 默认全局域
        self.default_gzone = default_gzone
        # 逻辑单元灾备信息
        self.disaster_info = disaster_info
        # 修改时间
        self.modified_time = modified_time
        # 逻辑单元名称
        self.name = name
        # 操作人
        self.operator = operator
        # 逻辑单元类型
        self.type = type
        # 所属地域：CZone Group 必填
        self.region = region

    def validate(self):
        self.validate_required(self.cells, 'cells')
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()
        self.validate_required(self.disaster_info, 'disaster_info')
        if self.disaster_info:
            for k in self.disaster_info:
                if k:
                    k.validate()
        self.validate_required(self.modified_time, 'modified_time')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.name, 'name')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        if self.datacenter is not None:
            result['datacenter'] = self.datacenter
        if self.default_gzone is not None:
            result['default_gzone'] = self.default_gzone
        result['disaster_info'] = []
        if self.disaster_info is not None:
            for k in self.disaster_info:
                result['disaster_info'].append(k.to_map() if k else None)
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.type is not None:
            result['type'] = self.type
        if self.region is not None:
            result['region'] = self.region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = Cell()
                self.cells.append(temp_model.from_map(k))
        if m.get('datacenter') is not None:
            self.datacenter = m.get('datacenter')
        if m.get('default_gzone') is not None:
            self.default_gzone = m.get('default_gzone')
        self.disaster_info = []
        if m.get('disaster_info') is not None:
            for k in m.get('disaster_info'):
                temp_model = DisasterInfo()
                self.disaster_info.append(temp_model.from_map(k))
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('region') is not None:
            self.region = m.get('region')
        return self


class NativeTechStackVersion(TeaModel):
    def __init__(
        self,
        description: str = None,
        extend_commands: List[str] = None,
        extend_properties: str = None,
        from_image: str = None,
        id: str = None,
        scope: str = None,
        tech_stack: str = None,
        tech_stack_id: str = None,
        version: str = None,
        utc_created: str = None,
        utc_modified: str = None,
    ):
        # 版本描述
        self.description = description
        # 用户扩展的自定义Dockerfile指令
        self.extend_commands = extend_commands
        # 版本扩展信息，e.g 公共环境变量
        self.extend_properties = extend_properties
        # 基础镜像存放地址
        self.from_image = from_image
        # 唯一标识ID
        self.id = id
        # 可见范围：全局可见|租户内可见
        self.scope = scope
        # 所属技术栈
        self.tech_stack = tech_stack
        # 所属技术栈标识id
        self.tech_stack_id = tech_stack_id
        # 技术栈版本
        self.version = version
        # 创建时间（UTC）
        self.utc_created = utc_created
        # 最近修改时间（UTC）
        self.utc_modified = utc_modified

    def validate(self):
        self.validate_required(self.description, 'description')
        self.validate_required(self.extend_commands, 'extend_commands')
        self.validate_required(self.extend_properties, 'extend_properties')
        self.validate_required(self.from_image, 'from_image')
        self.validate_required(self.id, 'id')
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.tech_stack, 'tech_stack')
        self.validate_required(self.tech_stack_id, 'tech_stack_id')
        self.validate_required(self.version, 'version')
        self.validate_required(self.utc_created, 'utc_created')
        if self.utc_created is not None:
            self.validate_pattern(self.utc_created, 'utc_created', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.utc_modified, 'utc_modified')
        if self.utc_modified is not None:
            self.validate_pattern(self.utc_modified, 'utc_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.extend_commands is not None:
            result['extend_commands'] = self.extend_commands
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        if self.from_image is not None:
            result['from_image'] = self.from_image
        if self.id is not None:
            result['id'] = self.id
        if self.scope is not None:
            result['scope'] = self.scope
        if self.tech_stack is not None:
            result['tech_stack'] = self.tech_stack
        if self.tech_stack_id is not None:
            result['tech_stack_id'] = self.tech_stack_id
        if self.version is not None:
            result['version'] = self.version
        if self.utc_created is not None:
            result['utc_created'] = self.utc_created
        if self.utc_modified is not None:
            result['utc_modified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('extend_commands') is not None:
            self.extend_commands = m.get('extend_commands')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        if m.get('from_image') is not None:
            self.from_image = m.get('from_image')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('tech_stack') is not None:
            self.tech_stack = m.get('tech_stack')
        if m.get('tech_stack_id') is not None:
            self.tech_stack_id = m.get('tech_stack_id')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('utc_created') is not None:
            self.utc_created = m.get('utc_created')
        if m.get('utc_modified') is not None:
            self.utc_modified = m.get('utc_modified')
        return self


class CloudConfigEntity(TeaModel):
    def __init__(
        self,
        cloud_config: str = None,
        gmt_create: str = None,
        operation: str = None,
        operator: str = None,
    ):
        # 配置详情
        self.cloud_config = cloud_config
        # 操作时间
        self.gmt_create = gmt_create
        # 操作类型
        self.operation = operation
        # admin
        self.operator = operator

    def validate(self):
        self.validate_required(self.cloud_config, 'cloud_config')
        self.validate_required(self.gmt_create, 'gmt_create')
        self.validate_required(self.operation, 'operation')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cloud_config is not None:
            result['cloud_config'] = self.cloud_config
        if self.gmt_create is not None:
            result['gmt_create'] = self.gmt_create
        if self.operation is not None:
            result['operation'] = self.operation
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cloud_config') is not None:
            self.cloud_config = m.get('cloud_config')
        if m.get('gmt_create') is not None:
            self.gmt_create = m.get('gmt_create')
        if m.get('operation') is not None:
            self.operation = m.get('operation')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class Application(TeaModel):
    def __init__(
        self,
        custom_params: List[OpsParam] = None,
        depends: List[str] = None,
        name: str = None,
        services: List[AppService] = None,
        version: str = None,
    ):
        # 应用部署时指定的自定义参数
        self.custom_params = custom_params
        # 应用部署时依赖的应用名称，只允许取此次调用参数中列出的应用。不允许形成循环依赖。
        self.depends = depends
        # 应用名称
        self.name = name
        # 指定应用下的应用服务实例
        self.services = services
        # 应用包版本
        self.version = version

    def validate(self):
        if self.custom_params:
            for k in self.custom_params:
                if k:
                    k.validate()
        if self.services:
            for k in self.services:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['custom_params'] = []
        if self.custom_params is not None:
            for k in self.custom_params:
                result['custom_params'].append(k.to_map() if k else None)
        if self.depends is not None:
            result['depends'] = self.depends
        if self.name is not None:
            result['name'] = self.name
        result['services'] = []
        if self.services is not None:
            for k in self.services:
                result['services'].append(k.to_map() if k else None)
        if self.version is not None:
            result['version'] = self.version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.custom_params = []
        if m.get('custom_params') is not None:
            for k in m.get('custom_params'):
                temp_model = OpsParam()
                self.custom_params.append(temp_model.from_map(k))
        if m.get('depends') is not None:
            self.depends = m.get('depends')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.services = []
        if m.get('services') is not None:
            for k in m.get('services'):
                temp_model = AppService()
                self.services.append(temp_model.from_map(k))
        if m.get('version') is not None:
            self.version = m.get('version')
        return self


class KubeEvent(TeaModel):
    def __init__(
        self,
        type: str = None,
        count: int = None,
        reason: str = None,
        message: str = None,
        modified_time: str = None,
    ):
        # 事件类型
        self.type = type
        # 发布次数
        self.count = count
        # 事件原因
        self.reason = reason
        # 事件内容
        self.message = message
        # 更新时间
        self.modified_time = modified_time

    def validate(self):
        self.validate_required(self.type, 'type')
        self.validate_required(self.count, 'count')
        self.validate_required(self.reason, 'reason')
        self.validate_required(self.message, 'message')
        self.validate_required(self.modified_time, 'modified_time')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.count is not None:
            result['count'] = self.count
        if self.reason is not None:
            result['reason'] = self.reason
        if self.message is not None:
            result['message'] = self.message
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        return self


class NodeInfo(TeaModel):
    def __init__(
        self,
        cell_name: str = None,
        ip: str = None,
        is_schedulable: bool = None,
        limited_cpu: int = None,
        limited_memory: int = None,
        name: str = None,
        pod_number: str = None,
        state: str = None,
        used_cpu: int = None,
        used_memory: int = None,
        zone_name: str = None,
        labels: List[Label] = None,
        annotations: List[Annotation] = None,
        created_time: str = None,
        system_infos: List[Annotation] = None,
        max_pod_amount: int = None,
        running_pod_amount: int = None,
    ):
        # cell name
        self.cell_name = cell_name
        # node ip
        self.ip = ip
        # true
        self.is_schedulable = is_schedulable
        # number of capacity cpu core
        self.limited_cpu = limited_cpu
        # quantity of capacity memory
        self.limited_memory = limited_memory
        # node name
        self.name = name
        # pod number of one node
        self.pod_number = pod_number
        # node state
        self.state = state
        # quantity of used cpu core
        self.used_cpu = used_cpu
        # quantity of used memory
        self.used_memory = used_memory
        # zone name
        self.zone_name = zone_name
        # node labels
        self.labels = labels
        # node annotations
        self.annotations = annotations
        # node created time
        self.created_time = created_time
        # node system infos
        self.system_infos = system_infos
        # max pod amount of node
        self.max_pod_amount = max_pod_amount
        # running pod amount of node
        self.running_pod_amount = running_pod_amount

    def validate(self):
        self.validate_required(self.name, 'name')
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.system_infos:
            for k in self.system_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.ip is not None:
            result['ip'] = self.ip
        if self.is_schedulable is not None:
            result['is_schedulable'] = self.is_schedulable
        if self.limited_cpu is not None:
            result['limited_cpu'] = self.limited_cpu
        if self.limited_memory is not None:
            result['limited_memory'] = self.limited_memory
        if self.name is not None:
            result['name'] = self.name
        if self.pod_number is not None:
            result['pod_number'] = self.pod_number
        if self.state is not None:
            result['state'] = self.state
        if self.used_cpu is not None:
            result['used_cpu'] = self.used_cpu
        if self.used_memory is not None:
            result['used_memory'] = self.used_memory
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.created_time is not None:
            result['created_time'] = self.created_time
        result['system_infos'] = []
        if self.system_infos is not None:
            for k in self.system_infos:
                result['system_infos'].append(k.to_map() if k else None)
        if self.max_pod_amount is not None:
            result['max_pod_amount'] = self.max_pod_amount
        if self.running_pod_amount is not None:
            result['running_pod_amount'] = self.running_pod_amount
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('ip') is not None:
            self.ip = m.get('ip')
        if m.get('is_schedulable') is not None:
            self.is_schedulable = m.get('is_schedulable')
        if m.get('limited_cpu') is not None:
            self.limited_cpu = m.get('limited_cpu')
        if m.get('limited_memory') is not None:
            self.limited_memory = m.get('limited_memory')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('pod_number') is not None:
            self.pod_number = m.get('pod_number')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('used_cpu') is not None:
            self.used_cpu = m.get('used_cpu')
        if m.get('used_memory') is not None:
            self.used_memory = m.get('used_memory')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = Annotation()
                self.annotations.append(temp_model.from_map(k))
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        self.system_infos = []
        if m.get('system_infos') is not None:
            for k in m.get('system_infos'):
                temp_model = Annotation()
                self.system_infos.append(temp_model.from_map(k))
        if m.get('max_pod_amount') is not None:
            self.max_pod_amount = m.get('max_pod_amount')
        if m.get('running_pod_amount') is not None:
            self.running_pod_amount = m.get('running_pod_amount')
        return self


class SecuredGroupInfo(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # secured group name
        self.name = name

    def validate(self):
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class TenantAppReleasePipeline(TeaModel):
    def __init__(
        self,
        tenant: str = None,
        workspace_group: str = None,
        release_id: str = None,
        release_time_series_id: str = None,
        state: str = None,
        url: str = None,
        apps: List[str] = None,
        operator: str = None,
        approve_plan_id: str = None,
        approve_plan_url: str = None,
    ):
        # 机构名称
        self.tenant = tenant
        # 环境
        self.workspace_group = workspace_group
        # 应用发布releaseId
        self.release_id = release_id
        # 发布单序列号
        self.release_time_series_id = release_time_series_id
        # 应用发布状态
        self.state = state
        # 应用发布单详情url
        self.url = url
        # 应用列表
        self.apps = apps
        # 操作人员
        self.operator = operator
        # 发布单ID
        self.approve_plan_id = approve_plan_id
        # 发布审批单Url
        self.approve_plan_url = approve_plan_url

    def validate(self):
        self.validate_required(self.tenant, 'tenant')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.release_id, 'release_id')
        self.validate_required(self.release_time_series_id, 'release_time_series_id')
        self.validate_required(self.state, 'state')
        self.validate_required(self.apps, 'apps')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tenant is not None:
            result['tenant'] = self.tenant
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.release_id is not None:
            result['release_id'] = self.release_id
        if self.release_time_series_id is not None:
            result['release_time_series_id'] = self.release_time_series_id
        if self.state is not None:
            result['state'] = self.state
        if self.url is not None:
            result['url'] = self.url
        if self.apps is not None:
            result['apps'] = self.apps
        if self.operator is not None:
            result['operator'] = self.operator
        if self.approve_plan_id is not None:
            result['approve_plan_id'] = self.approve_plan_id
        if self.approve_plan_url is not None:
            result['approve_plan_url'] = self.approve_plan_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('tenant') is not None:
            self.tenant = m.get('tenant')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('release_id') is not None:
            self.release_id = m.get('release_id')
        if m.get('release_time_series_id') is not None:
            self.release_time_series_id = m.get('release_time_series_id')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('apps') is not None:
            self.apps = m.get('apps')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('approve_plan_id') is not None:
            self.approve_plan_id = m.get('approve_plan_id')
        if m.get('approve_plan_url') is not None:
            self.approve_plan_url = m.get('approve_plan_url')
        return self


class MasterClusterForWorkspaces(TeaModel):
    def __init__(
        self,
        workspace_id: List[str] = None,
        master_cluster_info: MasterCluster = None,
    ):
        # workspace id
        self.workspace_id = workspace_id
        # master cluster info to init minion cluster
        self.master_cluster_info = master_cluster_info

    def validate(self):
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.master_cluster_info, 'master_cluster_info')
        if self.master_cluster_info:
            self.master_cluster_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.master_cluster_info is not None:
            result['master_cluster_info'] = self.master_cluster_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('master_cluster_info') is not None:
            temp_model = MasterCluster()
            self.master_cluster_info = temp_model.from_map(m['master_cluster_info'])
        return self


class NamespaceDetail(TeaModel):
    def __init__(
        self,
        name: str = None,
        labels: List[Label] = None,
        status: str = None,
        created_time: str = None,
    ):
        # name
        self.name = name
        # labels
        self.labels = labels
        # status
        self.status = status
        # created time
        self.created_time = created_time

    def validate(self):
        self.validate_required(self.name, 'name')
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.created_time, 'created_time')
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.created_time is not None:
            result['created_time'] = self.created_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        return self


class ClusterEvents(TeaModel):
    def __init__(
        self,
        cluster: str = None,
        events: List[KubernetesEvents] = None,
    ):
        # 集群名称
        self.cluster = cluster
        # 集群事件
        self.events = events

    def validate(self):
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.events, 'events')
        if self.events:
            for k in self.events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster is not None:
            result['cluster'] = self.cluster
        result['events'] = []
        if self.events is not None:
            for k in self.events:
                result['events'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        self.events = []
        if m.get('events') is not None:
            for k in m.get('events'):
                temp_model = KubernetesEvents()
                self.events.append(temp_model.from_map(k))
        return self


class NativeServiceView(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        load_balancer_id: str = None,
        vip_addresses: List[str] = None,
        vip_address_type: str = None,
        cluster_ip: str = None,
        created_timestamp: str = None,
        modified_timestamp: str = None,
    ):
        # 服务名称。
        self.name = name
        # 服务类型。
        self.type = type
        # 负载均衡实例id。
        self.load_balancer_id = load_balancer_id
        # VIP地址信息。
        self.vip_addresses = vip_addresses
        # VIP地址信息类型。
        self.vip_address_type = vip_address_type
        # ClusterIP信息。
        self.cluster_ip = cluster_ip
        # 创建时间。
        self.created_timestamp = created_timestamp
        # 修改时间。
        self.modified_timestamp = modified_timestamp

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')
        self.validate_required(self.created_timestamp, 'created_timestamp')
        if self.created_timestamp is not None:
            self.validate_pattern(self.created_timestamp, 'created_timestamp', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.modified_timestamp, 'modified_timestamp')
        if self.modified_timestamp is not None:
            self.validate_pattern(self.modified_timestamp, 'modified_timestamp', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.load_balancer_id is not None:
            result['load_balancer_id'] = self.load_balancer_id
        if self.vip_addresses is not None:
            result['vip_addresses'] = self.vip_addresses
        if self.vip_address_type is not None:
            result['vip_address_type'] = self.vip_address_type
        if self.cluster_ip is not None:
            result['cluster_ip'] = self.cluster_ip
        if self.created_timestamp is not None:
            result['created_timestamp'] = self.created_timestamp
        if self.modified_timestamp is not None:
            result['modified_timestamp'] = self.modified_timestamp
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('load_balancer_id') is not None:
            self.load_balancer_id = m.get('load_balancer_id')
        if m.get('vip_addresses') is not None:
            self.vip_addresses = m.get('vip_addresses')
        if m.get('vip_address_type') is not None:
            self.vip_address_type = m.get('vip_address_type')
        if m.get('cluster_ip') is not None:
            self.cluster_ip = m.get('cluster_ip')
        if m.get('created_timestamp') is not None:
            self.created_timestamp = m.get('created_timestamp')
        if m.get('modified_timestamp') is not None:
            self.modified_timestamp = m.get('modified_timestamp')
        return self


class ServiceWeight(TeaModel):
    def __init__(
        self,
        ingress_name: str = None,
        blue: int = None,
        green: int = None,
        status: str = None,
        message: str = None,
    ):
        # 统一接入名称
        self.ingress_name = ingress_name
        # 蓝区流量权重，取值0-100
        self.blue = blue
        # 绿区流量权重，取值0-100
        self.green = green
        # 状态：succeed、updating、fail
        self.status = status
        # 错误信息
        self.message = message

    def validate(self):
        self.validate_required(self.ingress_name, 'ingress_name')
        self.validate_required(self.blue, 'blue')
        self.validate_required(self.green, 'green')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ingress_name is not None:
            result['ingress_name'] = self.ingress_name
        if self.blue is not None:
            result['blue'] = self.blue
        if self.green is not None:
            result['green'] = self.green
        if self.status is not None:
            result['status'] = self.status
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ingress_name') is not None:
            self.ingress_name = m.get('ingress_name')
        if m.get('blue') is not None:
            self.blue = m.get('blue')
        if m.get('green') is not None:
            self.green = m.get('green')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class HealthCheckConfigInfo(TeaModel):
    def __init__(
        self,
        liveness_probe: LivenessProbe = None,
        readiness_probe: ReadinessProbe = None,
    ):
        # 容器健康检查配置liveness probe。
        self.liveness_probe = liveness_probe
        # 容器健康检查配置readiness probe。
        self.readiness_probe = readiness_probe

    def validate(self):
        if self.liveness_probe:
            self.liveness_probe.validate()
        if self.readiness_probe:
            self.readiness_probe.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.liveness_probe is not None:
            result['liveness_probe'] = self.liveness_probe.to_map()
        if self.readiness_probe is not None:
            result['readiness_probe'] = self.readiness_probe.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('liveness_probe') is not None:
            temp_model = LivenessProbe()
            self.liveness_probe = temp_model.from_map(m['liveness_probe'])
        if m.get('readiness_probe') is not None:
            temp_model = ReadinessProbe()
            self.readiness_probe = temp_model.from_map(m['readiness_probe'])
        return self


class OperationLog(TeaModel):
    def __init__(
        self,
        workspace_group_id: str = None,
        entity: str = None,
        action: str = None,
        target_id: str = None,
        operator_id: str = None,
        operator_name: str = None,
        source_system: str = None,
        context: str = None,
        cluster_id: str = None,
        pod_name: str = None,
        content: str = None,
        create_time: str = None,
    ):
        # 工作空间组id
        self.workspace_group_id = workspace_group_id
        # LDC_PLAN或者LDC_SERVICE
        self.entity = entity
        # 操作。
        self.action = action
        # 发布单plan_id或者lks_service_id
        self.target_id = target_id
        # operatorId
        self.operator_id = operator_id
        # operatorName
        self.operator_name = operator_name
        # sourceSystem
        self.source_system = source_system
        # context
        self.context = context
        # 集群id
        self.cluster_id = cluster_id
        # pod名称
        self.pod_name = pod_name
        # 操作内容
        self.content = content
        # 创建时间
        self.create_time = create_time

    def validate(self):
        if self.create_time is not None:
            self.validate_pattern(self.create_time, 'create_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.entity is not None:
            result['entity'] = self.entity
        if self.action is not None:
            result['action'] = self.action
        if self.target_id is not None:
            result['target_id'] = self.target_id
        if self.operator_id is not None:
            result['operator_id'] = self.operator_id
        if self.operator_name is not None:
            result['operator_name'] = self.operator_name
        if self.source_system is not None:
            result['source_system'] = self.source_system
        if self.context is not None:
            result['context'] = self.context
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.pod_name is not None:
            result['pod_name'] = self.pod_name
        if self.content is not None:
            result['content'] = self.content
        if self.create_time is not None:
            result['create_time'] = self.create_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('entity') is not None:
            self.entity = m.get('entity')
        if m.get('action') is not None:
            self.action = m.get('action')
        if m.get('target_id') is not None:
            self.target_id = m.get('target_id')
        if m.get('operator_id') is not None:
            self.operator_id = m.get('operator_id')
        if m.get('operator_name') is not None:
            self.operator_name = m.get('operator_name')
        if m.get('source_system') is not None:
            self.source_system = m.get('source_system')
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('pod_name') is not None:
            self.pod_name = m.get('pod_name')
        if m.get('content') is not None:
            self.content = m.get('content')
        if m.get('create_time') is not None:
            self.create_time = m.get('create_time')
        return self


class PlanSimpleView(TeaModel):
    def __init__(
        self,
        app_count: int = None,
        created_time: str = None,
        executor: str = None,
        finished_time: str = None,
        id: str = None,
        mode: str = None,
        name: str = None,
        started_time: str = None,
        state: str = None,
        time_series_id: str = None,
        type: str = None,
        workspace_group_id: str = None,
        pod_count: int = None,
    ):
        # 发布单涉及的应用个数
        self.app_count = app_count
        # 创建时间
        self.created_time = created_time
        # 执行人
        self.executor = executor
        # 结束时间
        self.finished_time = finished_time
        # 发布单id
        self.id = id
        # 运维单类型
        self.mode = mode
        # 发布单标题
        self.name = name
        # 开始时间
        self.started_time = started_time
        # 发布单状态
        self.state = state
        # 发布单号
        self.time_series_id = time_series_id
        # 发布单类型
        self.type = type
        # 工作空间组id
        self.workspace_group_id = workspace_group_id
        # Pod 数量
        self.pod_count = pod_count

    def validate(self):
        self.validate_required(self.app_count, 'app_count')
        self.validate_required(self.created_time, 'created_time')
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.executor, 'executor')
        if self.finished_time is not None:
            self.validate_pattern(self.finished_time, 'finished_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.id, 'id')
        self.validate_required(self.mode, 'mode')
        self.validate_required(self.name, 'name')
        if self.started_time is not None:
            self.validate_pattern(self.started_time, 'started_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.state, 'state')
        self.validate_required(self.time_series_id, 'time_series_id')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_count is not None:
            result['app_count'] = self.app_count
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.executor is not None:
            result['executor'] = self.executor
        if self.finished_time is not None:
            result['finished_time'] = self.finished_time
        if self.id is not None:
            result['id'] = self.id
        if self.mode is not None:
            result['mode'] = self.mode
        if self.name is not None:
            result['name'] = self.name
        if self.started_time is not None:
            result['started_time'] = self.started_time
        if self.state is not None:
            result['state'] = self.state
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.pod_count is not None:
            result['pod_count'] = self.pod_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_count') is not None:
            self.app_count = m.get('app_count')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('executor') is not None:
            self.executor = m.get('executor')
        if m.get('finished_time') is not None:
            self.finished_time = m.get('finished_time')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('started_time') is not None:
            self.started_time = m.get('started_time')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('pod_count') is not None:
            self.pod_count = m.get('pod_count')
        return self


class MasterClusterInfoForWorkspaces(TeaModel):
    def __init__(
        self,
        master_cluster_info: MasterCluster = None,
        workspace_ids: List[str] = None,
    ):
        # master cluster info
        self.master_cluster_info = master_cluster_info
        # workspace ids
        self.workspace_ids = workspace_ids

    def validate(self):
        self.validate_required(self.master_cluster_info, 'master_cluster_info')
        if self.master_cluster_info:
            self.master_cluster_info.validate()
        self.validate_required(self.workspace_ids, 'workspace_ids')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.master_cluster_info is not None:
            result['master_cluster_info'] = self.master_cluster_info.to_map()
        if self.workspace_ids is not None:
            result['workspace_ids'] = self.workspace_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('master_cluster_info') is not None:
            temp_model = MasterCluster()
            self.master_cluster_info = temp_model.from_map(m['master_cluster_info'])
        if m.get('workspace_ids') is not None:
            self.workspace_ids = m.get('workspace_ids')
        return self


class IngressInfo(TeaModel):
    def __init__(
        self,
        meta: ContainerServiceObjectMeta = None,
        unified_access_instance_name: str = None,
    ):
        # 元信息
        self.meta = meta
        # 所属统一接入实例名称
        self.unified_access_instance_name = unified_access_instance_name

    def validate(self):
        self.validate_required(self.meta, 'meta')
        if self.meta:
            self.meta.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta is not None:
            result['meta'] = self.meta.to_map()
        if self.unified_access_instance_name is not None:
            result['unified_access_instance_name'] = self.unified_access_instance_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('meta') is not None:
            temp_model = ContainerServiceObjectMeta()
            self.meta = temp_model.from_map(m['meta'])
        if m.get('unified_access_instance_name') is not None:
            self.unified_access_instance_name = m.get('unified_access_instance_name')
        return self


class AntvipDomain(TeaModel):
    def __init__(
        self,
        application: str = None,
        cell: str = None,
        health_check_default_port: int = None,
        health_check_type: str = None,
    ):
        # 应用名称
        self.application = application
        # 部署单元cell名称
        self.cell = cell
        # 健康检查端口，非必填项
        self.health_check_default_port = health_check_default_port
        # 健康检查类型，默认为TCP
        self.health_check_type = health_check_type

    def validate(self):
        self.validate_required(self.application, 'application')
        self.validate_required(self.cell, 'cell')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.application is not None:
            result['application'] = self.application
        if self.cell is not None:
            result['cell'] = self.cell
        if self.health_check_default_port is not None:
            result['health_check_default_port'] = self.health_check_default_port
        if self.health_check_type is not None:
            result['health_check_type'] = self.health_check_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('application') is not None:
            self.application = m.get('application')
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        if m.get('health_check_default_port') is not None:
            self.health_check_default_port = m.get('health_check_default_port')
        if m.get('health_check_type') is not None:
            self.health_check_type = m.get('health_check_type')
        return self


class ReleasePlanSpecAppService(TeaModel):
    def __init__(
        self,
        dependencies: List[str] = None,
        name: str = None,
        revision: str = None,
    ):
        # 依赖的应用服务名字列表
        self.dependencies = dependencies
        # 应用服务名字
        self.name = name
        # container service revision
        self.revision = revision

    def validate(self):
        self.validate_required(self.dependencies, 'dependencies')
        self.validate_required(self.name, 'name')
        self.validate_required(self.revision, 'revision')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dependencies is not None:
            result['dependencies'] = self.dependencies
        if self.name is not None:
            result['name'] = self.name
        if self.revision is not None:
            result['revision'] = self.revision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('dependencies') is not None:
            self.dependencies = m.get('dependencies')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        return self


class ClusterInfo(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        env: str = None,
        is_healthy: bool = None,
        name: str = None,
        overview_info: ClusterOverviewInfo = None,
        region_name: str = None,
        type: str = None,
        version: str = None,
        zone_name: str = None,
        workspace: str = None,
    ):
        # created time
        self.created_time = created_time
        # env
        self.env = env
        # cluster is healthy or not
        self.is_healthy = is_healthy
        # cluster name
        self.name = name
        # cluster overview info
        self.overview_info = overview_info
        # region name
        self.region_name = region_name
        # 独占 or 共享
        self.type = type
        # version
        self.version = version
        # zone name
        self.zone_name = zone_name
        # workspace名称[如果存在]。
        self.workspace = workspace

    def validate(self):
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.is_healthy, 'is_healthy')
        self.validate_required(self.name, 'name')
        self.validate_required(self.overview_info, 'overview_info')
        if self.overview_info:
            self.overview_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.env is not None:
            result['env'] = self.env
        if self.is_healthy is not None:
            result['is_healthy'] = self.is_healthy
        if self.name is not None:
            result['name'] = self.name
        if self.overview_info is not None:
            result['overview_info'] = self.overview_info.to_map()
        if self.region_name is not None:
            result['region_name'] = self.region_name
        if self.type is not None:
            result['type'] = self.type
        if self.version is not None:
            result['version'] = self.version
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('env') is not None:
            self.env = m.get('env')
        if m.get('is_healthy') is not None:
            self.is_healthy = m.get('is_healthy')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('overview_info') is not None:
            temp_model = ClusterOverviewInfo()
            self.overview_info = temp_model.from_map(m['overview_info'])
        if m.get('region_name') is not None:
            self.region_name = m.get('region_name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class SidecarTemplateMeta(TeaModel):
    def __init__(
        self,
        sidecar_name: str = None,
        sidecar_version: str = None,
        template: str = None,
        workspace_id: str = None,
        workspace_group_id: str = None,
        image: str = None,
        extension: str = None,
        scope: str = None,
    ):
        # 名称
        self.sidecar_name = sidecar_name
        # sidecar版本
        self.sidecar_version = sidecar_version
        # 具体的模板信息
        self.template = template
        # 工作空间
        self.workspace_id = workspace_id
        # 工作空间组id
        self.workspace_group_id = workspace_group_id
        # 镜像地址
        self.image = image
        # 保留扩展
        self.extension = extension
        # 基线所应用的scope范围
        self.scope = scope

    def validate(self):
        self.validate_required(self.sidecar_name, 'sidecar_name')
        self.validate_required(self.sidecar_version, 'sidecar_version')
        self.validate_required(self.template, 'template')
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.workspace_group_id, 'workspace_group_id')
        self.validate_required(self.image, 'image')
        self.validate_required(self.extension, 'extension')
        self.validate_required(self.scope, 'scope')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.template is not None:
            result['template'] = self.template
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.image is not None:
            result['image'] = self.image
        if self.extension is not None:
            result['extension'] = self.extension
        if self.scope is not None:
            result['scope'] = self.scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('template') is not None:
            self.template = m.get('template')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('extension') is not None:
            self.extension = m.get('extension')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        return self


class Cluster(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        env: str = None,
        is_healthy: bool = None,
        name: str = None,
        region_name: str = None,
        type: str = None,
        version: str = None,
        workspace: str = None,
        zone_name: str = None,
    ):
        # 集群创建时间
        self.created_time = created_time
        # env
        self.env = env
        # 集群是否健康
        self.is_healthy = is_healthy
        # 集群名称
        self.name = name
        # region name
        # 
        self.region_name = region_name
        # 独占
        self.type = type
        # 集群版本
        self.version = version
        # 环境名称
        self.workspace = workspace
        # 机房名称
        self.zone_name = zone_name

    def validate(self):
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.env, 'env')
        self.validate_required(self.is_healthy, 'is_healthy')
        self.validate_required(self.name, 'name')
        self.validate_required(self.region_name, 'region_name')
        self.validate_required(self.version, 'version')
        self.validate_required(self.workspace, 'workspace')
        self.validate_required(self.zone_name, 'zone_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.env is not None:
            result['env'] = self.env
        if self.is_healthy is not None:
            result['is_healthy'] = self.is_healthy
        if self.name is not None:
            result['name'] = self.name
        if self.region_name is not None:
            result['region_name'] = self.region_name
        if self.type is not None:
            result['type'] = self.type
        if self.version is not None:
            result['version'] = self.version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        if self.zone_name is not None:
            result['zone_name'] = self.zone_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('env') is not None:
            self.env = m.get('env')
        if m.get('is_healthy') is not None:
            self.is_healthy = m.get('is_healthy')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('region_name') is not None:
            self.region_name = m.get('region_name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('version') is not None:
            self.version = m.get('version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        if m.get('zone_name') is not None:
            self.zone_name = m.get('zone_name')
        return self


class FedNamespace(TeaModel):
    def __init__(
        self,
        annotations: List[Annotation] = None,
        clusters: List[str] = None,
        cluster_state_map: List[ClusterState] = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
        create_time_stamp: str = None,
        status: str = None,
        reason: str = None,
    ):
        # 命名空间的注解
        self.annotations = annotations
        # 分发的集群列表
        self.clusters = clusters
        # 分发状态
        self.cluster_state_map = cluster_state_map
        # 命名空间的标签
        self.labels = labels
        # 命名空间名称
        self.name = name
        # 联邦命名空间所在命名空间，和命名空间自身名称保持一致
        self.namespace = namespace
        # 创建时间
        self.create_time_stamp = create_time_stamp
        # 分发状态，成功 True，失败 False，删除中 Deleting
        self.status = status
        # 导致该分发状态的原因
        self.reason = reason

    def validate(self):
        self.validate_required(self.annotations, 'annotations')
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        self.validate_required(self.clusters, 'clusters')
        self.validate_required(self.cluster_state_map, 'cluster_state_map')
        if self.cluster_state_map:
            for k in self.cluster_state_map:
                if k:
                    k.validate()
        self.validate_required(self.labels, 'labels')
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.create_time_stamp, 'create_time_stamp')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        if self.clusters is not None:
            result['clusters'] = self.clusters
        result['cluster_state_map'] = []
        if self.cluster_state_map is not None:
            for k in self.cluster_state_map:
                result['cluster_state_map'].append(k.to_map() if k else None)
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.create_time_stamp is not None:
            result['create_time_stamp'] = self.create_time_stamp
        if self.status is not None:
            result['status'] = self.status
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = Annotation()
                self.annotations.append(temp_model.from_map(k))
        if m.get('clusters') is not None:
            self.clusters = m.get('clusters')
        self.cluster_state_map = []
        if m.get('cluster_state_map') is not None:
            for k in m.get('cluster_state_map'):
                temp_model = ClusterState()
                self.cluster_state_map.append(temp_model.from_map(k))
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('create_time_stamp') is not None:
            self.create_time_stamp = m.get('create_time_stamp')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class AppSimpleInfo(TeaModel):
    def __init__(
        self,
        app_id: str = None,
        app_instance_group_name: str = None,
        app_name: str = None,
        executor: str = None,
        finish_time: str = None,
        group_num: int = None,
        group_strategy: str = None,
        id: str = None,
        namespace: str = None,
        operation_type: str = None,
        revision: str = None,
        rollback_revision: str = None,
        standalone_executable: bool = None,
        start_time: str = None,
        state: str = None,
        pod_count: int = None,
        rollback_reason: str = None,
        depend_container_service_names: List[str] = None,
        message: str = None,
        deployment_template_name: str = None,
        bg_cell_name: str = None,
        bg_group_type: str = None,
    ):
        # 应用id
        self.app_id = app_id
        # 应用分组名字
        self.app_instance_group_name = app_instance_group_name
        # 应用名字
        self.app_name = app_name
        # 执行者
        self.executor = executor
        # 结束时间
        self.finish_time = finish_time
        # 分组个数
        self.group_num = group_num
        # 分组策略
        self.group_strategy = group_strategy
        # id
        self.id = id
        # 命名空间
        self.namespace = namespace
        # 操作类型
        self.operation_type = operation_type
        # 发布版本号
        self.revision = revision
        # 回滚revision
        self.rollback_revision = rollback_revision
        # 是否可单独执行
        self.standalone_executable = standalone_executable
        # 开始时间
        self.start_time = start_time
        # 应用状态
        self.state = state
        # Pod 数量
        self.pod_count = pod_count
        # 回滚原因
        self.rollback_reason = rollback_reason
        # 依赖的应用服务名
        self.depend_container_service_names = depend_container_service_names
        # 错误信息
        self.message = message
        # 发布模板名称
        self.deployment_template_name = deployment_template_name
        # 蓝绿部署单元名
        self.bg_cell_name = bg_cell_name
        # 蓝绿发布类型
        self.bg_group_type = bg_group_type

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.app_instance_group_name, 'app_instance_group_name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.executor, 'executor')
        self.validate_required(self.finish_time, 'finish_time')
        if self.finish_time is not None:
            self.validate_pattern(self.finish_time, 'finish_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.group_num, 'group_num')
        self.validate_required(self.group_strategy, 'group_strategy')
        self.validate_required(self.id, 'id')
        self.validate_required(self.operation_type, 'operation_type')
        self.validate_required(self.revision, 'revision')
        self.validate_required(self.standalone_executable, 'standalone_executable')
        self.validate_required(self.start_time, 'start_time')
        if self.start_time is not None:
            self.validate_pattern(self.start_time, 'start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.state, 'state')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.app_instance_group_name is not None:
            result['app_instance_group_name'] = self.app_instance_group_name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.executor is not None:
            result['executor'] = self.executor
        if self.finish_time is not None:
            result['finish_time'] = self.finish_time
        if self.group_num is not None:
            result['group_num'] = self.group_num
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        if self.id is not None:
            result['id'] = self.id
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operation_type is not None:
            result['operation_type'] = self.operation_type
        if self.revision is not None:
            result['revision'] = self.revision
        if self.rollback_revision is not None:
            result['rollback_revision'] = self.rollback_revision
        if self.standalone_executable is not None:
            result['standalone_executable'] = self.standalone_executable
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.state is not None:
            result['state'] = self.state
        if self.pod_count is not None:
            result['pod_count'] = self.pod_count
        if self.rollback_reason is not None:
            result['rollback_reason'] = self.rollback_reason
        if self.depend_container_service_names is not None:
            result['depend_container_service_names'] = self.depend_container_service_names
        if self.message is not None:
            result['message'] = self.message
        if self.deployment_template_name is not None:
            result['deployment_template_name'] = self.deployment_template_name
        if self.bg_cell_name is not None:
            result['bg_cell_name'] = self.bg_cell_name
        if self.bg_group_type is not None:
            result['bg_group_type'] = self.bg_group_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('app_instance_group_name') is not None:
            self.app_instance_group_name = m.get('app_instance_group_name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('executor') is not None:
            self.executor = m.get('executor')
        if m.get('finish_time') is not None:
            self.finish_time = m.get('finish_time')
        if m.get('group_num') is not None:
            self.group_num = m.get('group_num')
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operation_type') is not None:
            self.operation_type = m.get('operation_type')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('rollback_revision') is not None:
            self.rollback_revision = m.get('rollback_revision')
        if m.get('standalone_executable') is not None:
            self.standalone_executable = m.get('standalone_executable')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('pod_count') is not None:
            self.pod_count = m.get('pod_count')
        if m.get('rollback_reason') is not None:
            self.rollback_reason = m.get('rollback_reason')
        if m.get('depend_container_service_names') is not None:
            self.depend_container_service_names = m.get('depend_container_service_names')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('deployment_template_name') is not None:
            self.deployment_template_name = m.get('deployment_template_name')
        if m.get('bg_cell_name') is not None:
            self.bg_cell_name = m.get('bg_cell_name')
        if m.get('bg_group_type') is not None:
            self.bg_group_type = m.get('bg_group_type')
        return self


class TechStack(TeaModel):
    def __init__(
        self,
        description: str = None,
        extend_properties: str = None,
        id: str = None,
        name: str = None,
        scope: str = None,
        utc_created: str = None,
        utc_modified: str = None,
    ):
        # 技术栈描述
        self.description = description
        # 该字段为字符串类型Map，序列化为字符串用于存储扩展信息，e.g： 云原生下打包存放目录 /home/admin/release
        self.extend_properties = extend_properties
        # 技术栈id
        self.id = id
        # 技术栈名称
        self.name = name
        # 技术栈可见范围，全局可见|租户内可见
        self.scope = scope
        # 创建时间（UTC）
        self.utc_created = utc_created
        # 最近修改时间（UTC）
        self.utc_modified = utc_modified

    def validate(self):
        self.validate_required(self.description, 'description')
        self.validate_required(self.extend_properties, 'extend_properties')
        self.validate_required(self.name, 'name')
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.utc_created, 'utc_created')
        if self.utc_created is not None:
            self.validate_pattern(self.utc_created, 'utc_created', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.utc_modified, 'utc_modified')
        if self.utc_modified is not None:
            self.validate_pattern(self.utc_modified, 'utc_modified', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.scope is not None:
            result['scope'] = self.scope
        if self.utc_created is not None:
            result['utc_created'] = self.utc_created
        if self.utc_modified is not None:
            result['utc_modified'] = self.utc_modified
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('utc_created') is not None:
            self.utc_created = m.get('utc_created')
        if m.get('utc_modified') is not None:
            self.utc_modified = m.get('utc_modified')
        return self


class ExecuteProgress(TeaModel):
    def __init__(
        self,
        blocked: int = None,
        executing: int = None,
        failed: int = None,
        id: str = None,
        inited: int = None,
        state: str = None,
        success: int = None,
        total: int = None,
        waiting: int = None,
    ):
        # 阻塞个数
        self.blocked = blocked
        # 执行中个数
        self.executing = executing
        # 失败个数
        self.failed = failed
        # 执行对象ID
        self.id = id
        # 初始化机器个数
        self.inited = inited
        # 执行对象状态
        self.state = state
        # 成功个数
        self.success = success
        # 总计
        self.total = total
        # 等待中个数
        self.waiting = waiting

    def validate(self):
        self.validate_required(self.blocked, 'blocked')
        self.validate_required(self.executing, 'executing')
        self.validate_required(self.failed, 'failed')
        self.validate_required(self.id, 'id')
        self.validate_required(self.inited, 'inited')
        self.validate_required(self.state, 'state')
        self.validate_required(self.success, 'success')
        self.validate_required(self.total, 'total')
        self.validate_required(self.waiting, 'waiting')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.blocked is not None:
            result['blocked'] = self.blocked
        if self.executing is not None:
            result['executing'] = self.executing
        if self.failed is not None:
            result['failed'] = self.failed
        if self.id is not None:
            result['id'] = self.id
        if self.inited is not None:
            result['inited'] = self.inited
        if self.state is not None:
            result['state'] = self.state
        if self.success is not None:
            result['success'] = self.success
        if self.total is not None:
            result['total'] = self.total
        if self.waiting is not None:
            result['waiting'] = self.waiting
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('blocked') is not None:
            self.blocked = m.get('blocked')
        if m.get('executing') is not None:
            self.executing = m.get('executing')
        if m.get('failed') is not None:
            self.failed = m.get('failed')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('inited') is not None:
            self.inited = m.get('inited')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('total') is not None:
            self.total = m.get('total')
        if m.get('waiting') is not None:
            self.waiting = m.get('waiting')
        return self


class EmergencyPlan(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        params: List[TemplateParam] = None,
    ):
        # 预案id
        self.id = id
        # 预案名称
        self.name = name
        # 预案参数，只有传预案id时才返回预案参数
        self.params = params

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        if self.params:
            for k in self.params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        result['params'] = []
        if self.params is not None:
            for k in self.params:
                result['params'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.params = []
        if m.get('params') is not None:
            for k in m.get('params'):
                temp_model = TemplateParam()
                self.params.append(temp_model.from_map(k))
        return self


class FedConfigMapOverrideList(TeaModel):
    def __init__(
        self,
        list: List[FedConfigmapOverride] = None,
    ):
        # fed configmap override list
        self.list = list

    def validate(self):
        self.validate_required(self.list, 'list')
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = FedConfigmapOverride()
                self.list.append(temp_model.from_map(k))
        return self


class ElasticScene(TeaModel):
    def __init__(
        self,
        name: str = None,
        status: str = None,
        id: int = None,
    ):
        # 场景名
        self.name = name
        # 弹性场景状态，有效值（VALID，INVALID）
        self.status = status
        # 弹性场景ID
        self.id = id

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.status is not None:
            result['status'] = self.status
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class UidShardList(TeaModel):
    def __init__(
        self,
        data: List[UidShard] = None,
    ):
        # the uid shard list.
        self.data = data

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = UidShard()
                self.data.append(temp_model.from_map(k))
        return self


class Region(TeaModel):
    def __init__(
        self,
        id: str = None,
        name: str = None,
        workspaces: List[Workspace] = None,
    ):
        # region id
        self.id = id
        # region name
        self.name = name
        # workspace list
        self.workspaces = workspaces

    def validate(self):
        self.validate_required(self.id, 'id')
        if self.workspaces:
            for k in self.workspaces:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        result['workspaces'] = []
        if self.workspaces is not None:
            for k in self.workspaces:
                result['workspaces'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.workspaces = []
        if m.get('workspaces') is not None:
            for k in m.get('workspaces'):
                temp_model = Workspace()
                self.workspaces.append(temp_model.from_map(k))
        return self


class OBTenant(TeaModel):
    def __init__(
        self,
        description: str = None,
        extend_properties: str = None,
        id: str = None,
        name: str = None,
        type: str = None,
        uids: List[int] = None,
        workspace_group_id: str = None,
        created_time: str = None,
        modified_time: str = None,
    ):
        # 租户描述
        self.description = description
        # 扩展属性，序列化后的JSON字符串
        self.extend_properties = extend_properties
        # 唯一标识
        self.id = id
        # 租户名称
        self.name = name
        # 租户类型（单库GZONE|分片库RZONE）：存放对应业务库
        self.type = type
        # 租户对应uid分段，用于存放对应的业务分片库
        self.uids = uids
        # 工作空间组唯一标识
        self.workspace_group_id = workspace_group_id
        # 创建日期
        self.created_time = created_time
        # 修改时间
        self.modified_time = modified_time

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_group_id, 'workspace_group_id')
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.uids is not None:
            result['uids'] = self.uids
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('uids') is not None:
            self.uids = m.get('uids')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        return self


class OpsGroup(TeaModel):
    def __init__(
        self,
        status: str = None,
        units: List[OpsUnit] = None,
        progresses: List[OpsGroupTaskProgress] = None,
    ):
        # 运维操作组当前状态。取值列表： INITED：初始化完成； EXECUTING：执行中； SUCCESS：执行成功； FAILED：执行失败； CANCELED：已取消； CONFIRM_WAITING：待确认
        self.status = status
        # 包含在此运维操作组中的运维单元列表
        self.units = units
        # 运维任务进度列表
        self.progresses = progresses

    def validate(self):
        if self.units:
            for k in self.units:
                if k:
                    k.validate()
        if self.progresses:
            for k in self.progresses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        result['units'] = []
        if self.units is not None:
            for k in self.units:
                result['units'].append(k.to_map() if k else None)
        result['progresses'] = []
        if self.progresses is not None:
            for k in self.progresses:
                result['progresses'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        self.units = []
        if m.get('units') is not None:
            for k in m.get('units'):
                temp_model = OpsUnit()
                self.units.append(temp_model.from_map(k))
        self.progresses = []
        if m.get('progresses') is not None:
            for k in m.get('progresses'):
                temp_model = OpsGroupTaskProgress()
                self.progresses.append(temp_model.from_map(k))
        return self


class ElasticInfoView(TeaModel):
    def __init__(
        self,
        status: str = None,
        elastic_values: List[str] = None,
        press: bool = None,
    ):
        # 全局弹性状态，有效值：NORMAL，ELASTIC
        self.status = status
        # 弹性值
        self.elastic_values = elastic_values
        # 是否压测
        self.press = press

    def validate(self):
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['status'] = self.status
        if self.elastic_values is not None:
            result['elastic_values'] = self.elastic_values
        if self.press is not None:
            result['press'] = self.press
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('elastic_values') is not None:
            self.elastic_values = m.get('elastic_values')
        if m.get('press') is not None:
            self.press = m.get('press')
        return self


class SidecarReleaseStatus(TeaModel):
    def __init__(
        self,
        order_num: str = None,
        cell_name: str = None,
        status: str = None,
    ):
        # 运维单号
        self.order_num = order_num
        # 部署单元
        self.cell_name = cell_name
        # 所处状态
        self.status = status

    def validate(self):
        self.validate_required(self.order_num, 'order_num')
        self.validate_required(self.cell_name, 'cell_name')
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_num is not None:
            result['order_num'] = self.order_num
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class ServiceInfo(TeaModel):
    def __init__(
        self,
        meta: ContainerServiceObjectMeta = None,
        type: str = None,
        load_balancer_address_type: str = None,
        status: ServiceStatus = None,
        ports: List[ServicePort] = None,
    ):
        # 元信息
        self.meta = meta
        # Service 类型
        self.type = type
        # 负载均衡服务的网络类型（internet | intranet | office | multidomain）
        self.load_balancer_address_type = load_balancer_address_type
        # Service 状态
        self.status = status
        # service端口映射列表
        self.ports = ports

    def validate(self):
        self.validate_required(self.meta, 'meta')
        if self.meta:
            self.meta.validate()
        self.validate_required(self.type, 'type')
        if self.status:
            self.status.validate()
        if self.ports:
            for k in self.ports:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.meta is not None:
            result['meta'] = self.meta.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.load_balancer_address_type is not None:
            result['load_balancer_address_type'] = self.load_balancer_address_type
        if self.status is not None:
            result['status'] = self.status.to_map()
        result['ports'] = []
        if self.ports is not None:
            for k in self.ports:
                result['ports'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('meta') is not None:
            temp_model = ContainerServiceObjectMeta()
            self.meta = temp_model.from_map(m['meta'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('load_balancer_address_type') is not None:
            self.load_balancer_address_type = m.get('load_balancer_address_type')
        if m.get('status') is not None:
            temp_model = ServiceStatus()
            self.status = temp_model.from_map(m['status'])
        self.ports = []
        if m.get('ports') is not None:
            for k in m.get('ports'):
                temp_model = ServicePort()
                self.ports.append(temp_model.from_map(k))
        return self


class UnitFlow(TeaModel):
    def __init__(
        self,
        name: str = None,
        type: str = None,
        cell_flows: List[CellFlow] = None,
        uid_ranges: List[UidRange] = None,
        elastic: bool = None,
    ):
        # 部署单元组的名称
        self.name = name
        # 部署单元组的类型
        self.type = type
        # 该部署单元组下的部署单元流量规则
        self.cell_flows = cell_flows
        # 该部署单元组下的部署单元 uid 分配
        self.uid_ranges = uid_ranges
        # 是否弹性部署单元组
        self.elastic = elastic

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')
        self.validate_required(self.cell_flows, 'cell_flows')
        if self.cell_flows:
            for k in self.cell_flows:
                if k:
                    k.validate()
        self.validate_required(self.uid_ranges, 'uid_ranges')
        if self.uid_ranges:
            for k in self.uid_ranges:
                if k:
                    k.validate()
        self.validate_required(self.elastic, 'elastic')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        result['cell_flows'] = []
        if self.cell_flows is not None:
            for k in self.cell_flows:
                result['cell_flows'].append(k.to_map() if k else None)
        result['uid_ranges'] = []
        if self.uid_ranges is not None:
            for k in self.uid_ranges:
                result['uid_ranges'].append(k.to_map() if k else None)
        if self.elastic is not None:
            result['elastic'] = self.elastic
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        self.cell_flows = []
        if m.get('cell_flows') is not None:
            for k in m.get('cell_flows'):
                temp_model = CellFlow()
                self.cell_flows.append(temp_model.from_map(k))
        self.uid_ranges = []
        if m.get('uid_ranges') is not None:
            for k in m.get('uid_ranges'):
                temp_model = UidRange()
                self.uid_ranges.append(temp_model.from_map(k))
        if m.get('elastic') is not None:
            self.elastic = m.get('elastic')
        return self


class ReleaseVersion(TeaModel):
    def __init__(
        self,
        image: str = None,
    ):
        # 镜像
        self.image = image

    def validate(self):
        self.validate_required(self.image, 'image')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image is not None:
            result['image'] = self.image
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('image') is not None:
            self.image = m.get('image')
        return self


class AppDeployProgress(TeaModel):
    def __init__(
        self,
        component_list: List[str] = None,
        execute_groups: List[AppDeployGroup] = None,
        finish_time: str = None,
        id: str = None,
        is_roll_back: bool = None,
        pod_state_summary: AppDeployPodStateSummary = None,
        post_tasks: List[AppDeployTask] = None,
        pre_tasks: List[AppDeployTask] = None,
        roll_back_service_id: str = None,
        start_time: str = None,
        state: str = None,
        namespace: str = None,
        message: str = None,
        task_id: str = None,
        action_code: str = None,
    ):
        # 应用发布所需要组件列表
        self.component_list = component_list
        # 应用发布分组列表
        self.execute_groups = execute_groups
        # 结束时间
        self.finish_time = finish_time
        # service id
        self.id = id
        # 当前应用是否是一个回滚的应用
        self.is_roll_back = is_roll_back
        # 发布进度pod状态统计数据
        self.pod_state_summary = pod_state_summary
        # 后置任务列表
        self.post_tasks = post_tasks
        # 前置任务列表
        self.pre_tasks = pre_tasks
        # 当前服务关联的一个回滚服务的id，如果该值不为空则表示当前服务被回滚过
        self.roll_back_service_id = roll_back_service_id
        # 开始时间
        self.start_time = start_time
        # 当前发布状态
        self.state = state
        # 容器服务命名空间
        self.namespace = namespace
        # 错误信息
        self.message = message
        # task id
        self.task_id = task_id
        # 操作code
        self.action_code = action_code

    def validate(self):
        self.validate_required(self.component_list, 'component_list')
        self.validate_required(self.execute_groups, 'execute_groups')
        if self.execute_groups:
            for k in self.execute_groups:
                if k:
                    k.validate()
        self.validate_required(self.finish_time, 'finish_time')
        if self.finish_time is not None:
            self.validate_pattern(self.finish_time, 'finish_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.id, 'id')
        self.validate_required(self.is_roll_back, 'is_roll_back')
        self.validate_required(self.pod_state_summary, 'pod_state_summary')
        if self.pod_state_summary:
            self.pod_state_summary.validate()
        self.validate_required(self.post_tasks, 'post_tasks')
        if self.post_tasks:
            for k in self.post_tasks:
                if k:
                    k.validate()
        self.validate_required(self.pre_tasks, 'pre_tasks')
        if self.pre_tasks:
            for k in self.pre_tasks:
                if k:
                    k.validate()
        self.validate_required(self.start_time, 'start_time')
        if self.start_time is not None:
            self.validate_pattern(self.start_time, 'start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.state, 'state')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_list is not None:
            result['component_list'] = self.component_list
        result['execute_groups'] = []
        if self.execute_groups is not None:
            for k in self.execute_groups:
                result['execute_groups'].append(k.to_map() if k else None)
        if self.finish_time is not None:
            result['finish_time'] = self.finish_time
        if self.id is not None:
            result['id'] = self.id
        if self.is_roll_back is not None:
            result['is_roll_back'] = self.is_roll_back
        if self.pod_state_summary is not None:
            result['pod_state_summary'] = self.pod_state_summary.to_map()
        result['post_tasks'] = []
        if self.post_tasks is not None:
            for k in self.post_tasks:
                result['post_tasks'].append(k.to_map() if k else None)
        result['pre_tasks'] = []
        if self.pre_tasks is not None:
            for k in self.pre_tasks:
                result['pre_tasks'].append(k.to_map() if k else None)
        if self.roll_back_service_id is not None:
            result['roll_back_service_id'] = self.roll_back_service_id
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.state is not None:
            result['state'] = self.state
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.message is not None:
            result['message'] = self.message
        if self.task_id is not None:
            result['task_id'] = self.task_id
        if self.action_code is not None:
            result['action_code'] = self.action_code
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('component_list') is not None:
            self.component_list = m.get('component_list')
        self.execute_groups = []
        if m.get('execute_groups') is not None:
            for k in m.get('execute_groups'):
                temp_model = AppDeployGroup()
                self.execute_groups.append(temp_model.from_map(k))
        if m.get('finish_time') is not None:
            self.finish_time = m.get('finish_time')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('is_roll_back') is not None:
            self.is_roll_back = m.get('is_roll_back')
        if m.get('pod_state_summary') is not None:
            temp_model = AppDeployPodStateSummary()
            self.pod_state_summary = temp_model.from_map(m['pod_state_summary'])
        self.post_tasks = []
        if m.get('post_tasks') is not None:
            for k in m.get('post_tasks'):
                temp_model = AppDeployTask()
                self.post_tasks.append(temp_model.from_map(k))
        self.pre_tasks = []
        if m.get('pre_tasks') is not None:
            for k in m.get('pre_tasks'):
                temp_model = AppDeployTask()
                self.pre_tasks.append(temp_model.from_map(k))
        if m.get('roll_back_service_id') is not None:
            self.roll_back_service_id = m.get('roll_back_service_id')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('task_id') is not None:
            self.task_id = m.get('task_id')
        if m.get('action_code') is not None:
            self.action_code = m.get('action_code')
        return self


class SpannerClusterInfo(TeaModel):
    def __init__(
        self,
        container_cpu: int = None,
        container_cpu_exclusive: bool = None,
        container_device_type: str = None,
        container_disk: int = None,
        container_mem: int = None,
        container_network: str = None,
        created_time: str = None,
        extend_properties: str = None,
        id: str = None,
        modified_time: str = None,
        name: str = None,
        status: int = None,
        unit_infos: List[SpannerClusterUnitInfo] = None,
        unit_type: int = None,
        used_ports: List[int] = None,
        address_type: str = None,
    ):
        # 容器的CPU个数
        self.container_cpu = container_cpu
        # 容器是否独占CPU
        self.container_cpu_exclusive = container_cpu_exclusive
        # 容器所在物理机节点的标签
        self.container_device_type = container_device_type
        # 容器的磁盘大小
        self.container_disk = container_disk
        # 容器的内存大小(G)
        self.container_mem = container_mem
        # 容器网络
        self.container_network = container_network
        # 创建时间
        self.created_time = created_time
        # 扩展属性，json字符串
        self.extend_properties = extend_properties
        # ID
        self.id = id
        # 修改时间
        self.modified_time = modified_time
        # 集群名称
        self.name = name
        # 集群的状态： 1 运行状态  2 维护状态
        self.status = status
        # 集群单元信息
        self.unit_infos = unit_infos
        # 0 表示集群单元类型为容器
        self.unit_type = unit_type
        # 已使用的端口
        self.used_ports = used_ports
        # internet/intranet/multidomain/office
        self.address_type = address_type

    def validate(self):
        self.validate_required(self.container_cpu, 'container_cpu')
        self.validate_required(self.container_cpu_exclusive, 'container_cpu_exclusive')
        self.validate_required(self.container_device_type, 'container_device_type')
        self.validate_required(self.container_disk, 'container_disk')
        self.validate_required(self.container_mem, 'container_mem')
        self.validate_required(self.container_network, 'container_network')
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.id, 'id')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.name, 'name')
        self.validate_required(self.status, 'status')
        self.validate_required(self.unit_infos, 'unit_infos')
        if self.unit_infos:
            for k in self.unit_infos:
                if k:
                    k.validate()
        self.validate_required(self.unit_type, 'unit_type')
        self.validate_required(self.address_type, 'address_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.container_cpu is not None:
            result['container_cpu'] = self.container_cpu
        if self.container_cpu_exclusive is not None:
            result['container_cpu_exclusive'] = self.container_cpu_exclusive
        if self.container_device_type is not None:
            result['container_device_type'] = self.container_device_type
        if self.container_disk is not None:
            result['container_disk'] = self.container_disk
        if self.container_mem is not None:
            result['container_mem'] = self.container_mem
        if self.container_network is not None:
            result['container_network'] = self.container_network
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        if self.id is not None:
            result['id'] = self.id
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        if self.name is not None:
            result['name'] = self.name
        if self.status is not None:
            result['status'] = self.status
        result['unit_infos'] = []
        if self.unit_infos is not None:
            for k in self.unit_infos:
                result['unit_infos'].append(k.to_map() if k else None)
        if self.unit_type is not None:
            result['unit_type'] = self.unit_type
        if self.used_ports is not None:
            result['used_ports'] = self.used_ports
        if self.address_type is not None:
            result['address_type'] = self.address_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('container_cpu') is not None:
            self.container_cpu = m.get('container_cpu')
        if m.get('container_cpu_exclusive') is not None:
            self.container_cpu_exclusive = m.get('container_cpu_exclusive')
        if m.get('container_device_type') is not None:
            self.container_device_type = m.get('container_device_type')
        if m.get('container_disk') is not None:
            self.container_disk = m.get('container_disk')
        if m.get('container_mem') is not None:
            self.container_mem = m.get('container_mem')
        if m.get('container_network') is not None:
            self.container_network = m.get('container_network')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('status') is not None:
            self.status = m.get('status')
        self.unit_infos = []
        if m.get('unit_infos') is not None:
            for k in m.get('unit_infos'):
                temp_model = SpannerClusterUnitInfo()
                self.unit_infos.append(temp_model.from_map(k))
        if m.get('unit_type') is not None:
            self.unit_type = m.get('unit_type')
        if m.get('used_ports') is not None:
            self.used_ports = m.get('used_ports')
        if m.get('address_type') is not None:
            self.address_type = m.get('address_type')
        return self


class GrayReleaseConfig(TeaModel):
    def __init__(
        self,
        gray_label: str = None,
        provider: str = None,
        label_apply_policy: str = None,
        weight: int = None,
        rule: GrayLabelApplyRule = None,
        scale_replicas: List[ReplicaCount] = None,
    ):
        # 加到流量上的灰度标签
        self.gray_label = gray_label
        # 提供南北流量网关服务的类型
        self.provider = provider
        # 给流量添加灰度label的策略，可选byWeight或者byRule
        # 在byWeight模式下，会按照用户指定的比例，给进入的流量加上灰度标签
        # 在byRule模式下，会按照用户指定的规则（条件），给进入的流量加上灰度标签。
        self.label_apply_policy = label_apply_policy
        # 给进入的流量添加灰度label的比例，仅当label_apply_policy为byWeight时生效
        self.weight = weight
        # 给进入的流量添加灰度label的规则，仅当label_apply_policy为byRule时生效
        self.rule = rule
        # 在各部署单元期望部署的pod个数，若应用服务当前不部署在其中的部署单元，则该不会在该部署单元上为应用进行部署
        self.scale_replicas = scale_replicas

    def validate(self):
        self.validate_required(self.gray_label, 'gray_label')
        self.validate_required(self.provider, 'provider')
        self.validate_required(self.label_apply_policy, 'label_apply_policy')
        if self.rule:
            self.rule.validate()
        if self.scale_replicas:
            for k in self.scale_replicas:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gray_label is not None:
            result['gray_label'] = self.gray_label
        if self.provider is not None:
            result['provider'] = self.provider
        if self.label_apply_policy is not None:
            result['label_apply_policy'] = self.label_apply_policy
        if self.weight is not None:
            result['weight'] = self.weight
        if self.rule is not None:
            result['rule'] = self.rule.to_map()
        result['scale_replicas'] = []
        if self.scale_replicas is not None:
            for k in self.scale_replicas:
                result['scale_replicas'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('gray_label') is not None:
            self.gray_label = m.get('gray_label')
        if m.get('provider') is not None:
            self.provider = m.get('provider')
        if m.get('label_apply_policy') is not None:
            self.label_apply_policy = m.get('label_apply_policy')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        if m.get('rule') is not None:
            temp_model = GrayLabelApplyRule()
            self.rule = temp_model.from_map(m['rule'])
        self.scale_replicas = []
        if m.get('scale_replicas') is not None:
            for k in m.get('scale_replicas'):
                temp_model = ReplicaCount()
                self.scale_replicas.append(temp_model.from_map(k))
        return self


class CellInfo(TeaModel):
    def __init__(
        self,
        display_name: str = None,
    ):
        # cell display name
        self.display_name = display_name

    def validate(self):
        self.validate_required(self.display_name, 'display_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['display_name'] = self.display_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        return self


class OpsContainerServiceChain(TeaModel):
    def __init__(
        self,
        groups: List[OpsContainerServiceGroup] = None,
    ):
        # 运维容器分组列表
        self.groups = groups

    def validate(self):
        self.validate_required(self.groups, 'groups')
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = OpsContainerServiceGroup()
                self.groups.append(temp_model.from_map(k))
        return self


class NetworkInfo(TeaModel):
    def __init__(
        self,
        description: str = None,
    ):
        # networt description
        self.description = description

    def validate(self):
        self.validate_required(self.description, 'description')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('description') is not None:
            self.description = m.get('description')
        return self


class SidecarOpsMachineGroup(TeaModel):
    def __init__(
        self,
        id: str = None,
        target: str = None,
        status: str = None,
        properties: str = None,
        messages: str = None,
        sub_targets: List[SidecarOpsMachine] = None,
    ):
        # 分组ID
        self.id = id
        # 分组名称
        self.target = target
        # 状态
        self.status = status
        # 扩展属性
        self.properties = properties
        # 执行日志
        self.messages = messages
        # sidecar 运维机器列表
        self.sub_targets = sub_targets

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.status, 'status')
        self.validate_required(self.sub_targets, 'sub_targets')
        if self.sub_targets:
            for k in self.sub_targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.target is not None:
            result['target'] = self.target
        if self.status is not None:
            result['status'] = self.status
        if self.properties is not None:
            result['properties'] = self.properties
        if self.messages is not None:
            result['messages'] = self.messages
        result['sub_targets'] = []
        if self.sub_targets is not None:
            for k in self.sub_targets:
                result['sub_targets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('properties') is not None:
            self.properties = m.get('properties')
        if m.get('messages') is not None:
            self.messages = m.get('messages')
        self.sub_targets = []
        if m.get('sub_targets') is not None:
            for k in m.get('sub_targets'):
                temp_model = SidecarOpsMachine()
                self.sub_targets.append(temp_model.from_map(k))
        return self


class LoadBalancerInstance(TeaModel):
    def __init__(
        self,
        iaas_id: str = None,
        listeners: List[LoadBalancerListener] = None,
        name: str = None,
        paas_id: str = None,
        type: str = None,
        vip_addresses: List[str] = None,
        domain: str = None,
    ):
        # 负责均衡iaas id。
        self.iaas_id = iaas_id
        # 监听器。
        self.listeners = listeners
        # 负载均衡名称。
        self.name = name
        # 负责均衡PAAS id。
        self.paas_id = paas_id
        # 负责均衡类型。
        self.type = type
        # 负载均衡vip地址。
        self.vip_addresses = vip_addresses
        # 统一接入域名。
        self.domain = domain

    def validate(self):
        self.validate_required(self.iaas_id, 'iaas_id')
        self.validate_required(self.listeners, 'listeners')
        if self.listeners:
            for k in self.listeners:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')
        self.validate_required(self.domain, 'domain')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.iaas_id is not None:
            result['iaas_id'] = self.iaas_id
        result['listeners'] = []
        if self.listeners is not None:
            for k in self.listeners:
                result['listeners'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.paas_id is not None:
            result['paas_id'] = self.paas_id
        if self.type is not None:
            result['type'] = self.type
        if self.vip_addresses is not None:
            result['vip_addresses'] = self.vip_addresses
        if self.domain is not None:
            result['domain'] = self.domain
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('iaas_id') is not None:
            self.iaas_id = m.get('iaas_id')
        self.listeners = []
        if m.get('listeners') is not None:
            for k in m.get('listeners'):
                temp_model = LoadBalancerListener()
                self.listeners.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('paas_id') is not None:
            self.paas_id = m.get('paas_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('vip_addresses') is not None:
            self.vip_addresses = m.get('vip_addresses')
        if m.get('domain') is not None:
            self.domain = m.get('domain')
        return self


class PodOverviewInfo(TeaModel):
    def __init__(
        self,
        pod_number: int = None,
        unhealthy_pod_number: int = None,
    ):
        # pod number
        self.pod_number = pod_number
        # unhealthy pod number
        self.unhealthy_pod_number = unhealthy_pod_number

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pod_number is not None:
            result['pod_number'] = self.pod_number
        if self.unhealthy_pod_number is not None:
            result['unhealthy_pod_number'] = self.unhealthy_pod_number
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('pod_number') is not None:
            self.pod_number = m.get('pod_number')
        if m.get('unhealthy_pod_number') is not None:
            self.unhealthy_pod_number = m.get('unhealthy_pod_number')
        return self


class UnifiedAccessInstanceListener(TeaModel):
    def __init__(
        self,
        ca_certificate_id: str = None,
        listener_port: int = None,
        protocol: str = None,
        websocket_connect: bool = None,
    ):
        # CA证书ID。 若既上传CA证书又上传服务器证书，即采用双向认证。 若用户只上传服务器证书，即为单向认证。
        self.ca_certificate_id = ca_certificate_id
        # 统一接入实例监听端口。 取值：1-65535。
        self.listener_port = listener_port
        # 协议类型，目前支持http和https两种
        self.protocol = protocol
        # 是否使用websocket连接方式
        self.websocket_connect = websocket_connect

    def validate(self):
        self.validate_required(self.listener_port, 'listener_port')
        self.validate_required(self.protocol, 'protocol')
        self.validate_required(self.websocket_connect, 'websocket_connect')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ca_certificate_id is not None:
            result['ca_certificate_id'] = self.ca_certificate_id
        if self.listener_port is not None:
            result['listener_port'] = self.listener_port
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.websocket_connect is not None:
            result['websocket_connect'] = self.websocket_connect
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('ca_certificate_id') is not None:
            self.ca_certificate_id = m.get('ca_certificate_id')
        if m.get('listener_port') is not None:
            self.listener_port = m.get('listener_port')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('websocket_connect') is not None:
            self.websocket_connect = m.get('websocket_connect')
        return self


class NodeEvent(TeaModel):
    def __init__(
        self,
        count: int = None,
        message: str = None,
        modified_time: str = None,
        reason: str = None,
        type: str = None,
    ):
        # event count
        self.count = count
        # event message
        self.message = message
        # event modified time
        self.modified_time = modified_time
        # event reason
        self.reason = reason
        # event type
        self.type = type

    def validate(self):
        self.validate_required(self.count, 'count')
        self.validate_required(self.message, 'message')
        self.validate_required(self.modified_time, 'modified_time')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.reason, 'reason')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        if self.message is not None:
            result['message'] = self.message
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        if self.reason is not None:
            result['reason'] = self.reason
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class LinkeReleaseData(TeaModel):
    def __init__(
        self,
        release_id: str = None,
    ):
        # Linke release ID
        self.release_id = release_id

    def validate(self):
        self.validate_required(self.release_id, 'release_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.release_id is not None:
            result['release_id'] = self.release_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('release_id') is not None:
            self.release_id = m.get('release_id')
        return self


class SidecarOperationTask(TeaModel):
    def __init__(
        self,
        biz_id: str = None,
        operator: str = None,
        title: str = None,
        context: SidecarOperationTaskContext = None,
    ):
        # 业务流水号
        self.biz_id = biz_id
        # 操作人
        self.operator = operator
        # 名称
        self.title = title
        # sidecar运维内容上下文信息
        self.context = context

    def validate(self):
        self.validate_required(self.biz_id, 'biz_id')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.title, 'title')
        self.validate_required(self.context, 'context')
        if self.context:
            self.context.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_id is not None:
            result['biz_id'] = self.biz_id
        if self.operator is not None:
            result['operator'] = self.operator
        if self.title is not None:
            result['title'] = self.title
        if self.context is not None:
            result['context'] = self.context.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('biz_id') is not None:
            self.biz_id = m.get('biz_id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('context') is not None:
            temp_model = SidecarOperationTaskContext()
            self.context = temp_model.from_map(m['context'])
        return self


class ClusterStatus(TeaModel):
    def __init__(
        self,
        name: str = None,
        overview_info: ClusterOverviewInfo = None,
    ):
        # 集群名称
        self.name = name
        # 集群资源概览
        self.overview_info = overview_info

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.overview_info, 'overview_info')
        if self.overview_info:
            self.overview_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.overview_info is not None:
            result['overview_info'] = self.overview_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('overview_info') is not None:
            temp_model = ClusterOverviewInfo()
            self.overview_info = temp_model.from_map(m['overview_info'])
        return self


class TenantAppReleaseData(TeaModel):
    def __init__(
        self,
        success: bool = None,
        tenant: str = None,
        release_id: str = None,
        workspace_group: str = None,
    ):
        # 是否成功
        self.success = success
        # 机构名称
        self.tenant = tenant
        # 发布单ID
        self.release_id = release_id
        # 环境
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.success, 'success')
        self.validate_required(self.tenant, 'tenant')
        self.validate_required(self.release_id, 'release_id')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.success is not None:
            result['success'] = self.success
        if self.tenant is not None:
            result['tenant'] = self.tenant
        if self.release_id is not None:
            result['release_id'] = self.release_id
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('tenant') is not None:
            self.tenant = m.get('tenant')
        if m.get('release_id') is not None:
            self.release_id = m.get('release_id')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class LocalObjectReference(TeaModel):
    def __init__(
        self,
        name: str = None,
    ):
        # name
        self.name = name

    def validate(self):
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class JsonPatch(TeaModel):
    def __init__(
        self,
        op: str = None,
        path: str = None,
        value: str = None,
        value_type: str = None,
    ):
        # 操作类型
        self.op = op
        # json path 路径
        self.path = path
        # 值
        self.value = value
        # 值类型，默认 string
        self.value_type = value_type

    def validate(self):
        self.validate_required(self.op, 'op')
        self.validate_required(self.path, 'path')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.op is not None:
            result['op'] = self.op
        if self.path is not None:
            result['path'] = self.path
        if self.value is not None:
            result['value'] = self.value
        if self.value_type is not None:
            result['value_type'] = self.value_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('op') is not None:
            self.op = m.get('op')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('value_type') is not None:
            self.value_type = m.get('value_type')
        return self


class ElasticRuleView(TeaModel):
    def __init__(
        self,
        id: int = None,
        type: str = None,
        name: str = None,
        app_name: str = None,
        status: str = None,
        operator: str = None,
        scene_id: int = None,
    ):
        # ID
        self.id = id
        # 弹性类型，有效值：SERVICE，MSGBROKER
        self.type = type
        # 弹性值
        self.name = name
        # 关联应用
        self.app_name = app_name
        # 状态，有效值：VALID（线上生效），PRESS（仅压测生效），INVALID（无效状态）
        self.status = status
        # 操作人
        self.operator = operator
        # 场景 ID
        self.scene_id = scene_id

    def validate(self):
        self.validate_required(self.type, 'type')
        self.validate_required(self.name, 'name')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.status, 'status')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.scene_id, 'scene_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.type is not None:
            result['type'] = self.type
        if self.name is not None:
            result['name'] = self.name
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.status is not None:
            result['status'] = self.status
        if self.operator is not None:
            result['operator'] = self.operator
        if self.scene_id is not None:
            result['scene_id'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('scene_id') is not None:
            self.scene_id = m.get('scene_id')
        return self


class ElasticSubRuleView(TeaModel):
    def __init__(
        self,
        id: int = None,
        app_name: str = None,
        elastic_rule_id: int = None,
        parent_id: int = None,
        value: str = None,
        use_default_eid: bool = None,
        status: str = None,
        type: str = None,
        scene_id: int = None,
    ):
        # 弹性子规则ID
        self.id = id
        # 所属APP
        self.app_name = app_name
        # 关联的弹性规则ID
        self.elastic_rule_id = elastic_rule_id
        # 父节点
        self.parent_id = parent_id
        # 值
        self.value = value
        # 是否使用默认eid，默认 false
        self.use_default_eid = use_default_eid
        # 状态，有效值：VALID（线上生效），PRESS（仅压测生效），INVALID（无效状态）
        self.status = status
        # 规则类型
        self.type = type
        # 场景ID
        self.scene_id = scene_id

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.elastic_rule_id, 'elastic_rule_id')
        self.validate_required(self.value, 'value')
        self.validate_required(self.status, 'status')
        self.validate_required(self.type, 'type')
        self.validate_required(self.scene_id, 'scene_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['id'] = self.id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.elastic_rule_id is not None:
            result['elastic_rule_id'] = self.elastic_rule_id
        if self.parent_id is not None:
            result['parent_id'] = self.parent_id
        if self.value is not None:
            result['value'] = self.value
        if self.use_default_eid is not None:
            result['use_default_eid'] = self.use_default_eid
        if self.status is not None:
            result['status'] = self.status
        if self.type is not None:
            result['type'] = self.type
        if self.scene_id is not None:
            result['scene_id'] = self.scene_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('elastic_rule_id') is not None:
            self.elastic_rule_id = m.get('elastic_rule_id')
        if m.get('parent_id') is not None:
            self.parent_id = m.get('parent_id')
        if m.get('value') is not None:
            self.value = m.get('value')
        if m.get('use_default_eid') is not None:
            self.use_default_eid = m.get('use_default_eid')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('scene_id') is not None:
            self.scene_id = m.get('scene_id')
        return self


class PushRuleResult(TeaModel):
    def __init__(
        self,
        name: str = None,
        desc: str = None,
        succeed_list: List[str] = None,
        failed_list: List[str] = None,
        message: str = None,
    ):
        # site名字
        self.name = name
        # site描述
        self.desc = desc
        # 推送成功的zone
        self.succeed_list = succeed_list
        # 推送失败的zone
        self.failed_list = failed_list
        # 失败信息
        self.message = message

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        if self.desc is not None:
            result['desc'] = self.desc
        if self.succeed_list is not None:
            result['succeed_list'] = self.succeed_list
        if self.failed_list is not None:
            result['failed_list'] = self.failed_list
        if self.message is not None:
            result['message'] = self.message
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('desc') is not None:
            self.desc = m.get('desc')
        if m.get('succeed_list') is not None:
            self.succeed_list = m.get('succeed_list')
        if m.get('failed_list') is not None:
            self.failed_list = m.get('failed_list')
        if m.get('message') is not None:
            self.message = m.get('message')
        return self


class ContainerServiceBasicInfo(TeaModel):
    def __init__(
        self,
        app_build: str = None,
        app_id: str = None,
        app_name: str = None,
        created_time: str = None,
        current_image: str = None,
        deploying_revision: str = None,
        deployment_status: str = None,
        description: str = None,
        drafted_revision: str = None,
        drafted_time: str = None,
        last_deployed_revision: str = None,
        last_deploy_end_time: str = None,
        last_deploy_plan_id: str = None,
        last_deploy_start_time: str = None,
        metadata_status: str = None,
        modified_time: str = None,
        name: str = None,
        namespace: str = None,
        owner: str = None,
        pod_list: List[PodInfo] = None,
        processing_count: str = None,
        replicas: str = None,
        running_count: str = None,
        runtime_revision: str = None,
        workspace_group: str = None,
        service_list: List[LoadBalancerService] = None,
        message_detail: str = None,
    ):
        # 镜像构建id。
        self.app_build = app_build
        # 应用id
        self.app_id = app_id
        # 应用名称。
        self.app_name = app_name
        # 创建时间。
        self.created_time = created_time
        # 当前最新镜像。
        self.current_image = current_image
        # 发布中的版本。
        self.deploying_revision = deploying_revision
        # 发布部署状态。
        self.deployment_status = deployment_status
        # container service描述
        self.description = description
        # 当前应用服务草稿对应的版本号。
        self.drafted_revision = drafted_revision
        # 草稿更新时间。
        self.drafted_time = drafted_time
        # 最近一次发布的版本。
        self.last_deployed_revision = last_deployed_revision
        # 最近一次发布的结束时间。
        self.last_deploy_end_time = last_deploy_end_time
        # 最近一次关联的发布单。
        self.last_deploy_plan_id = last_deploy_plan_id
        # 最近一次发布的开始时间。
        self.last_deploy_start_time = last_deploy_start_time
        # 容器服务元数据状态。
        self.metadata_status = metadata_status
        # 创建时间。
        self.modified_time = modified_time
        # 容器应用服务名称。
        self.name = name
        # 所属命名空间名称。
        self.namespace = namespace
        # 负责人。
        self.owner = owner
        # 容器服务的Pod列表。
        self.pod_list = pod_list
        # 更新中pod数量
        self.processing_count = processing_count
        # replicas数量
        self.replicas = replicas
        # runding pod数量
        self.running_count = running_count
        # 运行时版本。
        self.runtime_revision = runtime_revision
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # 容器服务Service列表。
        self.service_list = service_list
        # message信息
        self.message_detail = message_detail

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.created_time, 'created_time')
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.drafted_time is not None:
            self.validate_pattern(self.drafted_time, 'drafted_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.last_deploy_end_time is not None:
            self.validate_pattern(self.last_deploy_end_time, 'last_deploy_end_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.last_deploy_start_time is not None:
            self.validate_pattern(self.last_deploy_start_time, 'last_deploy_start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.metadata_status, 'metadata_status')
        self.validate_required(self.modified_time, 'modified_time')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.owner, 'owner')
        self.validate_required(self.pod_list, 'pod_list')
        if self.pod_list:
            for k in self.pod_list:
                if k:
                    k.validate()
        self.validate_required(self.replicas, 'replicas')
        self.validate_required(self.workspace_group, 'workspace_group')
        if self.service_list:
            for k in self.service_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_build is not None:
            result['app_build'] = self.app_build
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.current_image is not None:
            result['current_image'] = self.current_image
        if self.deploying_revision is not None:
            result['deploying_revision'] = self.deploying_revision
        if self.deployment_status is not None:
            result['deployment_status'] = self.deployment_status
        if self.description is not None:
            result['description'] = self.description
        if self.drafted_revision is not None:
            result['drafted_revision'] = self.drafted_revision
        if self.drafted_time is not None:
            result['drafted_time'] = self.drafted_time
        if self.last_deployed_revision is not None:
            result['last_deployed_revision'] = self.last_deployed_revision
        if self.last_deploy_end_time is not None:
            result['last_deploy_end_time'] = self.last_deploy_end_time
        if self.last_deploy_plan_id is not None:
            result['last_deploy_plan_id'] = self.last_deploy_plan_id
        if self.last_deploy_start_time is not None:
            result['last_deploy_start_time'] = self.last_deploy_start_time
        if self.metadata_status is not None:
            result['metadata_status'] = self.metadata_status
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.owner is not None:
            result['owner'] = self.owner
        result['pod_list'] = []
        if self.pod_list is not None:
            for k in self.pod_list:
                result['pod_list'].append(k.to_map() if k else None)
        if self.processing_count is not None:
            result['processing_count'] = self.processing_count
        if self.replicas is not None:
            result['replicas'] = self.replicas
        if self.running_count is not None:
            result['running_count'] = self.running_count
        if self.runtime_revision is not None:
            result['runtime_revision'] = self.runtime_revision
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        result['service_list'] = []
        if self.service_list is not None:
            for k in self.service_list:
                result['service_list'].append(k.to_map() if k else None)
        if self.message_detail is not None:
            result['message_detail'] = self.message_detail
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('app_build') is not None:
            self.app_build = m.get('app_build')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('current_image') is not None:
            self.current_image = m.get('current_image')
        if m.get('deploying_revision') is not None:
            self.deploying_revision = m.get('deploying_revision')
        if m.get('deployment_status') is not None:
            self.deployment_status = m.get('deployment_status')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('drafted_revision') is not None:
            self.drafted_revision = m.get('drafted_revision')
        if m.get('drafted_time') is not None:
            self.drafted_time = m.get('drafted_time')
        if m.get('last_deployed_revision') is not None:
            self.last_deployed_revision = m.get('last_deployed_revision')
        if m.get('last_deploy_end_time') is not None:
            self.last_deploy_end_time = m.get('last_deploy_end_time')
        if m.get('last_deploy_plan_id') is not None:
            self.last_deploy_plan_id = m.get('last_deploy_plan_id')
        if m.get('last_deploy_start_time') is not None:
            self.last_deploy_start_time = m.get('last_deploy_start_time')
        if m.get('metadata_status') is not None:
            self.metadata_status = m.get('metadata_status')
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('owner') is not None:
            self.owner = m.get('owner')
        self.pod_list = []
        if m.get('pod_list') is not None:
            for k in m.get('pod_list'):
                temp_model = PodInfo()
                self.pod_list.append(temp_model.from_map(k))
        if m.get('processing_count') is not None:
            self.processing_count = m.get('processing_count')
        if m.get('replicas') is not None:
            self.replicas = m.get('replicas')
        if m.get('running_count') is not None:
            self.running_count = m.get('running_count')
        if m.get('runtime_revision') is not None:
            self.runtime_revision = m.get('runtime_revision')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        self.service_list = []
        if m.get('service_list') is not None:
            for k in m.get('service_list'):
                temp_model = LoadBalancerService()
                self.service_list.append(temp_model.from_map(k))
        if m.get('message_detail') is not None:
            self.message_detail = m.get('message_detail')
        return self


class SystemURL(TeaModel):
    def __init__(
        self,
        platform_name: str = None,
        url: str = None,
        context: str = None,
    ):
        # 平台名称
        self.platform_name = platform_name
        # url
        self.url = url
        # 上线问配置
        self.context = context

    def validate(self):
        self.validate_required(self.platform_name, 'platform_name')
        self.validate_required(self.url, 'url')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.platform_name is not None:
            result['platform_name'] = self.platform_name
        if self.url is not None:
            result['url'] = self.url
        if self.context is not None:
            result['context'] = self.context
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('platform_name') is not None:
            self.platform_name = m.get('platform_name')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('context') is not None:
            self.context = m.get('context')
        return self


class FedImagePullSecret(TeaModel):
    def __init__(
        self,
        annotations: List[str] = None,
        data: RegistryAccout = None,
        labels: List[str] = None,
        name: str = None,
        namespace: str = None,
        overrides: FedImagePullSecretOverrideList = None,
        workspace_group_name: str = None,
        cells: List[str] = None,
    ):
        # annotations
        self.annotations = annotations
        # image pull secret registry account info
        self.data = data
        # labels
        self.labels = labels
        # name
        self.name = name
        # namesapce
        self.namespace = namespace
        # cell overrides
        self.overrides = overrides
        # workspace group name
        self.workspace_group_name = workspace_group_name
        # cell list
        self.cells = cells

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.overrides, 'overrides')
        if self.overrides:
            self.overrides.validate()
        self.validate_required(self.workspace_group_name, 'workspace_group_name')
        self.validate_required(self.cells, 'cells')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['annotations'] = self.annotations
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.labels is not None:
            result['labels'] = self.labels
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.overrides is not None:
            result['overrides'] = self.overrides.to_map()
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.cells is not None:
            result['cells'] = self.cells
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('annotations') is not None:
            self.annotations = m.get('annotations')
        if m.get('data') is not None:
            temp_model = RegistryAccout()
            self.data = temp_model.from_map(m['data'])
        if m.get('labels') is not None:
            self.labels = m.get('labels')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('overrides') is not None:
            temp_model = FedImagePullSecretOverrideList()
            self.overrides = temp_model.from_map(m['overrides'])
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        return self


class ListPodOption(TeaModel):
    def __init__(
        self,
        type: str = None,
        pod_numer_from: int = None,
        pod_number_to: int = None,
        pod_numbers: List[int] = None,
    ):
        # 根据pod number列举pod的方式：RANGE为范围查询；ARRAY为指定pod number查询；ALL查询全量
        self.type = type
        # [type为RANGE时生效]范围查询的左边界（包含）
        self.pod_numer_from = pod_numer_from
        # [type为RANGE时生效]范围查询的右边界（不包含）
        self.pod_number_to = pod_number_to
        # [type为ARRAY时生效]指定pod number的查询
        self.pod_numbers = pod_numbers

    def validate(self):
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['type'] = self.type
        if self.pod_numer_from is not None:
            result['pod_numer_from'] = self.pod_numer_from
        if self.pod_number_to is not None:
            result['pod_number_to'] = self.pod_number_to
        if self.pod_numbers is not None:
            result['pod_numbers'] = self.pod_numbers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('pod_numer_from') is not None:
            self.pod_numer_from = m.get('pod_numer_from')
        if m.get('pod_number_to') is not None:
            self.pod_number_to = m.get('pod_number_to')
        if m.get('pod_numbers') is not None:
            self.pod_numbers = m.get('pod_numbers')
        return self


class CellWeight(TeaModel):
    def __init__(
        self,
        name: str = None,
        cell_weight_infos: List[CellWeightInfo] = None,
    ):
        # 统一接入或负载均衡名称
        self.name = name
        # 部署单元权重详情
        self.cell_weight_infos = cell_weight_infos

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.cell_weight_infos, 'cell_weight_infos')
        if self.cell_weight_infos:
            for k in self.cell_weight_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['name'] = self.name
        result['cell_weight_infos'] = []
        if self.cell_weight_infos is not None:
            for k in self.cell_weight_infos:
                result['cell_weight_infos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('name') is not None:
            self.name = m.get('name')
        self.cell_weight_infos = []
        if m.get('cell_weight_infos') is not None:
            for k in m.get('cell_weight_infos'):
                temp_model = CellWeightInfo()
                self.cell_weight_infos.append(temp_model.from_map(k))
        return self


class OAMApplicationConfiguration(TeaModel):
    def __init__(self):
        pass

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        return self


class PushSite(TeaModel):
    def __init__(
        self,
        current: bool = None,
        description: str = None,
        id: int = None,
        interface_type: str = None,
        interface_urls: List[str] = None,
        name: str = None,
        site_cells: List[SiteCell] = None,
        site_type: str = None,
    ):
        # 是否当前站点
        self.current = current
        # 站点描述
        self.description = description
        # 站点唯一标识
        self.id = id
        # 接口类型，可选（RPC，REST）
        self.interface_type = interface_type
        # 站点 DRM endpoints
        self.interface_urls = interface_urls
        # 站点名称
        self.name = name
        # 站点部署单元
        self.site_cells = site_cells
        # 站点类型，可选（MAIN，ISOMERISM）
        self.site_type = site_type

    def validate(self):
        self.validate_required(self.current, 'current')
        self.validate_required(self.id, 'id')
        self.validate_required(self.interface_type, 'interface_type')
        self.validate_required(self.name, 'name')
        if self.site_cells:
            for k in self.site_cells:
                if k:
                    k.validate()
        self.validate_required(self.site_type, 'site_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current is not None:
            result['current'] = self.current
        if self.description is not None:
            result['description'] = self.description
        if self.id is not None:
            result['id'] = self.id
        if self.interface_type is not None:
            result['interface_type'] = self.interface_type
        if self.interface_urls is not None:
            result['interface_urls'] = self.interface_urls
        if self.name is not None:
            result['name'] = self.name
        result['site_cells'] = []
        if self.site_cells is not None:
            for k in self.site_cells:
                result['site_cells'].append(k.to_map() if k else None)
        if self.site_type is not None:
            result['site_type'] = self.site_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('current') is not None:
            self.current = m.get('current')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('interface_type') is not None:
            self.interface_type = m.get('interface_type')
        if m.get('interface_urls') is not None:
            self.interface_urls = m.get('interface_urls')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.site_cells = []
        if m.get('site_cells') is not None:
            for k in m.get('site_cells'):
                temp_model = SiteCell()
                self.site_cells.append(temp_model.from_map(k))
        if m.get('site_type') is not None:
            self.site_type = m.get('site_type')
        return self


class FedConfigmap(TeaModel):
    def __init__(
        self,
        annotations: List[Annotation] = None,
        cell_status: List[ClusteCellStatus] = None,
        clusters: List[str] = None,
        create_time_stamp: str = None,
        data: List[ConfigMapData] = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
        overrides: List[FedConfigmapOverride] = None,
        reason: str = None,
        status: str = None,
    ):
        # 配置项的注解
        self.annotations = annotations
        # 分发状态
        self.cell_status = cell_status
        # 分发的 cell 列表
        self.clusters = clusters
        # 创建时间
        self.create_time_stamp = create_time_stamp
        # 配置项数据
        self.data = data
        # 配置项的标签
        self.labels = labels
        # 名称
        self.name = name
        # 命名空间
        self.namespace = namespace
        # 配置项数据在不同 cell 下的自定义覆盖配置
        self.overrides = overrides
        # 导致该分发状态的原因
        self.reason = reason
        # 分发状态，成功 True，失败 False，删除中 Deleting
        self.status = status

    def validate(self):
        self.validate_required(self.annotations, 'annotations')
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()
        if self.cell_status:
            for k in self.cell_status:
                if k:
                    k.validate()
        self.validate_required(self.clusters, 'clusters')
        self.validate_required(self.create_time_stamp, 'create_time_stamp')
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        self.validate_required(self.labels, 'labels')
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.overrides, 'overrides')
        if self.overrides:
            for k in self.overrides:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        result['cell_status'] = []
        if self.cell_status is not None:
            for k in self.cell_status:
                result['cell_status'].append(k.to_map() if k else None)
        if self.clusters is not None:
            result['clusters'] = self.clusters
        if self.create_time_stamp is not None:
            result['create_time_stamp'] = self.create_time_stamp
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        result['overrides'] = []
        if self.overrides is not None:
            for k in self.overrides:
                result['overrides'].append(k.to_map() if k else None)
        if self.reason is not None:
            result['reason'] = self.reason
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = Annotation()
                self.annotations.append(temp_model.from_map(k))
        self.cell_status = []
        if m.get('cell_status') is not None:
            for k in m.get('cell_status'):
                temp_model = ClusteCellStatus()
                self.cell_status.append(temp_model.from_map(k))
        if m.get('clusters') is not None:
            self.clusters = m.get('clusters')
        if m.get('create_time_stamp') is not None:
            self.create_time_stamp = m.get('create_time_stamp')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ConfigMapData()
                self.data.append(temp_model.from_map(k))
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        self.overrides = []
        if m.get('overrides') is not None:
            for k in m.get('overrides'):
                temp_model = FedConfigmapOverride()
                self.overrides.append(temp_model.from_map(k))
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UnifiedAccessInstanceInfo(TeaModel):
    def __init__(
        self,
        created_time: str = None,
        spanner_cluster: str = None,
        unified_access_instance_container_service_infos: List[UnifiedAccessInstanceContainerServiceInfo] = None,
        unified_access_instance_https_entry: HttpsEntry = None,
        unified_access_instance_http_entry: HttpEntry = None,
        unified_access_instance_id: str = None,
        unified_access_instance_local_detail_infos: List[UnifiedAccessInstanceLocalDetailInfo] = None,
        unified_access_instance_message_details: str = None,
        unified_access_instance_name: str = None,
        unified_access_instance_status: str = None,
        unified_access_instance_type: str = None,
        entry_settings: EntrySettings = None,
    ):
        # 统一接入实例创建的时间
        self.created_time = created_time
        # 关联的Spanner逻辑集群名称，一个逻辑集群由很多个local集群组成
        self.spanner_cluster = spanner_cluster
        # 关联的应用服务信息
        self.unified_access_instance_container_service_infos = unified_access_instance_container_service_infos
        # https协议配置
        self.unified_access_instance_https_entry = unified_access_instance_https_entry
        # http协议配置
        self.unified_access_instance_http_entry = unified_access_instance_http_entry
        # 统一接入实例ID
        self.unified_access_instance_id = unified_access_instance_id
        # 本地集群详细信息
        self.unified_access_instance_local_detail_infos = unified_access_instance_local_detail_infos
        # 统一接入实例详细信息显示，包含错误状态信息等
        self.unified_access_instance_message_details = unified_access_instance_message_details
        # 统一接入实例名称
        self.unified_access_instance_name = unified_access_instance_name
        # 统一接入实例状态描述：创建中、创建成功、创建失败
        self.unified_access_instance_status = unified_access_instance_status
        # 统一接入实例网络类型，内网（intranet），公网（internet）
        self.unified_access_instance_type = unified_access_instance_type
        # custom模式下，用户自定义entryId以及entryVip信息
        self.entry_settings = entry_settings

    def validate(self):
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.spanner_cluster, 'spanner_cluster')
        if self.unified_access_instance_container_service_infos:
            for k in self.unified_access_instance_container_service_infos:
                if k:
                    k.validate()
        if self.unified_access_instance_https_entry:
            self.unified_access_instance_https_entry.validate()
        self.validate_required(self.unified_access_instance_http_entry, 'unified_access_instance_http_entry')
        if self.unified_access_instance_http_entry:
            self.unified_access_instance_http_entry.validate()
        self.validate_required(self.unified_access_instance_id, 'unified_access_instance_id')
        self.validate_required(self.unified_access_instance_local_detail_infos, 'unified_access_instance_local_detail_infos')
        if self.unified_access_instance_local_detail_infos:
            for k in self.unified_access_instance_local_detail_infos:
                if k:
                    k.validate()
        self.validate_required(self.unified_access_instance_name, 'unified_access_instance_name')
        self.validate_required(self.unified_access_instance_status, 'unified_access_instance_status')
        self.validate_required(self.unified_access_instance_type, 'unified_access_instance_type')
        if self.entry_settings:
            self.entry_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.spanner_cluster is not None:
            result['spanner_cluster'] = self.spanner_cluster
        result['unified_access_instance_container_service_infos'] = []
        if self.unified_access_instance_container_service_infos is not None:
            for k in self.unified_access_instance_container_service_infos:
                result['unified_access_instance_container_service_infos'].append(k.to_map() if k else None)
        if self.unified_access_instance_https_entry is not None:
            result['unified_access_instance_https_entry'] = self.unified_access_instance_https_entry.to_map()
        if self.unified_access_instance_http_entry is not None:
            result['unified_access_instance_http_entry'] = self.unified_access_instance_http_entry.to_map()
        if self.unified_access_instance_id is not None:
            result['unified_access_instance_id'] = self.unified_access_instance_id
        result['unified_access_instance_local_detail_infos'] = []
        if self.unified_access_instance_local_detail_infos is not None:
            for k in self.unified_access_instance_local_detail_infos:
                result['unified_access_instance_local_detail_infos'].append(k.to_map() if k else None)
        if self.unified_access_instance_message_details is not None:
            result['unified_access_instance_message_details'] = self.unified_access_instance_message_details
        if self.unified_access_instance_name is not None:
            result['unified_access_instance_name'] = self.unified_access_instance_name
        if self.unified_access_instance_status is not None:
            result['unified_access_instance_status'] = self.unified_access_instance_status
        if self.unified_access_instance_type is not None:
            result['unified_access_instance_type'] = self.unified_access_instance_type
        if self.entry_settings is not None:
            result['entry_settings'] = self.entry_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('spanner_cluster') is not None:
            self.spanner_cluster = m.get('spanner_cluster')
        self.unified_access_instance_container_service_infos = []
        if m.get('unified_access_instance_container_service_infos') is not None:
            for k in m.get('unified_access_instance_container_service_infos'):
                temp_model = UnifiedAccessInstanceContainerServiceInfo()
                self.unified_access_instance_container_service_infos.append(temp_model.from_map(k))
        if m.get('unified_access_instance_https_entry') is not None:
            temp_model = HttpsEntry()
            self.unified_access_instance_https_entry = temp_model.from_map(m['unified_access_instance_https_entry'])
        if m.get('unified_access_instance_http_entry') is not None:
            temp_model = HttpEntry()
            self.unified_access_instance_http_entry = temp_model.from_map(m['unified_access_instance_http_entry'])
        if m.get('unified_access_instance_id') is not None:
            self.unified_access_instance_id = m.get('unified_access_instance_id')
        self.unified_access_instance_local_detail_infos = []
        if m.get('unified_access_instance_local_detail_infos') is not None:
            for k in m.get('unified_access_instance_local_detail_infos'):
                temp_model = UnifiedAccessInstanceLocalDetailInfo()
                self.unified_access_instance_local_detail_infos.append(temp_model.from_map(k))
        if m.get('unified_access_instance_message_details') is not None:
            self.unified_access_instance_message_details = m.get('unified_access_instance_message_details')
        if m.get('unified_access_instance_name') is not None:
            self.unified_access_instance_name = m.get('unified_access_instance_name')
        if m.get('unified_access_instance_status') is not None:
            self.unified_access_instance_status = m.get('unified_access_instance_status')
        if m.get('unified_access_instance_type') is not None:
            self.unified_access_instance_type = m.get('unified_access_instance_type')
        if m.get('entry_settings') is not None:
            temp_model = EntrySettings()
            self.entry_settings = temp_model.from_map(m['entry_settings'])
        return self


class ZoneOfWorkspace(TeaModel):
    def __init__(
        self,
        workspace_id: str = None,
        workspace_name: str = None,
        zones: List[ZoneInfo] = None,
        region_name: str = None,
        region_id: str = None,
    ):
        # workspace id
        self.workspace_id = workspace_id
        # workspace name
        self.workspace_name = workspace_name
        # zone list of workspace
        self.zones = zones
        # region name
        self.region_name = region_name
        # region id
        self.region_id = region_id

    def validate(self):
        self.validate_required(self.workspace_id, 'workspace_id')
        self.validate_required(self.workspace_name, 'workspace_name')
        self.validate_required(self.zones, 'zones')
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()
        self.validate_required(self.region_name, 'region_name')
        self.validate_required(self.region_id, 'region_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.workspace_name is not None:
            result['workspace_name'] = self.workspace_name
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        if self.region_name is not None:
            result['region_name'] = self.region_name
        if self.region_id is not None:
            result['region_id'] = self.region_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('workspace_name') is not None:
            self.workspace_name = m.get('workspace_name')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = ZoneInfo()
                self.zones.append(temp_model.from_map(k))
        if m.get('region_name') is not None:
            self.region_name = m.get('region_name')
        if m.get('region_id') is not None:
            self.region_id = m.get('region_id')
        return self


class BindAppserviceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        application_name: str = None,
        app_service_name: str = None,
        cell_ids: List[str] = None,
        workspace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称
        self.application_name = application_name
        # 应用服务名称
        self.app_service_name = app_service_name
        # 部署单元名称列表。 n代表第n个应用的名称，n从1开始，最大100。每个部署单元名称最大60个UTF-8字符。如果要输入多个部署单元，使用如下形式：cell_ids.1=RZ01A&cell_ids.2=RZ02B
        self.cell_ids = cell_ids
        # 工作空间名称
        self.workspace = workspace

    def validate(self):
        self.validate_required(self.application_name, 'application_name')
        self.validate_required(self.app_service_name, 'app_service_name')
        self.validate_required(self.cell_ids, 'cell_ids')
        self.validate_required(self.workspace, 'workspace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.application_name is not None:
            result['application_name'] = self.application_name
        if self.app_service_name is not None:
            result['app_service_name'] = self.app_service_name
        if self.cell_ids is not None:
            result['cell_ids'] = self.cell_ids
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('application_name') is not None:
            self.application_name = m.get('application_name')
        if m.get('app_service_name') is not None:
            self.app_service_name = m.get('app_service_name')
        if m.get('cell_ids') is not None:
            self.cell_ids = m.get('cell_ids')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class BindAppserviceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UnbindAppserviceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        application_name: str = None,
        app_service_name: str = None,
        cell_ids: List[str] = None,
        workspace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称
        self.application_name = application_name
        # 应用服务名称
        self.app_service_name = app_service_name
        # 部署单元名称列表。 n代表第n个应用的名称，n从1开始，最大100。每个部署单元名称最大60个UTF-8字符。如果要输入多个部署单元，使用如下形式：cell_ids.1=RZ01A&cell_ids.2=RZ02B
        self.cell_ids = cell_ids
        # 工作空间名称
        self.workspace = workspace

    def validate(self):
        self.validate_required(self.application_name, 'application_name')
        self.validate_required(self.app_service_name, 'app_service_name')
        self.validate_required(self.cell_ids, 'cell_ids')
        self.validate_required(self.workspace, 'workspace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.application_name is not None:
            result['application_name'] = self.application_name
        if self.app_service_name is not None:
            result['app_service_name'] = self.app_service_name
        if self.cell_ids is not None:
            result['cell_ids'] = self.cell_ids
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('application_name') is not None:
            self.application_name = m.get('application_name')
        if m.get('app_service_name') is not None:
            self.app_service_name = m.get('app_service_name')
        if m.get('cell_ids') is not None:
            self.cell_ids = m.get('cell_ids')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UnbindAppserviceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateAppopsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        applications: List[Application] = None,
        auto_execution: bool = None,
        computers: List[str] = None,
        ops_action: str = None,
        ops_action_params: List[OpsParam] = None,
        ops_demension: str = None,
        title: str = None,
        workspace_group: str = None,
        context: str = None,
        group_strategy: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 执行运维操作的目标应用列表,可通过services指定应用下待运维的应用服务实例. 如果要指定多个应用, 使用如下形式: applications.1.name=app1&applications.2.name=app2&applications.2.services.1.name=app2-sv1&applications.2.services.1.workspace=shdev
        self.applications = applications
        # 是否自动执行运维单, 默认为false.当设置为true是,创建完成并初始化成功后会自动执行该运维单.
        self.auto_execution = auto_execution
        # 执行运维操作的目标机器id列表。如果要输入多个机器，使用如下形式：computers.1.id=000112367&computers.2.id=000112367
        self.computers = computers
        # 应用运维的操作类型，取值列表：ONLINE：上线应用，OFFLINE：下线应用，RESTART:重启应用，DEPLOY_STATIC_RESOURCE：部署静态资源
        self.ops_action = ops_action
        # 执行ops_action所需要的参数。
        self.ops_action_params = ops_action_params
        # 应用运维的维度，有两种取值：APPLICATION和MACHINE。设置为APPLICATION，表示在非应用服务环境下该应用执行该应用运维操作；设置为MACHINE，表示应用下的一台或多台机器执行该应用运维操作。
        self.ops_demension = ops_demension
        # 应用运维单标题
        self.title = title
        # 工作空间组名称
        self.workspace_group = workspace_group
        # Map<String, String> 序列化后字符串
        self.context = context
        # 机器分组策略，默认采用快速分组
        # QUICK         -     快速分组
        # ALL_ONE    - 共分一组
        # EACH_ONE - 每台一组
        # 
        self.group_strategy = group_strategy

    def validate(self):
        if self.applications:
            for k in self.applications:
                if k:
                    k.validate()
        self.validate_required(self.ops_action, 'ops_action')
        if self.ops_action_params:
            for k in self.ops_action_params:
                if k:
                    k.validate()
        self.validate_required(self.ops_demension, 'ops_demension')
        self.validate_required(self.title, 'title')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['applications'] = []
        if self.applications is not None:
            for k in self.applications:
                result['applications'].append(k.to_map() if k else None)
        if self.auto_execution is not None:
            result['auto_execution'] = self.auto_execution
        if self.computers is not None:
            result['computers'] = self.computers
        if self.ops_action is not None:
            result['ops_action'] = self.ops_action
        result['ops_action_params'] = []
        if self.ops_action_params is not None:
            for k in self.ops_action_params:
                result['ops_action_params'].append(k.to_map() if k else None)
        if self.ops_demension is not None:
            result['ops_demension'] = self.ops_demension
        if self.title is not None:
            result['title'] = self.title
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.context is not None:
            result['context'] = self.context
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.applications = []
        if m.get('applications') is not None:
            for k in m.get('applications'):
                temp_model = Application()
                self.applications.append(temp_model.from_map(k))
        if m.get('auto_execution') is not None:
            self.auto_execution = m.get('auto_execution')
        if m.get('computers') is not None:
            self.computers = m.get('computers')
        if m.get('ops_action') is not None:
            self.ops_action = m.get('ops_action')
        self.ops_action_params = []
        if m.get('ops_action_params') is not None:
            for k in m.get('ops_action_params'):
                temp_model = OpsParam()
                self.ops_action_params.append(temp_model.from_map(k))
        if m.get('ops_demension') is not None:
            self.ops_demension = m.get('ops_demension')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        return self


class CreateAppopsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        operation_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 创建完成的运维单id
        self.operation_id = operation_id

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class GetAppopsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 运维单id
        self.operation_id = operation_id

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class GetAppopsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        application_chains: List[OpsApplicationChain] = None,
        executor: str = None,
        ops_action: str = None,
        ops_dimension: str = None,
        status: str = None,
        title: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 此运维操作中所有被操作的应用详情，以操作链的形式体现
        self.application_chains = application_chains
        # 运维操作执行者
        self.executor = executor
        # 应用运维的操作类型，取值列表：ONLINE：上线应用，OFFLINE：下线应用，RESTART:重启应用，DEPLOY_STATIC_RESOURCE：部署静态资源
        self.ops_action = ops_action
        # 应用运维的维度，有两种取值：APPLICATION和MACHINE。设置为APPLICATION，表示对整个应用都执行该应用运维操作；设置为MACHINE，表示应用下的一台或多台机器执行改应用运维操作。
        self.ops_dimension = ops_dimension
        # 部署单状态。取值列表： INITING：初始化中； INIT_FAILED：初始化失败； INITED：初始化完成； EXECUTING：执行中； SUCCESS：执行成功； FAILED：执行失败； CANCELING：取消中； CANCELED：已取消
        self.status = status
        # 应用运维单标题
        self.title = title

    def validate(self):
        self.validate_required(self.application_chains, 'application_chains')
        if self.application_chains:
            for k in self.application_chains:
                if k:
                    k.validate()
        self.validate_required(self.executor, 'executor')
        self.validate_required(self.ops_action, 'ops_action')
        self.validate_required(self.ops_dimension, 'ops_dimension')
        self.validate_required(self.status, 'status')
        self.validate_required(self.title, 'title')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['application_chains'] = []
        if self.application_chains is not None:
            for k in self.application_chains:
                result['application_chains'].append(k.to_map() if k else None)
        if self.executor is not None:
            result['executor'] = self.executor
        if self.ops_action is not None:
            result['ops_action'] = self.ops_action
        if self.ops_dimension is not None:
            result['ops_dimension'] = self.ops_dimension
        if self.status is not None:
            result['status'] = self.status
        if self.title is not None:
            result['title'] = self.title
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.application_chains = []
        if m.get('application_chains') is not None:
            for k in m.get('application_chains'):
                temp_model = OpsApplicationChain()
                self.application_chains.append(temp_model.from_map(k))
        if m.get('executor') is not None:
            self.executor = m.get('executor')
        if m.get('ops_action') is not None:
            self.ops_action = m.get('ops_action')
        if m.get('ops_dimension') is not None:
            self.ops_dimension = m.get('ops_dimension')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('title') is not None:
            self.title = m.get('title')
        return self


class GetAppopsApplicationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        application_name: str = None,
        operation_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 待查询的应用名称，必须是运维单中包含的应用
        self.application_name = application_name
        # 运维单id
        self.operation_id = operation_id

    def validate(self):
        self.validate_required(self.application_name, 'application_name')
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.application_name is not None:
            result['application_name'] = self.application_name
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('application_name') is not None:
            self.application_name = m.get('application_name')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class GetAppopsApplicationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        groups: List[OpsGroup] = None,
        status: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 此应用下所有计算容器分组运维状态详情
        self.groups = groups
        # 应用当前运维状态。取值列表：INITING：初始化中；INIT_FAILED：初始化失败；INITED：初始化完成；EXECUTING：执行中；SUCCESS：执行成功；FAILED：执行失败
        self.status = status

    def validate(self):
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = OpsGroup()
                self.groups.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class StartAppopsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单或运维单time_series_id
        self.operation_id = operation_id
        # 操作人，lks1.23.0才支持
        self.operator = operator

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class StartAppopsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ReinitAppopsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 运维单id
        self.operation_id = operation_id

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class ReinitAppopsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CancelAppopsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        reason: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 运维单id
        self.operation_id = operation_id
        # 取消原因。长度不超过100个UTF-8字符
        self.reason = reason
        # 操作人账号，lks1.23.0才支持
        self.operator = operator

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')
        self.validate_required(self.reason, 'reason')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.reason is not None:
            result['reason'] = self.reason
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class CancelAppopsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class RetryAppopsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        operator: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 运维单id
        self.operation_id = operation_id
        # 操作人账号，lks1.23.0才支持
        self.operator = operator
        # 租户编码
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.operator is not None:
            result['operator'] = self.operator
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class RetryAppopsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetDeploymentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单id
        self.operation_id = operation_id

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class GetDeploymentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        executor: str = None,
        status: str = None,
        title: str = None,
        application_chains: List[OpsApplicationChain] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 操作执行者
        self.executor = executor
        # 
        # 发布单状态。取值列表：INITING：初始化中；INIT_FAILED：初始化失败；INITED：初始化完成；EXECUTING：执行中；SUCCEEDED：执行成功；FAILED：执行失败；CANCELING：取消中；CANCELED：已取消
        # 
        self.status = status
        # 标题
        self.title = title
        # 此发布部署操作中所有被操作的应用详情，以操作链的形式体现
        self.application_chains = application_chains

    def validate(self):
        self.validate_required(self.executor, 'executor')
        self.validate_required(self.status, 'status')
        self.validate_required(self.title, 'title')
        self.validate_required(self.application_chains, 'application_chains')
        if self.application_chains:
            for k in self.application_chains:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.executor is not None:
            result['executor'] = self.executor
        if self.status is not None:
            result['status'] = self.status
        if self.title is not None:
            result['title'] = self.title
        result['application_chains'] = []
        if self.application_chains is not None:
            for k in self.application_chains:
                result['application_chains'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('executor') is not None:
            self.executor = m.get('executor')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('title') is not None:
            self.title = m.get('title')
        self.application_chains = []
        if m.get('application_chains') is not None:
            for k in m.get('application_chains'):
                temp_model = OpsApplicationChain()
                self.application_chains.append(temp_model.from_map(k))
        return self


class GetDeploymentApplicationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        application_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单id
        self.operation_id = operation_id
        # 待查询的应用名称，必须是部署单中包含的应用
        self.application_name = application_name

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')
        self.validate_required(self.application_name, 'application_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.application_name is not None:
            result['application_name'] = self.application_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('application_name') is not None:
            self.application_name = m.get('application_name')
        return self


class GetDeploymentApplicationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        status: str = None,
        version: str = None,
        groups: List[OpsGroup] = None,
        pre_tasks: List[OpsPrePostTask] = None,
        post_tasks: List[OpsPrePostTask] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        # 应用当前部署状态。取值列表：INITING：初始化中；INIT_FAILED：初始化失败；INITED：初始化完成；EXECUTING：执行中；SUCCEEDED：执行成功；FAILED：执行失败
        # 
        self.status = status
        # 
        # 应用发布版本
        # 
        self.version = version
        # 此应用下所有计算容器分组部署状态详情
        self.groups = groups
        # 应用前置任务
        self.pre_tasks = pre_tasks
        # 应用后置任务
        self.post_tasks = post_tasks

    def validate(self):
        self.validate_required(self.status, 'status')
        self.validate_required(self.version, 'version')
        self.validate_required(self.groups, 'groups')
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()
        self.validate_required(self.pre_tasks, 'pre_tasks')
        if self.pre_tasks:
            for k in self.pre_tasks:
                if k:
                    k.validate()
        self.validate_required(self.post_tasks, 'post_tasks')
        if self.post_tasks:
            for k in self.post_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.status is not None:
            result['status'] = self.status
        if self.version is not None:
            result['version'] = self.version
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        result['pre_tasks'] = []
        if self.pre_tasks is not None:
            for k in self.pre_tasks:
                result['pre_tasks'].append(k.to_map() if k else None)
        result['post_tasks'] = []
        if self.post_tasks is not None:
            for k in self.post_tasks:
                result['post_tasks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('version') is not None:
            self.version = m.get('version')
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = OpsGroup()
                self.groups.append(temp_model.from_map(k))
        self.pre_tasks = []
        if m.get('pre_tasks') is not None:
            for k in m.get('pre_tasks'):
                temp_model = OpsPrePostTask()
                self.pre_tasks.append(temp_model.from_map(k))
        self.post_tasks = []
        if m.get('post_tasks') is not None:
            for k in m.get('post_tasks'):
                temp_model = OpsPrePostTask()
                self.post_tasks.append(temp_model.from_map(k))
        return self


class GetDeploymentRollbackRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        application_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单id
        self.operation_id = operation_id
        # 待查询的应用名称，必须是部署单中包含的应用
        self.application_name = application_name

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')
        self.validate_required(self.application_name, 'application_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.application_name is not None:
            result['application_name'] = self.application_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('application_name') is not None:
            self.application_name = m.get('application_name')
        return self


class GetDeploymentRollbackResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        status: str = None,
        version: str = None,
        groups: List[OpsGroup] = None,
        pre_tasks: List[OpsPrePostTask] = None,
        post_tasks: List[OpsPrePostTask] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        # 应用当前部署状态。取值列表：INITING：初始化中；INIT_FAILED：初始化失败；INITED：初始化完成；EXECUTING：执行中；SUCCEEDED：执行成功；FAILED：执行失败
        # 
        self.status = status
        # 应用回滚版本
        self.version = version
        # 此应用下所有计算容器分组部署状态详情
        self.groups = groups
        # 应用前置任务
        self.pre_tasks = pre_tasks
        # 应用后置任务
        self.post_tasks = post_tasks

    def validate(self):
        self.validate_required(self.status, 'status')
        self.validate_required(self.version, 'version')
        self.validate_required(self.groups, 'groups')
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()
        self.validate_required(self.pre_tasks, 'pre_tasks')
        if self.pre_tasks:
            for k in self.pre_tasks:
                if k:
                    k.validate()
        self.validate_required(self.post_tasks, 'post_tasks')
        if self.post_tasks:
            for k in self.post_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.status is not None:
            result['status'] = self.status
        if self.version is not None:
            result['version'] = self.version
        result['groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['groups'].append(k.to_map() if k else None)
        result['pre_tasks'] = []
        if self.pre_tasks is not None:
            for k in self.pre_tasks:
                result['pre_tasks'].append(k.to_map() if k else None)
        result['post_tasks'] = []
        if self.post_tasks is not None:
            for k in self.post_tasks:
                result['post_tasks'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('version') is not None:
            self.version = m.get('version')
        self.groups = []
        if m.get('groups') is not None:
            for k in m.get('groups'):
                temp_model = OpsGroup()
                self.groups.append(temp_model.from_map(k))
        self.pre_tasks = []
        if m.get('pre_tasks') is not None:
            for k in m.get('pre_tasks'):
                temp_model = OpsPrePostTask()
                self.pre_tasks.append(temp_model.from_map(k))
        self.post_tasks = []
        if m.get('post_tasks') is not None:
            for k in m.get('post_tasks'):
                temp_model = OpsPrePostTask()
                self.post_tasks.append(temp_model.from_map(k))
        return self


class QueryDeploymentRollbackableRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        application_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单id
        self.operation_id = operation_id
        # 待查询的应用名称，必须是部署单中包含的应用
        self.application_name = application_name

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')
        self.validate_required(self.application_name, 'application_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.application_name is not None:
            result['application_name'] = self.application_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('application_name') is not None:
            self.application_name = m.get('application_name')
        return self


class QueryDeploymentRollbackableResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        versions: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 可回滚的版本
        self.versions = versions

    def validate(self):
        self.validate_required(self.versions, 'versions')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.versions is not None:
            result['versions'] = self.versions
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('versions') is not None:
            self.versions = m.get('versions')
        return self


class RollbackDeploymentApplicationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        application_name: str = None,
        version_no: str = None,
        group_strategy: str = None,
        group_count: int = None,
        reason: str = None,
        operator_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单id
        self.operation_id = operation_id
        # 待回滚的应用名称，必须是部署单中包含的应用
        self.application_name = application_name
        # 应用的回滚版本，如果不指定，默认回滚到最近一次发布成功的版本
        self.version_no = version_no
        # 回滚时的分组策略，取值为：
        # QUICK：快速分组；
        # EACH_ONE：每台一组；
        # UNIT：按逻辑单元分组；
        # CELL：按部署单元分组；
        # 默认为QUICK
        # 
        self.group_strategy = group_strategy
        # 分组数，默认为3
        self.group_count = group_count
        # 回滚原因
        self.reason = reason
        # 操作人
        self.operator_name = operator_name

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')
        self.validate_required(self.application_name, 'application_name')
        self.validate_required(self.reason, 'reason')
        self.validate_required(self.operator_name, 'operator_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.application_name is not None:
            result['application_name'] = self.application_name
        if self.version_no is not None:
            result['version_no'] = self.version_no
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        if self.group_count is not None:
            result['group_count'] = self.group_count
        if self.reason is not None:
            result['reason'] = self.reason
        if self.operator_name is not None:
            result['operator_name'] = self.operator_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('application_name') is not None:
            self.application_name = m.get('application_name')
        if m.get('version_no') is not None:
            self.version_no = m.get('version_no')
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        if m.get('group_count') is not None:
            self.group_count = m.get('group_count')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('operator_name') is not None:
            self.operator_name = m.get('operator_name')
        return self


class RollbackDeploymentApplicationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class PushFlowRouteclientRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        flow_type: str = None,
        isomerism_sites: List[str] = None,
        operator_name: str = None,
        push_type: str = None,
        workspace_group: str = None,
        unit_flows: List[UnitFlow] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 流量类型
        # NORMAL：正常流量
        # PRESS：压测流量
        self.flow_type = flow_type
        # 异构机房列表
        self.isomerism_sites = isomerism_sites
        # 操作人
        self.operator_name = operator_name
        # 推送类型
        # DRM：DRM推送
        # JMX：JMX推送
        # SPANNER：SPANNER推送
        self.push_type = push_type
        # 工作空间
        self.workspace_group = workspace_group
        # 部署单元组的流量规则
        self.unit_flows = unit_flows

    def validate(self):
        self.validate_required(self.flow_type, 'flow_type')
        self.validate_required(self.operator_name, 'operator_name')
        self.validate_required(self.push_type, 'push_type')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.unit_flows, 'unit_flows')
        if self.unit_flows:
            for k in self.unit_flows:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.flow_type is not None:
            result['flow_type'] = self.flow_type
        if self.isomerism_sites is not None:
            result['isomerism_sites'] = self.isomerism_sites
        if self.operator_name is not None:
            result['operator_name'] = self.operator_name
        if self.push_type is not None:
            result['push_type'] = self.push_type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        result['unit_flows'] = []
        if self.unit_flows is not None:
            for k in self.unit_flows:
                result['unit_flows'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('flow_type') is not None:
            self.flow_type = m.get('flow_type')
        if m.get('isomerism_sites') is not None:
            self.isomerism_sites = m.get('isomerism_sites')
        if m.get('operator_name') is not None:
            self.operator_name = m.get('operator_name')
        if m.get('push_type') is not None:
            self.push_type = m.get('push_type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        self.unit_flows = []
        if m.get('unit_flows') is not None:
            for k in m.get('unit_flows'):
                temp_model = UnitFlow()
                self.unit_flows.append(temp_model.from_map(k))
        return self


class PushFlowRouteclientResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateFederationNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        labels: List[Label] = None,
        name: str = None,
        workspace_group_name: str = None,
        annotations: List[Annotation] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # k8s resource labels
        self.labels = labels
        # FedNamespace名称
        self.name = name
        # workspaceGroup名称
        self.workspace_group_name = workspace_group_name
        # annotation,可以用来存放description等其他字段
        self.annotations = annotations

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        result['annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['annotations'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        self.annotations = []
        if m.get('annotations') is not None:
            for k in m.get('annotations'):
                temp_model = Annotation()
                self.annotations.append(temp_model.from_map(k))
        return self


class CreateFederationNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: FedNamespace = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # fed namespace info
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = FedNamespace()
            self.data = temp_model.from_map(m['data'])
        return self


class UpdateFederationNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        labels: List[Label] = None,
        name: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # fed namespace labels
        self.labels = labels
        # Fed Namespace name
        self.name = name
        # workspace group name
        self.workspace_group_name = workspace_group_name

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class UpdateFederationNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: FedNamespace = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # fed namespace data
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = FedNamespace()
            self.data = temp_model.from_map(m['data'])
        return self


class GetFederationNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # fed namespace name
        self.name = name
        # workspace group name
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class GetFederationNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: FedNamespace = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # fed namespace info
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = FedNamespace()
            self.data = temp_model.from_map(m['data'])
        return self


class DeleteFederationNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # fed namespace name
        self.name = name
        # workspaceGroup Name
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class DeleteFederationNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 删除操作成功或失败
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CreateFederationConfigmapRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cells: List[str] = None,
        data: List[ConfigMapData] = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
        overrides: FedConfigMapOverrideList = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # Cell name list
        self.cells = cells
        # FedConfigMap data
        self.data = data
        # FedConfigMap labels
        self.labels = labels
        # FedConfigMap name
        self.name = name
        # Federation ConfigMap namespace
        self.namespace = namespace
        # FedCofigmap Cluster Overrides
        self.overrides = overrides
        # workspace group 名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.cells, 'cells')
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        if self.overrides:
            self.overrides.validate()
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cells is not None:
            result['cells'] = self.cells
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.overrides is not None:
            result['overrides'] = self.overrides.to_map()
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ConfigMapData()
                self.data.append(temp_model.from_map(k))
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('overrides') is not None:
            temp_model = FedConfigMapOverrideList()
            self.overrides = temp_model.from_map(m['overrides'])
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class CreateFederationConfigmapResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        configmap: FedConfigmap = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # FedConfigMap 数据
        self.configmap = configmap

    def validate(self):
        if self.configmap:
            self.configmap.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.configmap is not None:
            result['configmap'] = self.configmap.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('configmap') is not None:
            temp_model = FedConfigmap()
            self.configmap = temp_model.from_map(m['configmap'])
        return self


class UpdateFederationConfigmapRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cells: List[str] = None,
        data: List[ConfigMapData] = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
        overrides: FedConfigMapOverrideList = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cell list
        self.cells = cells
        # FedConfigMap data
        self.data = data
        # FedConfigMap labels
        self.labels = labels
        # FedConfigMap name
        self.name = name
        # FedConfigMap命名空间
        self.namespace = namespace
        # FedConfigMap overrides
        self.overrides = overrides
        # workspaceGroup名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.cells, 'cells')
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        if self.overrides:
            self.overrides.validate()
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cells is not None:
            result['cells'] = self.cells
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.overrides is not None:
            result['overrides'] = self.overrides.to_map()
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ConfigMapData()
                self.data.append(temp_model.from_map(k))
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('overrides') is not None:
            temp_model = FedConfigMapOverrideList()
            self.overrides = temp_model.from_map(m['overrides'])
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class UpdateFederationConfigmapResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        configmap: FedConfigmap = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # fedconfigmap data
        self.configmap = configmap

    def validate(self):
        if self.configmap:
            self.configmap.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.configmap is not None:
            result['configmap'] = self.configmap.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('configmap') is not None:
            temp_model = FedConfigmap()
            self.configmap = temp_model.from_map(m['configmap'])
        return self


class GetFederationConfigmapRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        namespace: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # FedConfigmap name
        self.name = name
        # 所属命名空间名称。
        self.namespace = namespace
        # workspaceGroup 名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class GetFederationConfigmapResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        configmap: FedConfigmap = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # FedConfigMap获取结果
        self.configmap = configmap

    def validate(self):
        if self.configmap:
            self.configmap.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.configmap is not None:
            result['configmap'] = self.configmap.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('configmap') is not None:
            temp_model = FedConfigmap()
            self.configmap = temp_model.from_map(m['configmap'])
        return self


class DeleteFederationConfigmapRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group_name: str = None,
        namespace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # FedConfigMap name
        self.name = name
        # workspaceGroupName
        self.workspace_group_name = workspace_group_name
        # 所属命名空间名称。
        self.namespace = namespace

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class DeleteFederationConfigmapResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 删除结果
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class ListFederationConfigmapRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        label_selector: str = None,
        namespace: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # List labelSelector
        self.label_selector = label_selector
        # aaaa
        self.namespace = namespace
        # workspace group name
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.label_selector is not None:
            result['label_selector'] = self.label_selector
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('label_selector') is not None:
            self.label_selector = m.get('label_selector')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class ListFederationConfigmapResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        configmaps: List[FedConfigmap] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # FedConfigMap List
        self.configmaps = configmaps

    def validate(self):
        if self.configmaps:
            for k in self.configmaps:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['configmaps'] = []
        if self.configmaps is not None:
            for k in self.configmaps:
                result['configmaps'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.configmaps = []
        if m.get('configmaps') is not None:
            for k in m.get('configmaps'):
                temp_model = FedConfigmap()
                self.configmaps.append(temp_model.from_map(k))
        return self


class ListFederationNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        label_selector: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # k8s resource label selector
        self.label_selector = label_selector
        # workspace group名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.label_selector is not None:
            result['label_selector'] = self.label_selector
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('label_selector') is not None:
            self.label_selector = m.get('label_selector')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class ListFederationNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[FedNamespace] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # fed namespace list
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = FedNamespace()
                self.data.append(temp_model.from_map(k))
        return self


class QueryContainerserviceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        deployment_status: List[str] = None,
        metadata_status: List[str] = None,
        name: str = None,
        namespace: str = None,
        page_number: int = None,
        page_size: int = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属应用名称
        self.app_name = app_name
        # 容器服务部署状态。取值可以由多个部署状态组成一个JSON数组，不同状态之间用绊脚逗号(,)隔开，取值范围：
        # . WAITING_FOR_DEPLOY: 待发布
        # . INITIALIZING: 初始化中
        # . INITIALIZED: 初始化完成
        # . INITIALIZE_FAILED: 初始化失败
        # . CONFIRM_WAITING: 待确认
        # . CONFIRMED: 已确认
        # . EXECUTING: 发布中
        # . PAUSED: 暂停
        # . CANCELING: 取消中
        # . CANCELED: 已取消
        # . ROLLBACKING: 回滚中
        # . ROLLBACK_PAUSED: 回滚暂停
        # . ROLLBACKED: 已回滚
        # . SUCCEEDED: 发布完成
        # . FAILED: 发布失败
        # . DELETING: 删除中
        # . DELETE_FAILED: 删除失败
        self.deployment_status = deployment_status
        # 容器服务元数据状态。取值可以由多个元数据状态组成一个JSON数组，不同状态之间用半角逗号（,）隔开。状态取值范围：
        # . DRAFTED: 草稿
        # . CREATING: 创建中
        # . CREATED: 已创建
        # . UPDATING: 更新中
        # . UPDATED: 已更新
        # . DELETING: 删除中
        # . DELETED: 已删除
        # . DEPLOYED: 已发布
        # . CREATE_FAILED: 创建失败
        # . UPDATE_FAILED: 更新失败
        # . DELETE_FAILED: 删除失败
        self.metadata_status = metadata_status
        # 容器应用服务名称，支持使用通配符*进行模糊搜索。
        self.name = name
        # 当前命名空间名称。
        self.namespace = namespace
        # 实例状态列表的页码。起始值：1。默认值：1 。
        self.page_number = page_number
        # 分页查询时设置的每页行数。最大值：100。默认值：10。
        self.page_size = page_size
        # 当前工作空间组名称。
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.deployment_status is not None:
            result['deployment_status'] = self.deployment_status
        if self.metadata_status is not None:
            result['metadata_status'] = self.metadata_status
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('deployment_status') is not None:
            self.deployment_status = m.get('deployment_status')
        if m.get('metadata_status') is not None:
            self.metadata_status = m.get('metadata_status')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryContainerserviceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        container_service_list: List[ContainerServiceBasicInfo] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 容器应用服务列表。
        self.container_service_list = container_service_list
        # 实例列表的页码。
        self.page_number = page_number
        # 输入时设置的每页行数。
        self.page_size = page_size
        # 查询到的容器应用服务总数。
        self.total_count = total_count

    def validate(self):
        if self.container_service_list:
            for k in self.container_service_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['container_service_list'] = []
        if self.container_service_list is not None:
            for k in self.container_service_list:
                result['container_service_list'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.container_service_list = []
        if m.get('container_service_list') is not None:
            for k in m.get('container_service_list'):
                temp_model = ContainerServiceBasicInfo()
                self.container_service_list.append(temp_model.from_map(k))
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class ListMulticlusterMasterclusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace group name
        self.workspace_group = workspace_group

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListMulticlusterMasterclusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[MasterClustersOfZone] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # master clusters of different zones
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = MasterClustersOfZone()
                self.data.append(temp_model.from_map(k))
        return self


class InitMulticlusterClusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        fed_namespace: str = None,
        master_cluster_info: List[MasterCluster] = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # federation namespace
        self.fed_namespace = fed_namespace
        # master cluster info
        self.master_cluster_info = master_cluster_info
        # workspace group name
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.master_cluster_info, 'master_cluster_info')
        if self.master_cluster_info:
            for k in self.master_cluster_info:
                if k:
                    k.validate()
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.fed_namespace is not None:
            result['fed_namespace'] = self.fed_namespace
        result['master_cluster_info'] = []
        if self.master_cluster_info is not None:
            for k in self.master_cluster_info:
                result['master_cluster_info'].append(k.to_map() if k else None)
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('fed_namespace') is not None:
            self.fed_namespace = m.get('fed_namespace')
        self.master_cluster_info = []
        if m.get('master_cluster_info') is not None:
            for k in m.get('master_cluster_info'):
                temp_model = MasterCluster()
                self.master_cluster_info.append(temp_model.from_map(k))
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class InitMulticlusterClusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # import cluster success or false
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class ListMulticlusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace group name
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListMulticlusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[ClusterInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # minion cluster infos
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ClusterInfo()
                self.data.append(temp_model.from_map(k))
        return self


class DeleteContainerserviceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        drafted_revision: str = None,
        drafted_time: str = None,
        name: str = None,
        namespace: str = None,
        operator: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 最近一次草稿版本。
        self.drafted_revision = drafted_revision
        # 最近一次草稿时间
        self.drafted_time = drafted_time
        # 容器应用服务名称。
        self.name = name
        # 当前命名空间名称。
        self.namespace = namespace
        # 提交人。
        self.operator = operator
        # 所属工作空间组名称
        self.workspace_group = workspace_group

    def validate(self):
        if self.drafted_time is not None:
            self.validate_pattern(self.drafted_time, 'drafted_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.drafted_revision is not None:
            result['drafted_revision'] = self.drafted_revision
        if self.drafted_time is not None:
            result['drafted_time'] = self.drafted_time
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operator is not None:
            result['operator'] = self.operator
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('drafted_revision') is not None:
            self.drafted_revision = m.get('drafted_revision')
        if m.get('drafted_time') is not None:
            self.drafted_time = m.get('drafted_time')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class DeleteContainerserviceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateContainerserviceDeploymentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_services: SontainerServicesList = None,
        is_auto_execute: bool = None,
        namespace: str = None,
        ops_type: str = None,
        release_plan_unique_id: str = None,
        tenant_name: str = None,
        title: str = None,
        workspace_group: str = None,
        assignee_ids: List[str] = None,
        operator: str = None,
        gray_release_config: GrayReleaseConfig = None,
        traffic_container_services: List[str] = None,
        cell_names: List[str] = None,
        emergent: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器服务列表。
        self.container_services = container_services
        # 是否自动执行，默认false
        self.is_auto_execute = is_auto_execute
        # 所属命名空间
        self.namespace = namespace
        # 默认CLOUD_NATIVE_GROUP_RELEASE
        self.ops_type = ops_type
        # operator调用专用字段，ReleasePlan唯一标识
        self.release_plan_unique_id = release_plan_unique_id
        # tenant 名字，operator调用专用字段
        self.tenant_name = tenant_name
        # 发布单名称。
        self.title = title
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # 审批人账号id
        self.assignee_ids = assignee_ids
        # 操作人账号，lks1.23.0才支持
        self.operator = operator
        # 灰度发布的参数，仅当ops_type为GRAY_RELEASE时生效
        self.gray_release_config = gray_release_config
        # 引流应用服务列表, 部署单元蓝绿专用
        self.traffic_container_services = traffic_container_services
        # cell列表，部署单元蓝绿专用，按顺序发布
        self.cell_names = cell_names
        # 是否紧急发布，目前会自动跳过变更核心
        self.emergent = emergent

    def validate(self):
        self.validate_required(self.container_services, 'container_services')
        if self.container_services:
            self.container_services.validate()
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.title, 'title')
        self.validate_required(self.workspace_group, 'workspace_group')
        if self.gray_release_config:
            self.gray_release_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_services is not None:
            result['container_services'] = self.container_services.to_map()
        if self.is_auto_execute is not None:
            result['is_auto_execute'] = self.is_auto_execute
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.ops_type is not None:
            result['ops_type'] = self.ops_type
        if self.release_plan_unique_id is not None:
            result['release_plan_unique_id'] = self.release_plan_unique_id
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.title is not None:
            result['title'] = self.title
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.assignee_ids is not None:
            result['assignee_ids'] = self.assignee_ids
        if self.operator is not None:
            result['operator'] = self.operator
        if self.gray_release_config is not None:
            result['gray_release_config'] = self.gray_release_config.to_map()
        if self.traffic_container_services is not None:
            result['traffic_container_services'] = self.traffic_container_services
        if self.cell_names is not None:
            result['cell_names'] = self.cell_names
        if self.emergent is not None:
            result['emergent'] = self.emergent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_services') is not None:
            temp_model = SontainerServicesList()
            self.container_services = temp_model.from_map(m['container_services'])
        if m.get('is_auto_execute') is not None:
            self.is_auto_execute = m.get('is_auto_execute')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('ops_type') is not None:
            self.ops_type = m.get('ops_type')
        if m.get('release_plan_unique_id') is not None:
            self.release_plan_unique_id = m.get('release_plan_unique_id')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('assignee_ids') is not None:
            self.assignee_ids = m.get('assignee_ids')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('gray_release_config') is not None:
            temp_model = GrayReleaseConfig()
            self.gray_release_config = temp_model.from_map(m['gray_release_config'])
        if m.get('traffic_container_services') is not None:
            self.traffic_container_services = m.get('traffic_container_services')
        if m.get('cell_names') is not None:
            self.cell_names = m.get('cell_names')
        if m.get('emergent') is not None:
            self.emergent = m.get('emergent')
        return self


class CreateContainerserviceDeploymentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        operation_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 创建完成的部署单id
        self.operation_id = operation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class CreateFederationSecretRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cells: List[str] = None,
        data: List[SecretData] = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
        overrides: FedSecretOverrideList = None,
        type: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cell name list
        self.cells = cells
        # FedSecret data
        # 
        self.data = data
        # FedSecret labels
        # 
        self.labels = labels
        # FedSecret name
        # 
        self.name = name
        # Federation Secret namespace
        self.namespace = namespace
        # FedSecret Cluster Overrides
        # 
        self.overrides = overrides
        # Fed Secret type
        self.type = type
        # workspace group 名称
        # 
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.cells, 'cells')
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        if self.overrides:
            self.overrides.validate()
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cells is not None:
            result['cells'] = self.cells
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.overrides is not None:
            result['overrides'] = self.overrides.to_map()
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = SecretData()
                self.data.append(temp_model.from_map(k))
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('overrides') is not None:
            temp_model = FedSecretOverrideList()
            self.overrides = temp_model.from_map(m['overrides'])
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class CreateFederationSecretResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        secret: FedSecret = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # FedSecret 数据
        # 
        self.secret = secret

    def validate(self):
        if self.secret:
            self.secret.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.secret is not None:
            result['secret'] = self.secret.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('secret') is not None:
            temp_model = FedSecret()
            self.secret = temp_model.from_map(m['secret'])
        return self


class GetFederationSecretRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        namespace: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # FedSecretname
        self.name = name
        # 所属命名空间名称。
        self.namespace = namespace
        # workspaceGroup 名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class GetFederationSecretResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        secret: FedSecret = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # FedSecret获取结果
        # 
        self.secret = secret

    def validate(self):
        if self.secret:
            self.secret.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.secret is not None:
            result['secret'] = self.secret.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('secret') is not None:
            temp_model = FedSecret()
            self.secret = temp_model.from_map(m['secret'])
        return self


class DeleteFederationSecretRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group_name: str = None,
        namespace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # FedSecret name
        # 
        self.name = name
        # workspaceGroupName
        self.workspace_group_name = workspace_group_name
        # 所属命名空间名称。
        self.namespace = namespace

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class DeleteFederationSecretResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 删除结果
        # 
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class UpdateFederationSecretRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cells: List[str] = None,
        data: List[SecretData] = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
        overrides: FedSecretOverrideList = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cell list
        self.cells = cells
        # FedSecret data
        # 
        self.data = data
        # FedSecret labels
        # 
        self.labels = labels
        # FedSecret name
        # 
        self.name = name
        # FedSecret命名空间
        # 
        self.namespace = namespace
        # FedSecret overrides
        # 
        self.overrides = overrides
        # workspaceGroup名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.cells, 'cells')
        self.validate_required(self.data, 'data')
        if self.data:
            for k in self.data:
                if k:
                    k.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        if self.overrides:
            self.overrides.validate()
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cells is not None:
            result['cells'] = self.cells
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.overrides is not None:
            result['overrides'] = self.overrides.to_map()
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = SecretData()
                self.data.append(temp_model.from_map(k))
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('overrides') is not None:
            temp_model = FedSecretOverrideList()
            self.overrides = temp_model.from_map(m['overrides'])
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class UpdateFederationSecretResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        secret: FedSecret = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # fedsecret data
        # 
        self.secret = secret

    def validate(self):
        if self.secret:
            self.secret.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.secret is not None:
            result['secret'] = self.secret.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('secret') is not None:
            temp_model = FedSecret()
            self.secret = temp_model.from_map(m['secret'])
        return self


class ListFederationSecretRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        label_selector: str = None,
        namespace: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # List labelSelector
        # 
        self.label_selector = label_selector
        # antcloud
        self.namespace = namespace
        # workspace group name
        # 
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.label_selector is not None:
            result['label_selector'] = self.label_selector
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('label_selector') is not None:
            self.label_selector = m.get('label_selector')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class ListFederationSecretResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        secret_list: List[FedSecret] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # FedSecret List
        self.secret_list = secret_list

    def validate(self):
        if self.secret_list:
            for k in self.secret_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['secret_list'] = []
        if self.secret_list is not None:
            for k in self.secret_list:
                result['secret_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.secret_list = []
        if m.get('secret_list') is not None:
            for k in m.get('secret_list'):
                temp_model = FedSecret()
                self.secret_list.append(temp_model.from_map(k))
        return self


class DescribeContainerserviceRevisionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        namespace: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器服务名称。
        self.name = name
        # 命名空间名称。
        self.namespace = namespace
        # 所属工作空间组名称。
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class DescribeContainerserviceRevisionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        revision: ContainerServiceRevision = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 容器服务版本信息。
        self.revision = revision

    def validate(self):
        if self.revision:
            self.revision.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.revision is not None:
            result['revision'] = self.revision.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('revision') is not None:
            temp_model = ContainerServiceRevision()
            self.revision = temp_model.from_map(m['revision'])
        return self


class GetContainerserviceRevisionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        revision: str = None,
        workspace_group: str = None,
        namespace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器应用服务名称。
        self.name = name
        # 版本号。
        self.revision = revision
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # fed namespace
        self.namespace = namespace

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.revision, 'revision')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.revision is not None:
            result['revision'] = self.revision
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class GetContainerserviceRevisionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        revision: ContainerServiceRevision = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 容器服务版本信息。
        self.revision = revision

    def validate(self):
        if self.revision:
            self.revision.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.revision is not None:
            result['revision'] = self.revision.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('revision') is not None:
            temp_model = ContainerServiceRevision()
            self.revision = temp_model.from_map(m['revision'])
        return self


class QueryContainerserviceRevisionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        deployment_status: List[str] = None,
        metadata_status: List[str] = None,
        name: str = None,
        namespace: str = None,
        page_number: int = None,
        page_size: int = None,
        workspace_group: str = None,
        revision: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 取值范围： . WAITING_FOR_DEPLOY: 待发布 . INITIALIZING: 初始化中 . INITIALIZED: 初始化完成 . INITIALIZE_FAILED: 初始化失败 . CONFIRM_WAITING: 待确认 . CONFIRMED: 已确认 . EXECUTING: 发布中 . PAUSED: 暂停 . CANCELING: 取消中 . CANCELED: 已取消 . ROLLBACKING: 回滚中 . ROLLBACK_PAUSED: 回滚暂停 . ROLLBACKED: 已回滚 . SUCCEEDED: 发布完成 . FAILED: 发布失败 . DELETING: 删除中 . DELETE_FAILED: 删除失败
        self.deployment_status = deployment_status
        # 状态取值范围： . DRAFTED: 草稿 . CREATING: 创建中 . CREATED: 已创建 . UPDATING: 更新中 . UPDATED: 已更新 . DELETING: 删除中 . DELETED: 已删除 . DEPLOYED: 已发布 . CREATE_FAILED: 创建失败 . UPDATE_FAILED: 更新失败 . DELETE_FAILED: 删除失败
        self.metadata_status = metadata_status
        # 容器应用服务名称。
        self.name = name
        # 命名空间名称。
        self.namespace = namespace
        # 容器服务版本列表的页码。起始值：1。默认值：1 。
        self.page_number = page_number
        # 分页查询时设置的每页行数。最大值：100。默认值：10。
        self.page_size = page_size
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # 可以根据版本号模糊搜索，lks1.25.0开始支持
        self.revision = revision

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.deployment_status is not None:
            result['deployment_status'] = self.deployment_status
        if self.metadata_status is not None:
            result['metadata_status'] = self.metadata_status
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.revision is not None:
            result['revision'] = self.revision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('deployment_status') is not None:
            self.deployment_status = m.get('deployment_status')
        if m.get('metadata_status') is not None:
            self.metadata_status = m.get('metadata_status')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        return self


class QueryContainerserviceRevisionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        page_number: int = None,
        page_size: int = None,
        revision_list: List[ContainerServiceRevision] = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 版本列表的页码。
        self.page_number = page_number
        # 输入时设置的每页行数。
        self.page_size = page_size
        # 容器服务版本列表。
        self.revision_list = revision_list
        # 查询到的容器应用版本总数。
        self.total_count = total_count

    def validate(self):
        if self.revision_list:
            for k in self.revision_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        result['revision_list'] = []
        if self.revision_list is not None:
            for k in self.revision_list:
                result['revision_list'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        self.revision_list = []
        if m.get('revision_list') is not None:
            for k in m.get('revision_list'):
                temp_model = ContainerServiceRevision()
                self.revision_list.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class UpdateContainerserviceRevisionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        name: str = None,
        revision: str = None,
        remark: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # 容器应用服务名称。
        self.name = name
        # 容器应用服务版本号。
        self.revision = revision
        # 版本备注信息。
        self.remark = remark

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.name, 'name')
        self.validate_required(self.revision, 'revision')
        self.validate_required(self.remark, 'remark')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.name is not None:
            result['name'] = self.name
        if self.revision is not None:
            result['revision'] = self.revision
        if self.remark is not None:
            result['remark'] = self.remark
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('remark') is not None:
            self.remark = m.get('remark')
        return self


class UpdateContainerserviceRevisionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateContainerserviceImageRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        image: str = None,
        name: str = None,
        namespace: str = None,
        operator: str = None,
        revision: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 更新镜像的完整地址
        self.image = image
        # 容器应用服务名称。
        self.name = name
        # 容器服务所在命名空间
        self.namespace = namespace
        # 操作人。
        self.operator = operator
        # 容器应用服务版本。
        self.revision = revision
        # 所属工作空间组名称。
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.image, 'image')
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.revision, 'revision')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.image is not None:
            result['image'] = self.image
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operator is not None:
            result['operator'] = self.operator
        if self.revision is not None:
            result['revision'] = self.revision
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateContainerserviceImageResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        revision: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 更新后的容器应用服务版本号。
        self.revision = revision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.revision is not None:
            result['revision'] = self.revision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        return self


class UpdateContainerserviceReplicasRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        fixed_replica_elastic_config: FixedReplicaElasticConfig = None,
        name: str = None,
        namespace: str = None,
        operator: str = None,
        revision: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 扩缩容replica详情
        self.fixed_replica_elastic_config = fixed_replica_elastic_config
        # 容器应用服务名称。
        self.name = name
        # namespace
        self.namespace = namespace
        # 操作人
        self.operator = operator
        # 容器应用服务版本号。
        self.revision = revision
        # 所属工作空间组名称。
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.fixed_replica_elastic_config, 'fixed_replica_elastic_config')
        if self.fixed_replica_elastic_config:
            self.fixed_replica_elastic_config.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.revision, 'revision')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.fixed_replica_elastic_config is not None:
            result['fixed_replica_elastic_config'] = self.fixed_replica_elastic_config.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operator is not None:
            result['operator'] = self.operator
        if self.revision is not None:
            result['revision'] = self.revision
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('fixed_replica_elastic_config') is not None:
            temp_model = FixedReplicaElasticConfig()
            self.fixed_replica_elastic_config = temp_model.from_map(m['fixed_replica_elastic_config'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateContainerserviceReplicasResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        operation_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 创建完成的部署单id
        self.operation_id = operation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class CreateContainerserviceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        client_token: str = None,
        config: ContainerServiceConfig = None,
        description: str = None,
        name: str = None,
        namespace: str = None,
        operator: str = None,
        owner_id: str = None,
        owner_name: str = None,
        workspace_group: str = None,
        app_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属应用名称。
        self.app_name = app_name
        # 必填，且不能重复。保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。
        self.client_token = client_token
        # 容器服务配置。
        self.config = config
        # 容器服务描述
        self.description = description
        # 容器服务名称。
        self.name = name
        # 所属命名空间名称。
        self.namespace = namespace
        # 操作人iam账号名，通过pop调用时该参数无效。
        self.operator = operator
        # owner_id（废弃）
        self.owner_id = owner_id
        # owner_name（废弃）
        self.owner_name = owner_name
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # 应用appid
        self.app_id = app_id

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.config, 'config')
        if self.config:
            self.config.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.app_id, 'app_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.config is not None:
            result['config'] = self.config.to_map()
        if self.description is not None:
            result['description'] = self.description
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operator is not None:
            result['operator'] = self.operator
        if self.owner_id is not None:
            result['owner_id'] = self.owner_id
        if self.owner_name is not None:
            result['owner_name'] = self.owner_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.app_id is not None:
            result['app_id'] = self.app_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('config') is not None:
            temp_model = ContainerServiceConfig()
            self.config = temp_model.from_map(m['config'])
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('owner_id') is not None:
            self.owner_id = m.get('owner_id')
        if m.get('owner_name') is not None:
            self.owner_name = m.get('owner_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        return self


class CreateContainerserviceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        revision: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 容器服务版本号。
        self.revision = revision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.revision is not None:
            result['revision'] = self.revision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        return self


class SaveContainerserviceRevisionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class SaveContainerserviceRevisionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateContainerserviceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_id: str = None,
        app_name: str = None,
        client_token: str = None,
        config: ContainerServiceConfig = None,
        name: str = None,
        namespace: str = None,
        operator: str = None,
        owner_id: str = None,
        owner_name: str = None,
        workspace_group: str = None,
        description: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app id
        self.app_id = app_id
        # 所属应用名称。
        self.app_name = app_name
        # 必填：保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。
        self.client_token = client_token
        # 容器服务配置。
        # 
        self.config = config
        # 应用服务名称
        self.name = name
        # 命名空间
        self.namespace = namespace
        # 操作人账号
        self.operator = operator
        # 应用负责人id
        self.owner_id = owner_id
        # 应用负责人名称
        self.owner_name = owner_name
        # 工作环境组
        self.workspace_group = workspace_group
        # 描述
        self.description = description

    def validate(self):
        self.validate_required(self.app_id, 'app_id')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.config, 'config')
        if self.config:
            self.config.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_id is not None:
            result['app_id'] = self.app_id
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.config is not None:
            result['config'] = self.config.to_map()
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operator is not None:
            result['operator'] = self.operator
        if self.owner_id is not None:
            result['owner_id'] = self.owner_id
        if self.owner_name is not None:
            result['owner_name'] = self.owner_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.description is not None:
            result['description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_id') is not None:
            self.app_id = m.get('app_id')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('config') is not None:
            temp_model = ContainerServiceConfig()
            self.config = temp_model.from_map(m['config'])
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('owner_id') is not None:
            self.owner_id = m.get('owner_id')
        if m.get('owner_name') is not None:
            self.owner_name = m.get('owner_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('description') is not None:
            self.description = m.get('description')
        return self


class UpdateContainerserviceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        revision: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # container service版本号
        self.revision = revision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.revision is not None:
            result['revision'] = self.revision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        return self


class ExistContainerserviceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        namespace: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # 所属命名空间名称。
        self.namespace = namespace
        # 容器服务名称。
        self.name = name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ExistContainerserviceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        exist: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 容器服务是否存在。
        # 取值：true | false
        self.exist = exist

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.exist is not None:
            result['exist'] = self.exist
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('exist') is not None:
            self.exist = m.get('exist')
        return self


class GetClusterBasicinfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name
        self.cluster_name = cluster_name

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        return self


class GetClusterBasicinfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell_infos: List[CellInfo] = None,
        created_time: str = None,
        display_name: str = None,
        network_info: NetworkInfo = None,
        region_info: RegionInfo = None,
        secured_group_infos: List[SecuredGroupInfo] = None,
        status: str = None,
        zone_info: ZoneInfo = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cell infos
        self.cell_infos = cell_infos
        # created time
        self.created_time = created_time
        # cluster display name
        self.display_name = display_name
        # network info
        self.network_info = network_info
        # region info
        self.region_info = region_info
        # secured group infos
        self.secured_group_infos = secured_group_infos
        # cluster status
        # 
        self.status = status
        # zone info
        self.zone_info = zone_info

    def validate(self):
        if self.cell_infos:
            for k in self.cell_infos:
                if k:
                    k.validate()
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.network_info:
            self.network_info.validate()
        if self.region_info:
            self.region_info.validate()
        if self.secured_group_infos:
            for k in self.secured_group_infos:
                if k:
                    k.validate()
        if self.zone_info:
            self.zone_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cell_infos'] = []
        if self.cell_infos is not None:
            for k in self.cell_infos:
                result['cell_infos'].append(k.to_map() if k else None)
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.network_info is not None:
            result['network_info'] = self.network_info.to_map()
        if self.region_info is not None:
            result['region_info'] = self.region_info.to_map()
        result['secured_group_infos'] = []
        if self.secured_group_infos is not None:
            for k in self.secured_group_infos:
                result['secured_group_infos'].append(k.to_map() if k else None)
        if self.status is not None:
            result['status'] = self.status
        if self.zone_info is not None:
            result['zone_info'] = self.zone_info.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cell_infos = []
        if m.get('cell_infos') is not None:
            for k in m.get('cell_infos'):
                temp_model = CellInfo()
                self.cell_infos.append(temp_model.from_map(k))
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('network_info') is not None:
            temp_model = NetworkInfo()
            self.network_info = temp_model.from_map(m['network_info'])
        if m.get('region_info') is not None:
            temp_model = RegionInfo()
            self.region_info = temp_model.from_map(m['region_info'])
        self.secured_group_infos = []
        if m.get('secured_group_infos') is not None:
            for k in m.get('secured_group_infos'):
                temp_model = SecuredGroupInfo()
                self.secured_group_infos.append(temp_model.from_map(k))
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('zone_info') is not None:
            temp_model = ZoneInfo()
            self.zone_info = temp_model.from_map(m['zone_info'])
        return self


class GetClusterOverviewinfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name
        self.cluster_name = cluster_name

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        return self


class GetClusterOverviewinfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        limited_cpu: int = None,
        limited_cpu_unit: str = None,
        limited_memory: int = None,
        limited_memory_unit: str = None,
        pod_overview_info: PodOverviewInfo = None,
        total_node_num: str = None,
        un_healthy_node_num: str = None,
        used_cpu: int = None,
        used_cpu_unit: str = None,
        used_memory: int = None,
        used_memory_unit: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cpu
        self.limited_cpu = limited_cpu
        # cpu unit
        self.limited_cpu_unit = limited_cpu_unit
        # memory
        self.limited_memory = limited_memory
        # memory unit
        self.limited_memory_unit = limited_memory_unit
        # pod overview info
        self.pod_overview_info = pod_overview_info
        # total node number
        self.total_node_num = total_node_num
        # unhealthy node num
        self.un_healthy_node_num = un_healthy_node_num
        # used cpu
        self.used_cpu = used_cpu
        # used cpu unit
        self.used_cpu_unit = used_cpu_unit
        # used memory
        self.used_memory = used_memory
        # used memory unit
        self.used_memory_unit = used_memory_unit

    def validate(self):
        if self.pod_overview_info:
            self.pod_overview_info.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.limited_cpu is not None:
            result['limited_cpu'] = self.limited_cpu
        if self.limited_cpu_unit is not None:
            result['limited_cpu_unit'] = self.limited_cpu_unit
        if self.limited_memory is not None:
            result['limited_memory'] = self.limited_memory
        if self.limited_memory_unit is not None:
            result['limited_memory_unit'] = self.limited_memory_unit
        if self.pod_overview_info is not None:
            result['pod_overview_info'] = self.pod_overview_info.to_map()
        if self.total_node_num is not None:
            result['total_node_num'] = self.total_node_num
        if self.un_healthy_node_num is not None:
            result['un_healthy_node_num'] = self.un_healthy_node_num
        if self.used_cpu is not None:
            result['used_cpu'] = self.used_cpu
        if self.used_cpu_unit is not None:
            result['used_cpu_unit'] = self.used_cpu_unit
        if self.used_memory is not None:
            result['used_memory'] = self.used_memory
        if self.used_memory_unit is not None:
            result['used_memory_unit'] = self.used_memory_unit
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('limited_cpu') is not None:
            self.limited_cpu = m.get('limited_cpu')
        if m.get('limited_cpu_unit') is not None:
            self.limited_cpu_unit = m.get('limited_cpu_unit')
        if m.get('limited_memory') is not None:
            self.limited_memory = m.get('limited_memory')
        if m.get('limited_memory_unit') is not None:
            self.limited_memory_unit = m.get('limited_memory_unit')
        if m.get('pod_overview_info') is not None:
            temp_model = PodOverviewInfo()
            self.pod_overview_info = temp_model.from_map(m['pod_overview_info'])
        if m.get('total_node_num') is not None:
            self.total_node_num = m.get('total_node_num')
        if m.get('un_healthy_node_num') is not None:
            self.un_healthy_node_num = m.get('un_healthy_node_num')
        if m.get('used_cpu') is not None:
            self.used_cpu = m.get('used_cpu')
        if m.get('used_cpu_unit') is not None:
            self.used_cpu_unit = m.get('used_cpu_unit')
        if m.get('used_memory') is not None:
            self.used_memory = m.get('used_memory')
        if m.get('used_memory_unit') is not None:
            self.used_memory_unit = m.get('used_memory_unit')
        return self


class QueryCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属环境。
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell_list: List[CellInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 部署单元列表。
        self.cell_list = cell_list

    def validate(self):
        if self.cell_list:
            for k in self.cell_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cell_list'] = []
        if self.cell_list is not None:
            for k in self.cell_list:
                result['cell_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cell_list = []
        if m.get('cell_list') is not None:
            for k in m.get('cell_list'):
                temp_model = CellInfo()
                self.cell_list.append(temp_model.from_map(k))
        return self


class GetClusterPodoverviewRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        node_name: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name
        self.cluster_name = cluster_name
        # node name
        self.node_name = node_name
        # workspace group name
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.node_name, 'node_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.node_name is not None:
            result['node_name'] = self.node_name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('node_name') is not None:
            self.node_name = m.get('node_name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class GetClusterPodoverviewResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: PodOverviewInfo = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # pod detail infos
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = PodOverviewInfo()
            self.data = temp_model.from_map(m['data'])
        return self


class ListClusterNodeinfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name
        self.cluster_name = cluster_name

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        return self


class ListClusterNodeinfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[NodeInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # node infos of specific cluster
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = NodeInfo()
                self.data.append(temp_model.from_map(k))
        return self


class CreateClusterNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        labels: List[Label] = None,
        name: str = None,
        tenant_id: str = None,
        tenant_name: str = None,
        workspace_group_id: str = None,
        workspace_group_name: str = None,
        cluster_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # namespace labels
        self.labels = labels
        # name
        self.name = name
        # tenant id
        self.tenant_id = tenant_id
        # tenant name
        self.tenant_name = tenant_name
        # workspace group id
        self.workspace_group_id = workspace_group_id
        # workspace group name
        self.workspace_group_name = workspace_group_name
        # cluster name to create namespace in
        self.cluster_name = cluster_name

    def validate(self):
        self.validate_required(self.labels, 'labels')
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.tenant_name, 'tenant_name')
        self.validate_required(self.workspace_group_id, 'workspace_group_id')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')
        self.validate_required(self.cluster_name, 'cluster_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        return self


class CreateClusterNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # is create namespace succeed
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class ListClusterNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        tenant_id: str = None,
        tenant_name: str = None,
        workspace_group_id: str = None,
        workspace_group_name: str = None,
        cluster_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # tenant id
        self.tenant_id = tenant_id
        # tenant name
        self.tenant_name = tenant_name
        # workspace group id
        self.workspace_group_id = workspace_group_id
        # workspace group name
        self.workspace_group_name = workspace_group_name
        # cluster name
        self.cluster_name = cluster_name

    def validate(self):
        self.validate_required(self.tenant_id, 'tenant_id')
        self.validate_required(self.tenant_name, 'tenant_name')
        self.validate_required(self.workspace_group_id, 'workspace_group_id')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')
        self.validate_required(self.cluster_name, 'cluster_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.tenant_id is not None:
            result['tenant_id'] = self.tenant_id
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('tenant_id') is not None:
            self.tenant_id = m.get('tenant_id')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        return self


class ListClusterNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[NamespaceDetail] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # namespace detail infos
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = NamespaceDetail()
                self.data.append(temp_model.from_map(k))
        return self


class QueryClusterNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class QueryClusterNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteClusterNamespaceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name
        self.cluster_name = cluster_name
        # name of namespace
        self.name = name

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DeleteClusterNamespaceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # is delete namespace success
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class GetClusterNodeinfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        node_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name
        self.cluster_name = cluster_name
        # node name
        self.node_name = node_name

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.node_name, 'node_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.node_name is not None:
            result['node_name'] = self.node_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('node_name') is not None:
            self.node_name = m.get('node_name')
        return self


class GetClusterNodeinfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: NodeInfo = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # node detail info
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = NodeInfo()
            self.data = temp_model.from_map(m['data'])
        return self


class CreateFederationImagepullsecretRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cells: List[str] = None,
        labels: List[Label] = None,
        name: str = None,
        namespace: str = None,
        overrides: FedImagePullSecretOverrideList = None,
        registry_account: RegistryAccout = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cells
        self.cells = cells
        # labels
        self.labels = labels
        # image pull secret name
        self.name = name
        # image pull secret namespace
        self.namespace = namespace
        # fed image pull secret list
        self.overrides = overrides
        # registry account
        self.registry_account = registry_account
        # workspace group name
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.cells, 'cells')
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.overrides, 'overrides')
        if self.overrides:
            self.overrides.validate()
        self.validate_required(self.registry_account, 'registry_account')
        if self.registry_account:
            self.registry_account.validate()
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cells is not None:
            result['cells'] = self.cells
        result['labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.overrides is not None:
            result['overrides'] = self.overrides.to_map()
        if self.registry_account is not None:
            result['registry_account'] = self.registry_account.to_map()
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        self.labels = []
        if m.get('labels') is not None:
            for k in m.get('labels'):
                temp_model = Label()
                self.labels.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('overrides') is not None:
            temp_model = FedImagePullSecretOverrideList()
            self.overrides = temp_model.from_map(m['overrides'])
        if m.get('registry_account') is not None:
            temp_model = RegistryAccout()
            self.registry_account = temp_model.from_map(m['registry_account'])
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class CreateFederationImagepullsecretResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        secret: FedSecret = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # image pull secret
        self.secret = secret

    def validate(self):
        if self.secret:
            self.secret.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.secret is not None:
            result['secret'] = self.secret.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('secret') is not None:
            temp_model = FedSecret()
            self.secret = temp_model.from_map(m['secret'])
        return self


class ListClusterNodepodRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        node_name: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name
        self.cluster_name = cluster_name
        # node name
        self.node_name = node_name
        # workspace group name
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.node_name, 'node_name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.node_name is not None:
            result['node_name'] = self.node_name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('node_name') is not None:
            self.node_name = m.get('node_name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class ListClusterNodepodResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[PodDetailInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # pod infos
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = PodDetailInfo()
                self.data.append(temp_model.from_map(k))
        return self


class ListClusterNodeeventRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        node_name: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name
        self.cluster_name = cluster_name
        # node name
        self.node_name = node_name
        # workspace group name
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.node_name, 'node_name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.node_name is not None:
            result['node_name'] = self.node_name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('node_name') is not None:
            self.node_name = m.get('node_name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class ListClusterNodeeventResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[NodeEvent] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # node events
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = NodeEvent()
                self.data.append(temp_model.from_map(k))
        return self


class QueryOpsplanRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        creation_time_from: str = None,
        creation_time_to: str = None,
        current_page: int = None,
        name: str = None,
        mode: str = None,
        page_size: int = None,
        plan_ids: List[str] = None,
        state_list: List[str] = None,
        time_series_id: str = None,
        types: List[str] = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称
        # 
        self.app_name = app_name
        # 发布单创建起始时间
        # 
        self.creation_time_from = creation_time_from
        # 发布单创建截止时间
        # 
        self.creation_time_to = creation_time_to
        # 当前页码，从1开始
        self.current_page = current_page
        # 发布单名称前缀
        self.name = name
        # 运维单类型：REBOOT,ONLINE,OFFLINE
        self.mode = mode
        # 分页大小
        self.page_size = page_size
        # 发布单id列表
        # 
        self.plan_ids = plan_ids
        # 发布单状态列表
        self.state_list = state_list
        # 发布单号
        # 
        self.time_series_id = time_series_id
        # 发布单类型列表， e.g: 分组发布|重启
        # 
        self.types = types
        # 工作空间组名称
        # 
        self.workspace_group = workspace_group

    def validate(self):
        if self.creation_time_from is not None:
            self.validate_pattern(self.creation_time_from, 'creation_time_from', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.creation_time_to is not None:
            self.validate_pattern(self.creation_time_to, 'creation_time_to', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.current_page, 'current_page')
        self.validate_required(self.page_size, 'page_size')
        if self.page_size is not None:
            self.validate_maximum(self.page_size, 'page_size', 100)
            self.validate_minimum(self.page_size, 'page_size', 1)
        self.validate_required(self.types, 'types')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.creation_time_from is not None:
            result['creation_time_from'] = self.creation_time_from
        if self.creation_time_to is not None:
            result['creation_time_to'] = self.creation_time_to
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.name is not None:
            result['name'] = self.name
        if self.mode is not None:
            result['mode'] = self.mode
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.plan_ids is not None:
            result['plan_ids'] = self.plan_ids
        if self.state_list is not None:
            result['state_list'] = self.state_list
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        if self.types is not None:
            result['types'] = self.types
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('creation_time_from') is not None:
            self.creation_time_from = m.get('creation_time_from')
        if m.get('creation_time_to') is not None:
            self.creation_time_to = m.get('creation_time_to')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('plan_ids') is not None:
            self.plan_ids = m.get('plan_ids')
        if m.get('state_list') is not None:
            self.state_list = m.get('state_list')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        if m.get('types') is not None:
            self.types = m.get('types')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryOpsplanResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        current_page: int = None,
        list: List[PlanSimpleView] = None,
        page_size: int = None,
        start_index: int = None,
        total_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 当前页码
        self.current_page = current_page
        # 发布单摘要信息列表
        self.list = list
        # 分页大小
        self.page_size = page_size
        # 发布单列表起始下标
        self.start_index = start_index
        # 总条数
        self.total_size = total_size

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.current_page is not None:
            result['current_page'] = self.current_page
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.start_index is not None:
            result['start_index'] = self.start_index
        if self.total_size is not None:
            result['total_size'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = PlanSimpleView()
                self.list.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('start_index') is not None:
            self.start_index = m.get('start_index')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        return self


class QueryOpsplanStatesummaryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        types: List[str] = None,
        time_series_id: str = None,
        state_list: List[str] = None,
        plan_ids: List[str] = None,
        name: str = None,
        page_size: int = None,
        current_page: int = None,
        creation_time_from: str = None,
        creation_time_to: str = None,
        app_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组名称
        # 
        self.workspace_group = workspace_group
        # 发布单类型列表
        # 
        self.types = types
        # 发布单号
        # 
        self.time_series_id = time_series_id
        # 发布单状态列表
        # 
        self.state_list = state_list
        # 发布单id列表
        # 
        self.plan_ids = plan_ids
        # 发布单名称前缀
        # 
        self.name = name
        # 分页大小
        # 
        self.page_size = page_size
        # 当前页码，从1开始
        # 
        self.current_page = current_page
        # 发布单创建起始时间
        self.creation_time_from = creation_time_from
        # 发布单创建截止时间
        # 
        self.creation_time_to = creation_time_to
        # 应用名称
        # 
        self.app_name = app_name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.types, 'types')
        self.validate_required(self.page_size, 'page_size')
        if self.page_size is not None:
            self.validate_maximum(self.page_size, 'page_size', 100)
            self.validate_minimum(self.page_size, 'page_size', 1)
        self.validate_required(self.current_page, 'current_page')
        if self.current_page is not None:
            self.validate_minimum(self.current_page, 'current_page', 1)
        if self.creation_time_from is not None:
            self.validate_pattern(self.creation_time_from, 'creation_time_from', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.creation_time_to is not None:
            self.validate_pattern(self.creation_time_to, 'creation_time_to', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.types is not None:
            result['types'] = self.types
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        if self.state_list is not None:
            result['state_list'] = self.state_list
        if self.plan_ids is not None:
            result['plan_ids'] = self.plan_ids
        if self.name is not None:
            result['name'] = self.name
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.creation_time_from is not None:
            result['creation_time_from'] = self.creation_time_from
        if self.creation_time_to is not None:
            result['creation_time_to'] = self.creation_time_to
        if self.app_name is not None:
            result['app_name'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('types') is not None:
            self.types = m.get('types')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        if m.get('state_list') is not None:
            self.state_list = m.get('state_list')
        if m.get('plan_ids') is not None:
            self.plan_ids = m.get('plan_ids')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('creation_time_from') is not None:
            self.creation_time_from = m.get('creation_time_from')
        if m.get('creation_time_to') is not None:
            self.creation_time_to = m.get('creation_time_to')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        return self


class QueryOpsplanStatesummaryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[LdcPlanStateCount] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 发布单状态汇总数据
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = LdcPlanStateCount()
                self.data.append(temp_model.from_map(k))
        return self


class QueryOpsplanDetailRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        time_series_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单id
        self.time_series_id = time_series_id

    def validate(self):
        self.validate_required(self.time_series_id, 'time_series_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        return self


class QueryOpsplanDetailResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_count: int = None,
        app_infos: List[AppSimpleInfo] = None,
        executor: str = None,
        finish_time: str = None,
        group_collection_list: List[AppGroupSimpleViewList] = None,
        id: str = None,
        message_detail: str = None,
        mode: str = None,
        name: str = None,
        remark: str = None,
        start_time: str = None,
        state: str = None,
        time_series_id: str = None,
        type: str = None,
        pod_count: int = None,
        approval_status: str = None,
        approval_url: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 发布单包含的应用数
        self.app_count = app_count
        # 应用信息列表
        self.app_infos = app_infos
        # 执行人
        self.executor = executor
        # 发布结束时间
        self.finish_time = finish_time
        # 应用分组概要信息列表
        self.group_collection_list = group_collection_list
        # 发布单id
        self.id = id
        # 错误信息
        self.message_detail = message_detail
        # 运维单类型
        # 
        self.mode = mode
        # 发布单标题
        self.name = name
        # 备注信息
        self.remark = remark
        # 发布开始时间
        self.start_time = start_time
        # 发布单状态
        # 
        self.state = state
        # 发布单号
        self.time_series_id = time_series_id
        # 发布单类型
        self.type = type
        # pod数量
        self.pod_count = pod_count
        # 审批状态：AGREE-同意，REJECTED-拒绝，CANCELED-取消
        self.approval_status = approval_status
        # 审批详情url
        self.approval_url = approval_url

    def validate(self):
        if self.app_infos:
            for k in self.app_infos:
                if k:
                    k.validate()
        if self.finish_time is not None:
            self.validate_pattern(self.finish_time, 'finish_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.group_collection_list:
            for k in self.group_collection_list:
                if k:
                    k.validate()
        if self.start_time is not None:
            self.validate_pattern(self.start_time, 'start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_count is not None:
            result['app_count'] = self.app_count
        result['app_infos'] = []
        if self.app_infos is not None:
            for k in self.app_infos:
                result['app_infos'].append(k.to_map() if k else None)
        if self.executor is not None:
            result['executor'] = self.executor
        if self.finish_time is not None:
            result['finish_time'] = self.finish_time
        result['group_collection_list'] = []
        if self.group_collection_list is not None:
            for k in self.group_collection_list:
                result['group_collection_list'].append(k.to_map() if k else None)
        if self.id is not None:
            result['id'] = self.id
        if self.message_detail is not None:
            result['message_detail'] = self.message_detail
        if self.mode is not None:
            result['mode'] = self.mode
        if self.name is not None:
            result['name'] = self.name
        if self.remark is not None:
            result['remark'] = self.remark
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.state is not None:
            result['state'] = self.state
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        if self.type is not None:
            result['type'] = self.type
        if self.pod_count is not None:
            result['pod_count'] = self.pod_count
        if self.approval_status is not None:
            result['approval_status'] = self.approval_status
        if self.approval_url is not None:
            result['approval_url'] = self.approval_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_count') is not None:
            self.app_count = m.get('app_count')
        self.app_infos = []
        if m.get('app_infos') is not None:
            for k in m.get('app_infos'):
                temp_model = AppSimpleInfo()
                self.app_infos.append(temp_model.from_map(k))
        if m.get('executor') is not None:
            self.executor = m.get('executor')
        if m.get('finish_time') is not None:
            self.finish_time = m.get('finish_time')
        self.group_collection_list = []
        if m.get('group_collection_list') is not None:
            for k in m.get('group_collection_list'):
                temp_model = AppGroupSimpleViewList()
                self.group_collection_list.append(temp_model.from_map(k))
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('message_detail') is not None:
            self.message_detail = m.get('message_detail')
        if m.get('mode') is not None:
            self.mode = m.get('mode')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('remark') is not None:
            self.remark = m.get('remark')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('pod_count') is not None:
            self.pod_count = m.get('pod_count')
        if m.get('approval_status') is not None:
            self.approval_status = m.get('approval_status')
        if m.get('approval_url') is not None:
            self.approval_url = m.get('approval_url')
        return self


class QueryBuildpackTechstackRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class QueryBuildpackTechstackResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        list: List[TechStack] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 当前租户内可见的技术栈分类：包括公共可见以及租户自定义分类
        self.list = list

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = TechStack()
                self.list.append(temp_model.from_map(k))
        return self


class QueryBuildpackNativetechstackversionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        tech_stack: str = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 技术栈名称。
        # 原则上允许用户定义同名自定义技术栈（e.g,用户创建和全局同名的技术栈SOFA），此时优先获取用户自定义技术栈下技术栈版本；
        self.tech_stack = tech_stack
        # 当前页码， 默认值为1
        self.current_page = current_page
        # 一页获取个数，默认值10
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.tech_stack, 'tech_stack')
        if self.page_size is not None:
            self.validate_maximum(self.page_size, 'page_size', 100)
            self.validate_minimum(self.page_size, 'page_size', 1)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.tech_stack is not None:
            result['tech_stack'] = self.tech_stack
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('tech_stack') is not None:
            self.tech_stack = m.get('tech_stack')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryBuildpackNativetechstackversionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        total_count: int = None,
        list: List[NativeTechStackVersion] = None,
        current_page: int = None,
        page_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 总个数
        self.total_count = total_count
        # 云原生技术栈版本列表
        self.list = list
        # 当前页码
        self.current_page = current_page
        # 一页包含个数
        self.page_size = page_size

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.total_count is not None:
            result['total_count'] = self.total_count
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = NativeTechStackVersion()
                self.list.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class UpdateContainerserviceNativebpversionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        namespace: str = None,
        native_build_pack_version: str = None,
        operator: str = None,
        workspace_group: str = None,
        revision: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务名称
        self.name = name
        # 容器服务所在命名空间
        self.namespace = namespace
        # 云原生技术栈版本
        self.native_build_pack_version = native_build_pack_version
        # 操作人
        self.operator = operator
        # 环境名称
        self.workspace_group = workspace_group
        # 容器服务版本
        self.revision = revision

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.native_build_pack_version, 'native_build_pack_version')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.revision, 'revision')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.native_build_pack_version is not None:
            result['native_build_pack_version'] = self.native_build_pack_version
        if self.operator is not None:
            result['operator'] = self.operator
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.revision is not None:
            result['revision'] = self.revision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('native_build_pack_version') is not None:
            self.native_build_pack_version = m.get('native_build_pack_version')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        return self


class UpdateContainerserviceNativebpversionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        revision: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 更新后的容器应用服务版本号
        self.revision = revision

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.revision is not None:
            result['revision'] = self.revision
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        return self


class LoadContainerserviceDockerfileRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        package_url: str = None,
        workspace_group: str = None,
        namespace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务名称
        self.name = name
        # 应用包地址，可以为相对目录，或者远程可访问存储地址.
        # 用于组装Dockerfile模板中对应的应用包获取地址
        self.package_url = package_url
        # 环境名称
        self.workspace_group = workspace_group
        # 容器服务所在namespace
        self.namespace = namespace

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.package_url, 'package_url')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.package_url is not None:
            result['package_url'] = self.package_url
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('package_url') is not None:
            self.package_url = m.get('package_url')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class LoadContainerserviceDockerfileResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        commands: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # Dockerfile指令列表
        self.commands = commands

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.commands is not None:
            result['commands'] = self.commands
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('commands') is not None:
            self.commands = m.get('commands')
        return self


class CreateBuildpackNativetechstackversionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        display_version: str = None,
        description: str = None,
        from_image: str = None,
        tech_stack: str = None,
        tech_stack_id: str = None,
        scope: str = None,
        ext_commands: List[str] = None,
        extend_properties: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # ce4456_jdk8_tengine6
        self.display_version = display_version
        # 版本描述
        self.description = description
        # 完整的镜像地址
        self.from_image = from_image
        # 所属技术栈大类
        self.tech_stack = tech_stack
        # 技术栈大类对应的id，如不填写，后台默认根据名称校验所属技术栈大类
        self.tech_stack_id = tech_stack_id
        # 指定该版本可见范围：
        # PUBLIC - 全站点各个租户都可见；
        # TENANT - 仅创建改版本对应的租户内可见
        self.scope = scope
        # 扩展的Dockerfile指令。
        # 用于在FromImage的基础上扩展Dockerfile指令
        self.ext_commands = ext_commands
        # 扩展属性 - 表现为Map<String,String>序列化后的字符串
        self.extend_properties = extend_properties

    def validate(self):
        self.validate_required(self.display_version, 'display_version')
        self.validate_required(self.from_image, 'from_image')
        self.validate_required(self.tech_stack, 'tech_stack')
        self.validate_required(self.scope, 'scope')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.display_version is not None:
            result['display_version'] = self.display_version
        if self.description is not None:
            result['description'] = self.description
        if self.from_image is not None:
            result['from_image'] = self.from_image
        if self.tech_stack is not None:
            result['tech_stack'] = self.tech_stack
        if self.tech_stack_id is not None:
            result['tech_stack_id'] = self.tech_stack_id
        if self.scope is not None:
            result['scope'] = self.scope
        if self.ext_commands is not None:
            result['ext_commands'] = self.ext_commands
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('display_version') is not None:
            self.display_version = m.get('display_version')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('from_image') is not None:
            self.from_image = m.get('from_image')
        if m.get('tech_stack') is not None:
            self.tech_stack = m.get('tech_stack')
        if m.get('tech_stack_id') is not None:
            self.tech_stack_id = m.get('tech_stack_id')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('ext_commands') is not None:
            self.ext_commands = m.get('ext_commands')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        return self


class CreateBuildpackNativetechstackversionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: NativeTechStackVersion = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 创建后生成的对象信息
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = NativeTechStackVersion()
            self.data = temp_model.from_map(m['data'])
        return self


class ListMulticlusterZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace group name
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListMulticlusterZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[ZoneOfWorkspace] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # zones of workspace group
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ZoneOfWorkspace()
                self.data.append(temp_model.from_map(k))
        return self


class ExecOpsplanAppopstaskRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        control_type: str = None,
        action_code: str = None,
        id: str = None,
        operator: str = None,
        cancel_plan_flag: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 操作类型
        self.control_type = control_type
        # pipeline stage 名字
        self.action_code = action_code
        # 任务id
        self.id = id
        # operator名字
        self.operator = operator
        # [huanyu场景使用]，当cancel_plan_flag为true, control_type=CANCEL且action_code=CLOUD_NATIVE_DEPLOY时，整个运维单将被取消
        self.cancel_plan_flag = cancel_plan_flag

    def validate(self):
        self.validate_required(self.control_type, 'control_type')
        self.validate_required(self.action_code, 'action_code')
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.control_type is not None:
            result['control_type'] = self.control_type
        if self.action_code is not None:
            result['action_code'] = self.action_code
        if self.id is not None:
            result['id'] = self.id
        if self.operator is not None:
            result['operator'] = self.operator
        if self.cancel_plan_flag is not None:
            result['cancel_plan_flag'] = self.cancel_plan_flag
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('control_type') is not None:
            self.control_type = m.get('control_type')
        if m.get('action_code') is not None:
            self.action_code = m.get('action_code')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('cancel_plan_flag') is not None:
            self.cancel_plan_flag = m.get('cancel_plan_flag')
        return self


class ExecOpsplanAppopstaskResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryOpsplanProgressRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        time_series_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单序列号
        self.time_series_id = time_series_id

    def validate(self):
        self.validate_required(self.time_series_id, 'time_series_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        return self


class QueryOpsplanProgressResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_execute_progress: List[ExecuteProgress] = None,
        execute_progress: ExecuteProgress = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 应用执行进度
        self.app_execute_progress = app_execute_progress
        # 发布单进度
        self.execute_progress = execute_progress

    def validate(self):
        if self.app_execute_progress:
            for k in self.app_execute_progress:
                if k:
                    k.validate()
        if self.execute_progress:
            self.execute_progress.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['app_execute_progress'] = []
        if self.app_execute_progress is not None:
            for k in self.app_execute_progress:
                result['app_execute_progress'].append(k.to_map() if k else None)
        if self.execute_progress is not None:
            result['execute_progress'] = self.execute_progress.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.app_execute_progress = []
        if m.get('app_execute_progress') is not None:
            for k in m.get('app_execute_progress'):
                temp_model = ExecuteProgress()
                self.app_execute_progress.append(temp_model.from_map(k))
        if m.get('execute_progress') is not None:
            temp_model = ExecuteProgress()
            self.execute_progress = temp_model.from_map(m['execute_progress'])
        return self


class QueryOpsplanAppprogressRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: str = None,
        time_series_id: str = None,
        stage_id: str = None,
        need_export_cell_pods: bool = None,
        opscloud_change_target_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用id
        self.id = id
        # 运维单id
        self.time_series_id = time_series_id
        # 批次stage的id
        self.stage_id = stage_id
        # [huanyu场景使用] 是否需要返回affected_cell_pods
        self.need_export_cell_pods = need_export_cell_pods
        # [huanyu场景使用] 返回给opscloud的变更对象类型。如果为NONE，则不返回变更对象信息
        self.opscloud_change_target_type = opscloud_change_target_type

    def validate(self):
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        if self.stage_id is not None:
            result['stage_id'] = self.stage_id
        if self.need_export_cell_pods is not None:
            result['need_export_cell_pods'] = self.need_export_cell_pods
        if self.opscloud_change_target_type is not None:
            result['opscloud_change_target_type'] = self.opscloud_change_target_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        if m.get('stage_id') is not None:
            self.stage_id = m.get('stage_id')
        if m.get('need_export_cell_pods') is not None:
            self.need_export_cell_pods = m.get('need_export_cell_pods')
        if m.get('opscloud_change_target_type') is not None:
            self.opscloud_change_target_type = m.get('opscloud_change_target_type')
        return self


class QueryOpsplanAppprogressResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        app_deploy_progress: AppDeployProgress = None,
        affected_cell_pods: List[AppDeployCell] = None,
        opscloud_change_target_json_str: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 应用发布进度详情
        self.app_deploy_progress = app_deploy_progress
        # [huanyu场景使用] 查询涉及的部署单元及pod详情列表
        self.affected_cell_pods = affected_cell_pods
        # [huanyu场景使用] json格式的变更对象信息列表
        self.opscloud_change_target_json_str = opscloud_change_target_json_str

    def validate(self):
        if self.app_deploy_progress:
            self.app_deploy_progress.validate()
        if self.affected_cell_pods:
            for k in self.affected_cell_pods:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.app_deploy_progress is not None:
            result['app_deploy_progress'] = self.app_deploy_progress.to_map()
        result['affected_cell_pods'] = []
        if self.affected_cell_pods is not None:
            for k in self.affected_cell_pods:
                result['affected_cell_pods'].append(k.to_map() if k else None)
        if self.opscloud_change_target_json_str is not None:
            result['opscloud_change_target_json_str'] = self.opscloud_change_target_json_str
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('app_deploy_progress') is not None:
            temp_model = AppDeployProgress()
            self.app_deploy_progress = temp_model.from_map(m['app_deploy_progress'])
        self.affected_cell_pods = []
        if m.get('affected_cell_pods') is not None:
            for k in m.get('affected_cell_pods'):
                temp_model = AppDeployCell()
                self.affected_cell_pods.append(temp_model.from_map(k))
        if m.get('opscloud_change_target_json_str') is not None:
            self.opscloud_change_target_json_str = m.get('opscloud_change_target_json_str')
        return self


class ListContainerservicePodRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service_name: str = None,
        namespace: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器服务名称
        self.container_service_name = container_service_name
        # namespace
        self.namespace = namespace
        # 工作空间组名称。
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class ListContainerservicePodResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        pod_list: List[PodInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # pod信息列表
        self.pod_list = pod_list

    def validate(self):
        if self.pod_list:
            for k in self.pod_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['pod_list'] = []
        if self.pod_list is not None:
            for k in self.pod_list:
                result['pod_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.pod_list = []
        if m.get('pod_list') is not None:
            for k in m.get('pod_list'):
                temp_model = PodInfo()
                self.pod_list.append(temp_model.from_map(k))
        return self


class ListContainerserviceKubeeventsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class ListContainerserviceKubeeventsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # mock
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListPodEventsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster: str = None,
        name: str = None,
        namespace: str = None,
        workspace_group: str = None,
        uid: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 集群名称
        self.cluster = cluster
        # Pod名称
        self.name = name
        # 所属命名空间名称
        self.namespace = namespace
        # 所属环境名称
        self.workspace_group = workspace_group
        # pod uid
        self.uid = uid

    def validate(self):
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.uid, 'uid')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.uid is not None:
            result['uid'] = self.uid
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        return self


class ListPodEventsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        events: List[KubeEvent] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # Pod事件列表
        self.events = events

    def validate(self):
        if self.events:
            for k in self.events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['events'] = []
        if self.events is not None:
            for k in self.events:
                result['events'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.events = []
        if m.get('events') is not None:
            for k in m.get('events'):
                temp_model = KubeEvent()
                self.events.append(temp_model.from_map(k))
        return self


class ListPodContainersRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        cluster: str = None,
        namespace: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属环境名称
        self.workspace_group = workspace_group
        # 所属集群名称
        self.cluster = cluster
        # 所属工作空间名称
        self.namespace = namespace
        # Pod名称
        self.name = name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListPodContainersResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        containers: List[ContainerInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # Pod容器列表
        self.containers = containers

    def validate(self):
        if self.containers:
            for k in self.containers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['containers'] = []
        if self.containers is not None:
            for k in self.containers:
                result['containers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.containers = []
        if m.get('containers') is not None:
            for k in m.get('containers'):
                temp_model = ContainerInfo()
                self.containers.append(temp_model.from_map(k))
        return self


class QueryContainerserviceCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # container service name
        self.container_service_name = container_service_name

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        return self


class QueryContainerserviceCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell_list: List[CellInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cell list
        self.cell_list = cell_list

    def validate(self):
        if self.cell_list:
            for k in self.cell_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cell_list'] = []
        if self.cell_list is not None:
            for k in self.cell_list:
                result['cell_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cell_list = []
        if m.get('cell_list') is not None:
            for k in m.get('cell_list'):
                temp_model = CellInfo()
                self.cell_list.append(temp_model.from_map(k))
        return self


class CreateCellgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        datacenter: str = None,
        default_gzone: str = None,
        name: str = None,
        type: str = None,
        workspace_group: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属idc
        self.datacenter = datacenter
        # 默认全局域
        self.default_gzone = default_gzone
        # 逻辑单元名称
        self.name = name
        # 逻辑单元类型
        self.type = type
        # 所属环境名称。
        self.workspace_group = workspace_group
        # 操作人。
        self.operator = operator

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.datacenter is not None:
            result['datacenter'] = self.datacenter
        if self.default_gzone is not None:
            result['default_gzone'] = self.default_gzone
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('datacenter') is not None:
            self.datacenter = m.get('datacenter')
        if m.get('default_gzone') is not None:
            self.default_gzone = m.get('default_gzone')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class CreateCellgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListCellgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属环境名称
        self.workspace_group = workspace_group
        # cell group查询前缀
        self.name = name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class ListCellgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell_group_list: List[CellGroup] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 逻辑单元列表
        self.cell_group_list = cell_group_list

    def validate(self):
        if self.cell_group_list:
            for k in self.cell_group_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cell_group_list'] = []
        if self.cell_group_list is not None:
            for k in self.cell_group_list:
                result['cell_group_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cell_group_list = []
        if m.get('cell_group_list') is not None:
            for k in m.get('cell_group_list'):
                temp_model = CellGroup()
                self.cell_group_list.append(temp_model.from_map(k))
        return self


class UpdateCellgroupDisasterinfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        disaster_info: List[DisasterInfo] = None,
        name: str = None,
        workspace_group: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 灾备信息。
        self.disaster_info = disaster_info
        # 逻辑单元名称。
        self.name = name
        # 所属环境名称。
        self.workspace_group = workspace_group
        # 操作人。
        self.operator = operator

    def validate(self):
        self.validate_required(self.disaster_info, 'disaster_info')
        if self.disaster_info:
            for k in self.disaster_info:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['disaster_info'] = []
        if self.disaster_info is not None:
            for k in self.disaster_info:
                result['disaster_info'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.disaster_info = []
        if m.get('disaster_info') is not None:
            for k in m.get('disaster_info'):
                temp_model = DisasterInfo()
                self.disaster_info.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class UpdateCellgroupDisasterinfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteCellgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属环境名称
        self.workspace_group = workspace_group
        # 逻辑单元名称
        self.name = name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DeleteCellgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单元名称前缀
        self.name = name
        # 环境名称
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cells: List[Cell] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 部署单元列表
        self.cells = cells

    def validate(self):
        if self.cells:
            for k in self.cells:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cells'] = []
        if self.cells is not None:
            for k in self.cells:
                result['cells'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cells = []
        if m.get('cells') is not None:
            for k in m.get('cells'):
                temp_model = Cell()
                self.cells.append(temp_model.from_map(k))
        return self


class CreateCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cell_group: str = None,
        color: str = None,
        identity: str = None,
        is_gray: bool = None,
        name: str = None,
        type: str = None,
        weight: int = None,
        workspace_group: str = None,
        zone: str = None,
        workspace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属逻辑单元名称[单元化模式特有]。
        self.cell_group = cell_group
        # 蓝绿着色信息[单元化模式特有]。
        self.color = color
        # 部署单元标识。
        self.identity = identity
        # 是否灰度[单元化模式特有]。
        self.is_gray = is_gray
        # 部署单元名称。
        self.name = name
        # 部署单元类型[单元化模式特有]。
        self.type = type
        # 权重[单元化模式特有]。
        self.weight = weight
        # 所属环境名称。
        self.workspace_group = workspace_group
        # 所属机房。
        self.zone = zone
        # 所属工作空间名称。
        self.workspace = workspace

    def validate(self):
        self.validate_required(self.identity, 'identity')
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.zone, 'zone')
        self.validate_required(self.workspace, 'workspace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cell_group is not None:
            result['cell_group'] = self.cell_group
        if self.color is not None:
            result['color'] = self.color
        if self.identity is not None:
            result['identity'] = self.identity
        if self.is_gray is not None:
            result['is_gray'] = self.is_gray
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.weight is not None:
            result['weight'] = self.weight
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.zone is not None:
            result['zone'] = self.zone
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cell_group') is not None:
            self.cell_group = m.get('cell_group')
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('identity') is not None:
            self.identity = m.get('identity')
        if m.get('is_gray') is not None:
            self.is_gray = m.get('is_gray')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('zone') is not None:
            self.zone = m.get('zone')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class CreateCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group: str = None,
        workspace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单元名称。
        self.name = name
        # 所属环境名称。
        self.workspace_group = workspace_group
        # 所属工作空间名称。
        self.workspace = workspace

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.workspace, 'workspace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class DeleteCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeletePodRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        namespace: str = None,
        container_service: str = None,
        cluster: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属环境名称。
        self.workspace_group = workspace_group
        # 命名空间名称。
        self.namespace = namespace
        # 容器应用服务名称。
        self.container_service = container_service
        # 集群名称。
        self.cluster = cluster
        # pod名称。
        self.name = name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.container_service is not None:
            result['container_service'] = self.container_service
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('container_service') is not None:
            self.container_service = m.get('container_service')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DeletePodResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetWorkspacegroupTopologyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        region: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属环境(WorkspaceGroup)名称。
        self.name = name
        # 地域
        self.region = region

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.region, 'region')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.region is not None:
            result['region'] = self.region
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('region') is not None:
            self.region = m.get('region')
        return self


class GetWorkspacegroupTopologyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell_groups: List[CellGroup] = None,
        name: str = None,
        zones: List[ZoneInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 环境逻辑单元信息。
        self.cell_groups = cell_groups
        # 环境(WorkspaceGroup)名称。
        self.name = name
        # 环境机房信息。
        self.zones = zones

    def validate(self):
        if self.cell_groups:
            for k in self.cell_groups:
                if k:
                    k.validate()
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cell_groups'] = []
        if self.cell_groups is not None:
            for k in self.cell_groups:
                result['cell_groups'].append(k.to_map() if k else None)
        if self.name is not None:
            result['name'] = self.name
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cell_groups = []
        if m.get('cell_groups') is not None:
            for k in m.get('cell_groups'):
                temp_model = CellGroup()
                self.cell_groups.append(temp_model.from_map(k))
        if m.get('name') is not None:
            self.name = m.get('name')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = ZoneInfo()
                self.zones.append(temp_model.from_map(k))
        return self


class UpdateFlowCellweightRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cell_group: str = None,
        operator: str = None,
        press: bool = None,
        weight_info_list: CellWeightInfoList = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单元组
        self.cell_group = cell_group
        # 操作人
        self.operator = operator
        # 是否压测流量，默认 false
        self.press = press
        # 部署单元权重信息
        self.weight_info_list = weight_info_list
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.cell_group, 'cell_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.weight_info_list, 'weight_info_list')
        if self.weight_info_list:
            self.weight_info_list.validate()
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cell_group is not None:
            result['cell_group'] = self.cell_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.press is not None:
            result['press'] = self.press
        if self.weight_info_list is not None:
            result['weight_info_list'] = self.weight_info_list.to_map()
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cell_group') is not None:
            self.cell_group = m.get('cell_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('press') is not None:
            self.press = m.get('press')
        if m.get('weight_info_list') is not None:
            temp_model = CellWeightInfoList()
            self.weight_info_list = temp_model.from_map(m['weight_info_list'])
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateFlowCellweightResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateFlowUidrangeRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cell_group: str = None,
        gray: bool = None,
        operator: str = None,
        press: bool = None,
        uid_ranges: UidShardList = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单元组
        self.cell_group = cell_group
        # 是否灰度流量（默认false）
        self.gray = gray
        # 操作人
        self.operator = operator
        # 是否压测流量（默认 false）
        self.press = press
        # uid 范围
        self.uid_ranges = uid_ranges
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.cell_group, 'cell_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.uid_ranges, 'uid_ranges')
        if self.uid_ranges:
            self.uid_ranges.validate()
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cell_group is not None:
            result['cell_group'] = self.cell_group
        if self.gray is not None:
            result['gray'] = self.gray
        if self.operator is not None:
            result['operator'] = self.operator
        if self.press is not None:
            result['press'] = self.press
        if self.uid_ranges is not None:
            result['uid_ranges'] = self.uid_ranges.to_map()
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cell_group') is not None:
            self.cell_group = m.get('cell_group')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('press') is not None:
            self.press = m.get('press')
        if m.get('uid_ranges') is not None:
            temp_model = UidShardList()
            self.uid_ranges = temp_model.from_map(m['uid_ranges'])
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateFlowUidrangeResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class EnableFlowElasticuidRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        pop_out_uids: List[PopOutUid] = None,
        press: bool = None,
        gray: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 弹出的 UID 信息
        self.pop_out_uids = pop_out_uids
        # 是否压测流量（默认 false）
        self.press = press
        # 是否灰度流量（默认 false）
        self.gray = gray

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.pop_out_uids, 'pop_out_uids')
        if self.pop_out_uids:
            for k in self.pop_out_uids:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        result['pop_out_uids'] = []
        if self.pop_out_uids is not None:
            for k in self.pop_out_uids:
                result['pop_out_uids'].append(k.to_map() if k else None)
        if self.press is not None:
            result['press'] = self.press
        if self.gray is not None:
            result['gray'] = self.gray
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        self.pop_out_uids = []
        if m.get('pop_out_uids') is not None:
            for k in m.get('pop_out_uids'):
                temp_model = PopOutUid()
                self.pop_out_uids.append(temp_model.from_map(k))
        if m.get('press') is not None:
            self.press = m.get('press')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        return self


class EnableFlowElasticuidResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DisableFlowElasticuidRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        resume_uids: List[int] = None,
        press: bool = None,
        gray: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 弹回的 UID 分片
        self.resume_uids = resume_uids
        # 是否压测（默认 false）
        self.press = press
        # 是否灰度（默认 false）
        self.gray = gray

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.resume_uids, 'resume_uids')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.resume_uids is not None:
            result['resume_uids'] = self.resume_uids
        if self.press is not None:
            result['press'] = self.press
        if self.gray is not None:
            result['gray'] = self.gray
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('resume_uids') is not None:
            self.resume_uids = m.get('resume_uids')
        if m.get('press') is not None:
            self.press = m.get('press')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        return self


class DisableFlowElasticuidResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ExportFlowRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        apps: List[str] = None,
        gray: bool = None,
        operator: str = None,
        rule_type: str = None,
        workspace_group: str = None,
        check: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 参与规则生成的应用列表
        self.apps = apps
        # 是否灰度（默认 false）
        self.gray = gray
        # 操作人
        self.operator = operator
        # 规则类型，支持(ZONE_INFO,ELASTIC_BIZ_RULE,ZONE_COLOR,TAO_BAO_RULE)
        self.rule_type = rule_type
        # 工作空间组
        self.workspace_group = workspace_group
        # 是否进行规则校验，默认 false
        self.check = check

    def validate(self):
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.rule_type, 'rule_type')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.apps is not None:
            result['apps'] = self.apps
        if self.gray is not None:
            result['gray'] = self.gray
        if self.operator is not None:
            result['operator'] = self.operator
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.check is not None:
            result['check'] = self.check
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('apps') is not None:
            self.apps = m.get('apps')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('check') is not None:
            self.check = m.get('check')
        return self


class ExportFlowRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        rule: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 流量规则的 JSON 字符串
        self.rule = rule

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.rule is not None:
            result['rule'] = self.rule
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('rule') is not None:
            self.rule = m.get('rule')
        return self


class PushFlowRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        apps: List[str] = None,
        gray: bool = None,
        operator: str = None,
        push_all: bool = None,
        rule_type: str = None,
        rule_value: str = None,
        targets: List[str] = None,
        workspace_group: str = None,
        override: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 包含系统列表，目前功能不支持，禁止设置
        self.apps = apps
        # 是否灰度（默认 false）
        self.gray = gray
        # 操作人
        self.operator = operator
        # 推送中间件流量规则时，是否同时推送中间件中枢
        self.push_all = push_all
        # 规则类型,支持(ZONE_INFO,ELASTIC_BIZ_RULE,ZONE_COLOR,TAO_BAO_RULE)
        self.rule_type = rule_type
        # 规则文本
        self.rule_value = rule_value
        # 推送目标列表，域外支持 MIDDLEWARE（微服务/中间件）、ALB（统一接入） 两种
        self.targets = targets
        # 工作空间组
        self.workspace_group = workspace_group
        # 是否覆盖其他应用的规则，默认 false
        self.override = override

    def validate(self):
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.rule_type, 'rule_type')
        self.validate_required(self.rule_value, 'rule_value')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.apps is not None:
            result['apps'] = self.apps
        if self.gray is not None:
            result['gray'] = self.gray
        if self.operator is not None:
            result['operator'] = self.operator
        if self.push_all is not None:
            result['push_all'] = self.push_all
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.rule_value is not None:
            result['rule_value'] = self.rule_value
        if self.targets is not None:
            result['targets'] = self.targets
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.override is not None:
            result['override'] = self.override
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('apps') is not None:
            self.apps = m.get('apps')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('push_all') is not None:
            self.push_all = m.get('push_all')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('rule_value') is not None:
            self.rule_value = m.get('rule_value')
        if m.get('targets') is not None:
            self.targets = m.get('targets')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('override') is not None:
            self.override = m.get('override')
        return self


class PushFlowRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        gray: bool = None,
        rule_result_list: List[PushRuleResult] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 是否灰度环境
        self.gray = gray
        # 推送结果
        self.rule_result_list = rule_result_list

    def validate(self):
        if self.rule_result_list:
            for k in self.rule_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.gray is not None:
            result['gray'] = self.gray
        result['rule_result_list'] = []
        if self.rule_result_list is not None:
            for k in self.rule_result_list:
                result['rule_result_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        self.rule_result_list = []
        if m.get('rule_result_list') is not None:
            for k in m.get('rule_result_list'):
                temp_model = PushRuleResult()
                self.rule_result_list.append(temp_model.from_map(k))
        return self


class AddFlowElasticruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        event_codes: List[str] = None,
        methods: List[str] = None,
        operator: str = None,
        rule_type: str = None,
        scene_name: str = None,
        service_name: str = None,
        status: str = None,
        topic: str = None,
        use_default_eid: bool = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属应用名称
        self.app_name = app_name
        # MSGBROKER 需要填写。
        # 弹性规则消息类型事件码。
        # 如果包含所有eventCode，可以用英文星号"*"表示。
        self.event_codes = event_codes
        # 弹性规则方法名称，RPC类型需要填写。
        # 如果包含所有方法，则填写英文星号"*"
        self.methods = methods
        # 操作人
        self.operator = operator
        # 弹性规则类型，包括：APP、RPC、MSGBROKER，ANTQ
        self.rule_type = rule_type
        # 适用的弹性场景名称
        self.scene_name = scene_name
        # 弹性规则服务名称。
        # RPC：对应接口名，例如：com.alipay.cif.facade.AckCodeService:1.0:cif。
        # APP：对应应用名，例如：cif。
        # MSG或ANTQ：对应消息groupId，例如：S-UNIQUERY-SYNC。
        self.service_name = service_name
        # 弹性规则状态，有效值：VALID（线上生效）、PRESS（仅压测生效）、INVALID（无效状态）
        self.status = status
        # MSGBROKER 和 ANTQ 需要填写。
        # 弹性规则消息类型topic。
        # 如果包含所有topic，可以用英文星号"*"表示。
        self.topic = topic
        # 是否使用默认EID（默认 false）
        self.use_default_eid = use_default_eid
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.rule_type, 'rule_type')
        self.validate_required(self.scene_name, 'scene_name')
        self.validate_required(self.service_name, 'service_name')
        self.validate_required(self.status, 'status')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.event_codes is not None:
            result['event_codes'] = self.event_codes
        if self.methods is not None:
            result['methods'] = self.methods
        if self.operator is not None:
            result['operator'] = self.operator
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.scene_name is not None:
            result['scene_name'] = self.scene_name
        if self.service_name is not None:
            result['service_name'] = self.service_name
        if self.status is not None:
            result['status'] = self.status
        if self.topic is not None:
            result['topic'] = self.topic
        if self.use_default_eid is not None:
            result['use_default_eid'] = self.use_default_eid
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('event_codes') is not None:
            self.event_codes = m.get('event_codes')
        if m.get('methods') is not None:
            self.methods = m.get('methods')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('scene_name') is not None:
            self.scene_name = m.get('scene_name')
        if m.get('service_name') is not None:
            self.service_name = m.get('service_name')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('topic') is not None:
            self.topic = m.get('topic')
        if m.get('use_default_eid') is not None:
            self.use_default_eid = m.get('use_default_eid')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class AddFlowElasticruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateFlowElasticruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        operator: str = None,
        service_name: str = None,
        status: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 弹性规则 ID
        self.id = id
        # 操作人
        self.operator = operator
        # 弹性规则服务名称。
        # RPC：对应接口名，例如：com.alipay.cif.facade.AckCodeService:1.0:cif。
        # APP：对应应用名，例如：cif。
        # MSG或ANTQ：对应消息groupId，例如：S-UNIQUERY-SYNC。
        self.service_name = service_name
        # 弹性规则状态，可选值 VALID("线上生效")，PRESS("仅压测生效")，INVALID("无效状态");
        self.status = status
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.service_name, 'service_name')
        self.validate_required(self.status, 'status')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.operator is not None:
            result['operator'] = self.operator
        if self.service_name is not None:
            result['service_name'] = self.service_name
        if self.status is not None:
            result['status'] = self.status
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('service_name') is not None:
            self.service_name = m.get('service_name')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateFlowElasticruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteFlowElasticruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: int = None,
        operator: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 弹性规则 ID
        self.id = id
        # 操作人
        self.operator = operator
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.operator is not None:
            result['operator'] = self.operator
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class DeleteFlowElasticruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class AddFlowElasticsubruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        event_code: str = None,
        operator: str = None,
        parent_id: int = None,
        rpc_method: str = None,
        rule_type: str = None,
        status: str = None,
        topic: str = None,
        use_default_eid: bool = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 消息eventCode, MSGBROKER必填
        self.event_code = event_code
        # 操作人
        self.operator = operator
        # 父规则ID
        self.parent_id = parent_id
        # 规则值, RPC必填
        self.rpc_method = rpc_method
        # 所属规则类型，可选值：RPC, MSGBROKER, ANTQ, APP
        self.rule_type = rule_type
        # VALID("线上生效"), PRESS("仅压测生效"), INVALID("无效状态");
        self.status = status
        # 消息topic, MSGBROKER和ANTQ必填
        self.topic = topic
        # 是否使用默认eid, RPC必填
        self.use_default_eid = use_default_eid
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.parent_id, 'parent_id')
        self.validate_required(self.rule_type, 'rule_type')
        self.validate_required(self.status, 'status')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.event_code is not None:
            result['event_code'] = self.event_code
        if self.operator is not None:
            result['operator'] = self.operator
        if self.parent_id is not None:
            result['parent_id'] = self.parent_id
        if self.rpc_method is not None:
            result['rpc_method'] = self.rpc_method
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.status is not None:
            result['status'] = self.status
        if self.topic is not None:
            result['topic'] = self.topic
        if self.use_default_eid is not None:
            result['use_default_eid'] = self.use_default_eid
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('event_code') is not None:
            self.event_code = m.get('event_code')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('parent_id') is not None:
            self.parent_id = m.get('parent_id')
        if m.get('rpc_method') is not None:
            self.rpc_method = m.get('rpc_method')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('topic') is not None:
            self.topic = m.get('topic')
        if m.get('use_default_eid') is not None:
            self.use_default_eid = m.get('use_default_eid')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class AddFlowElasticsubruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteFlowElasticsubruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 规则 ID
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteFlowElasticsubruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateFlowElasticrulestatusRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        elastic_rule_ids: List[int] = None,
        new_status: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 命名空间
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 弹性规则ID列表
        self.elastic_rule_ids = elastic_rule_ids
        # VALID("线上生效"), PRESS("仅压测生效"),  INVALID("无效状态");
        self.new_status = new_status

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.elastic_rule_ids, 'elastic_rule_ids')
        self.validate_required(self.new_status, 'new_status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.elastic_rule_ids is not None:
            result['elastic_rule_ids'] = self.elastic_rule_ids
        if self.new_status is not None:
            result['new_status'] = self.new_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('elastic_rule_ids') is not None:
            self.elastic_rule_ids = m.get('elastic_rule_ids')
        if m.get('new_status') is not None:
            self.new_status = m.get('new_status')
        return self


class UpdateFlowElasticrulestatusResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteFlowElasticruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        elastic_rule_ids: List[int] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 弹性规则ID列表
        self.elastic_rule_ids = elastic_rule_ids

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.elastic_rule_ids, 'elastic_rule_ids')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.elastic_rule_ids is not None:
            result['elastic_rule_ids'] = self.elastic_rule_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('elastic_rule_ids') is not None:
            self.elastic_rule_ids = m.get('elastic_rule_ids')
        return self


class BatchdeleteFlowElasticruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateFlowElasticsceneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        name: str = None,
        status: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 场景名
        self.name = name
        # 场景状态，可选值（VALID，INVALID）
        self.status = status

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.name, 'name')
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.name is not None:
            result['name'] = self.name
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class CreateFlowElasticsceneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateFlowElasticsceneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        id: int = None,
        name: str = None,
        status: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 弹性场景 ID
        self.id = id
        # 弹性场景名
        self.name = name
        # 弹性场景状态，可选值（VALID，INVALID）
        self.status = status

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdateFlowElasticsceneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteFlowElasticsceneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 弹性规则场景 ID
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteFlowElasticsceneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class SetFlowElasticvalueRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        elastic_values: List[str] = None,
        gray: bool = None,
        operator: str = None,
        press: bool = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 弹性值，对应zdal里的弹性位，比如52，53等
        self.elastic_values = elastic_values
        # 是否灰度（默认 false）
        self.gray = gray
        # 操作人
        self.operator = operator
        # 是否弹性（默认 false）
        self.press = press
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.elastic_values, 'elastic_values')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.elastic_values is not None:
            result['elastic_values'] = self.elastic_values
        if self.gray is not None:
            result['gray'] = self.gray
        if self.operator is not None:
            result['operator'] = self.operator
        if self.press is not None:
            result['press'] = self.press
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('elastic_values') is not None:
            self.elastic_values = m.get('elastic_values')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('press') is not None:
            self.press = m.get('press')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class SetFlowElasticvalueResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DisableFlowElasticvalueRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        press: bool = None,
        gray: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 是否弹性（默认 false）
        self.press = press
        # 是否灰度（默认 false）
        self.gray = gray

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.press is not None:
            result['press'] = self.press
        if self.gray is not None:
            result['gray'] = self.gray
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('press') is not None:
            self.press = m.get('press')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        return self


class DisableFlowElasticvalueResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateFlowSiteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        description: str = None,
        interface_type: str = None,
        interface_urls: List[str] = None,
        name: str = None,
        operator: str = None,
        site_type: str = None,
        unique_id: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 描述
        self.description = description
        # 推送接口类型，可选值（RPC，REST）
        self.interface_type = interface_type
        # 推送接口 url
        self.interface_urls = interface_urls
        # 站点名
        self.name = name
        # 操作人
        self.operator = operator
        # 站点类型，可选值 MAIN（主站点）， ISOMERISM（异构机房）
        self.site_type = site_type
        # opssla uniqueId
        self.unique_id = unique_id
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.interface_type, 'interface_type')
        self.validate_required(self.interface_urls, 'interface_urls')
        self.validate_required(self.name, 'name')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.site_type, 'site_type')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.description is not None:
            result['description'] = self.description
        if self.interface_type is not None:
            result['interface_type'] = self.interface_type
        if self.interface_urls is not None:
            result['interface_urls'] = self.interface_urls
        if self.name is not None:
            result['name'] = self.name
        if self.operator is not None:
            result['operator'] = self.operator
        if self.site_type is not None:
            result['site_type'] = self.site_type
        if self.unique_id is not None:
            result['unique_id'] = self.unique_id
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('interface_type') is not None:
            self.interface_type = m.get('interface_type')
        if m.get('interface_urls') is not None:
            self.interface_urls = m.get('interface_urls')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('site_type') is not None:
            self.site_type = m.get('site_type')
        if m.get('unique_id') is not None:
            self.unique_id = m.get('unique_id')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class CreateFlowSiteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateFlowSiteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        id: int = None,
        name: str = None,
        description: str = None,
        site_type: str = None,
        interface_type: str = None,
        interface_urls: List[str] = None,
        unique_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 站点 ID
        self.id = id
        # 站点名
        self.name = name
        # 描述
        self.description = description
        # 站点类型，可选值（MAIN， ISOMERISM）
        self.site_type = site_type
        # 接口类型（RPC，REST）
        self.interface_type = interface_type
        # 推送接口url
        self.interface_urls = interface_urls
        # opssla uniqueId
        self.unique_id = unique_id

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.site_type, 'site_type')
        self.validate_required(self.interface_type, 'interface_type')
        self.validate_required(self.interface_urls, 'interface_urls')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.description is not None:
            result['description'] = self.description
        if self.site_type is not None:
            result['site_type'] = self.site_type
        if self.interface_type is not None:
            result['interface_type'] = self.interface_type
        if self.interface_urls is not None:
            result['interface_urls'] = self.interface_urls
        if self.unique_id is not None:
            result['unique_id'] = self.unique_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('site_type') is not None:
            self.site_type = m.get('site_type')
        if m.get('interface_type') is not None:
            self.interface_type = m.get('interface_type')
        if m.get('interface_urls') is not None:
            self.interface_urls = m.get('interface_urls')
        if m.get('unique_id') is not None:
            self.unique_id = m.get('unique_id')
        return self


class UpdateFlowSiteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteFlowSiteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        operator: str = None,
        id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator
        # 站点 ID
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteFlowSiteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateOpsplanRestartRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        auto_execute: bool = None,
        context: str = None,
        dependency: OpsContainerServiceChain = None,
        group_amount: int = None,
        group_orders: List[str] = None,
        group_strategy: str = None,
        need_beta: bool = None,
        restricted_cells: List[str] = None,
        restricted_zones: List[str] = None,
        selected_container_services: OpsContainerServiceGroup = None,
        title: str = None,
        workspace_group: str = None,
        namespace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 是否自动执行
        self.auto_execute = auto_execute
        # 运维单扩展信息，jsonStr格式
        self.context = context
        # 容器服务间依赖顺序。
        # e.g 先发 A，B， 再发C， D
        # {"groups": [{container_services: [{"name": A}, {"name": B}]}, {"container_services": [{"name": C}, {"name": D}]}]}
        self.dependency = dependency
        # 在具体分组策略下，每个执行单元（部署单元，机房等）内部的分组个数。
        self.group_amount = group_amount
        # 用户可自定义分组发布的顺序，结合具体的分组策略并通过指定具体分组维度对应的名称生效。
        # e.g, 当分组策略为机房时，可以指定先发机房A，再发机房B ["A", "B"]
        self.group_orders = group_orders
        # 分组策略（维度）
        # 按部署单元（CELL） - 按部署单元依次重启
        # 按机房（ZONE）- 按机房依次重启
        # 按逻辑单元（UNIT） - 按逻辑单元重启
        # 共分一组（ALL） - 所有容器一起重启，仍遵循分组个数控制
        self.group_strategy = group_strategy
        # 是否需要beta卡点
        self.need_beta = need_beta
        # 限定操作的部署单元
        self.restricted_cells = restricted_cells
        # 限定操作的机房
        self.restricted_zones = restricted_zones
        # 选定的容器服务列表
        self.selected_container_services = selected_container_services
        # 重启单标题
        self.title = title
        # 工作空间组
        self.workspace_group = workspace_group
        # 命名空间
        self.namespace = namespace

    def validate(self):
        if self.dependency:
            self.dependency.validate()
        self.validate_required(self.group_amount, 'group_amount')
        self.validate_required(self.group_strategy, 'group_strategy')
        self.validate_required(self.need_beta, 'need_beta')
        self.validate_required(self.selected_container_services, 'selected_container_services')
        if self.selected_container_services:
            self.selected_container_services.validate()
        self.validate_required(self.title, 'title')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.auto_execute is not None:
            result['auto_execute'] = self.auto_execute
        if self.context is not None:
            result['context'] = self.context
        if self.dependency is not None:
            result['dependency'] = self.dependency.to_map()
        if self.group_amount is not None:
            result['group_amount'] = self.group_amount
        if self.group_orders is not None:
            result['group_orders'] = self.group_orders
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        if self.need_beta is not None:
            result['need_beta'] = self.need_beta
        if self.restricted_cells is not None:
            result['restricted_cells'] = self.restricted_cells
        if self.restricted_zones is not None:
            result['restricted_zones'] = self.restricted_zones
        if self.selected_container_services is not None:
            result['selected_container_services'] = self.selected_container_services.to_map()
        if self.title is not None:
            result['title'] = self.title
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('auto_execute') is not None:
            self.auto_execute = m.get('auto_execute')
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('dependency') is not None:
            temp_model = OpsContainerServiceChain()
            self.dependency = temp_model.from_map(m['dependency'])
        if m.get('group_amount') is not None:
            self.group_amount = m.get('group_amount')
        if m.get('group_orders') is not None:
            self.group_orders = m.get('group_orders')
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        if m.get('need_beta') is not None:
            self.need_beta = m.get('need_beta')
        if m.get('restricted_cells') is not None:
            self.restricted_cells = m.get('restricted_cells')
        if m.get('restricted_zones') is not None:
            self.restricted_zones = m.get('restricted_zones')
        if m.get('selected_container_services') is not None:
            temp_model = OpsContainerServiceGroup()
            self.selected_container_services = temp_model.from_map(m['selected_container_services'])
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class CreateOpsplanRestartResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        operation_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 运维单号
        self.operation_id = operation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class UpdateContainerserviceCommentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        namespace: str = None,
        name: str = None,
        revision: str = None,
        comment: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # wsg
        self.workspace_group = workspace_group
        # fed namespace
        self.namespace = namespace
        # container service name
        self.name = name
        # specific container service revision
        self.revision = revision
        # 版本注释
        self.comment = comment

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.name, 'name')
        self.validate_required(self.revision, 'revision')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.name is not None:
            result['name'] = self.name
        if self.revision is not None:
            result['revision'] = self.revision
        if self.comment is not None:
            result['comment'] = self.comment
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('comment') is not None:
            self.comment = m.get('comment')
        return self


class UpdateContainerserviceCommentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class RollbackContainerserviceDeploymentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        container_service_name: str = None,
        namespace: str = None,
        revision: str = None,
        operation_id: str = None,
        operator: str = None,
        group_count: int = None,
        group_strategy: str = None,
        reason: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属工作空间组名称
        self.workspace_group = workspace_group
        # 容器服务名字
        self.container_service_name = container_service_name
        # 所属命名空间名称
        self.namespace = namespace
        # 回滚的版本
        self.revision = revision
        # 部署单ID
        self.operation_id = operation_id
        # 操作人账号
        self.operator = operator
        # 分组数，默认为3
        self.group_count = group_count
        # 回滚时的分组策略，取值为： QUICK：快速分组； EACH_ONE：每台一组； UNIT：按逻辑单元分组； CELL：按部署单元分组； 默认为CELL
        self.group_strategy = group_strategy
        # 回滚原因
        self.reason = reason

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.revision, 'revision')
        self.validate_required(self.operation_id, 'operation_id')
        self.validate_required(self.reason, 'reason')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.revision is not None:
            result['revision'] = self.revision
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.operator is not None:
            result['operator'] = self.operator
        if self.group_count is not None:
            result['group_count'] = self.group_count
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        if self.reason is not None:
            result['reason'] = self.reason
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('group_count') is not None:
            self.group_count = m.get('group_count')
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        return self


class RollbackContainerserviceDeploymentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryFlowUidinfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        elastic: bool = None,
        gray: bool = None,
        press: bool = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 是否弹性（默认 false）
        self.elastic = elastic
        # 是否灰度（默认 false）
        self.gray = gray
        # 是否压测（默认 false）
        self.press = press
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.elastic is not None:
            result['elastic'] = self.elastic
        if self.gray is not None:
            result['gray'] = self.gray
        if self.press is not None:
            result['press'] = self.press
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('elastic') is not None:
            self.elastic = m.get('elastic')
        if m.get('gray') is not None:
            self.gray = m.get('gray')
        if m.get('press') is not None:
            self.press = m.get('press')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryFlowUidinfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        uid_info_list: List[UidInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # UID 列表
        self.uid_info_list = uid_info_list

    def validate(self):
        if self.uid_info_list:
            for k in self.uid_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['uid_info_list'] = []
        if self.uid_info_list is not None:
            for k in self.uid_info_list:
                result['uid_info_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.uid_info_list = []
        if m.get('uid_info_list') is not None:
            for k in m.get('uid_info_list'):
                temp_model = UidInfo()
                self.uid_info_list.append(temp_model.from_map(k))
        return self


class QueryFlowSiteRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryFlowSiteResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        sites: List[PushSite] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 当前环境的站点列表
        self.sites = sites

    def validate(self):
        if self.sites:
            for k in self.sites:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['sites'] = []
        if self.sites is not None:
            for k in self.sites:
                result['sites'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.sites = []
        if m.get('sites') is not None:
            for k in m.get('sites'):
                temp_model = PushSite()
                self.sites.append(temp_model.from_map(k))
        return self


class GetCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group: str = None,
        workspace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单元名称。
        self.name = name
        # 所属环境信息。
        self.workspace_group = workspace_group
        # 所属工作空间名称。
        self.workspace = workspace

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.workspace, 'workspace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class GetCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell: Cell = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 部署单元信息。
        self.cell = cell

    def validate(self):
        if self.cell:
            self.cell.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cell is not None:
            result['cell'] = self.cell.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cell') is not None:
            temp_model = Cell()
            self.cell = temp_model.from_map(m['cell'])
        return self


class GetCellgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属环境信息。
        self.workspace_group = workspace_group
        # 逻辑单元名称。
        self.name = name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetCellgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell_group: CellGroup = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 逻辑单元信息。
        self.cell_group = cell_group

    def validate(self):
        if self.cell_group:
            self.cell_group.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cell_group is not None:
            result['cell_group'] = self.cell_group.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cell_group') is not None:
            temp_model = CellGroup()
            self.cell_group = temp_model.from_map(m['cell_group'])
        return self


class UpdateCellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        color: str = None,
        is_gray: bool = None,
        name: str = None,
        weight: int = None,
        workspace_group: str = None,
        workspace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 蓝绿着色信息。
        self.color = color
        # 是否灰度。
        self.is_gray = is_gray
        # 部署单元名称。
        self.name = name
        # 默认权重。
        self.weight = weight
        # 所属环境信息。
        self.workspace_group = workspace_group
        # 所属工作空间名称。
        self.workspace = workspace

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.workspace, 'workspace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.color is not None:
            result['color'] = self.color
        if self.is_gray is not None:
            result['is_gray'] = self.is_gray
        if self.name is not None:
            result['name'] = self.name
        if self.weight is not None:
            result['weight'] = self.weight
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.workspace is not None:
            result['workspace'] = self.workspace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('color') is not None:
            self.color = m.get('color')
        if m.get('is_gray') is not None:
            self.is_gray = m.get('is_gray')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('weight') is not None:
            self.weight = m.get('weight')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        return self


class UpdateCellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListEventsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster: str = None,
        container_name: str = None,
        name: str = None,
        namespace: str = None,
        uid: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 集群名
        self.cluster = cluster
        # 容器名称
        self.container_name = container_name
        # pod名称
        self.name = name
        # namespace
        self.namespace = namespace
        # pod uid
        self.uid = uid
        # wsg
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.uid, 'uid')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.container_name is not None:
            result['container_name'] = self.container_name
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.uid is not None:
            result['uid'] = self.uid
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('container_name') is not None:
            self.container_name = m.get('container_name')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('uid') is not None:
            self.uid = m.get('uid')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListEventsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        events: List[KubeEvent] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 事件列表
        self.events = events

    def validate(self):
        if self.events:
            for k in self.events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['events'] = []
        if self.events is not None:
            for k in self.events:
                result['events'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.events = []
        if m.get('events') is not None:
            for k in m.get('events'):
                temp_model = KubeEvent()
                self.events.append(temp_model.from_map(k))
        return self


class ListRegionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class ListRegionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        regions: List[Region] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 地域列表
        self.regions = regions

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['regions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.regions = []
        if m.get('regions') is not None:
            for k in m.get('regions'):
                temp_model = Region()
                self.regions.append(temp_model.from_map(k))
        return self


class ListZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class ListZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        zones: List[Zone] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 可用区列表
        self.zones = zones

    def validate(self):
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.zones = []
        if m.get('zones') is not None:
            for k in m.get('zones'):
                temp_model = Zone()
                self.zones.append(temp_model.from_map(k))
        return self


class QueryPodLogRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster: str = None,
        container_name: str = None,
        namespace: str = None,
        pod_name: str = None,
        since_seconds: int = None,
        tail_lines: int = None,
        timestamps: bool = None,
        minion_cluster_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 集群名称
        self.cluster = cluster
        # 容器名称
        # The container for which to stream logs. Defaults to only container if there is one container in the pod. (optional)
        self.container_name = container_name
        # namespace
        self.namespace = namespace
        # pod名称
        self.pod_name = pod_name
        # A relative time in seconds before the current time from which to show logs. If this value precedes the time a pod was started, only logs since the pod start will be returned. If this value is in the future, no logs will be returned. Only one of sinceSeconds or sinceTime may be specified. (optional)
        self.since_seconds = since_seconds
        # the number of lines from the end of the logs to show
        self.tail_lines = tail_lines
        # If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line of log output. Defaults to false. (optional)
        self.timestamps = timestamps
        # cluster对应的aks中minion cluster的id
        self.minion_cluster_id = minion_cluster_id

    def validate(self):
        self.validate_required(self.cluster, 'cluster')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.pod_name, 'pod_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster is not None:
            result['cluster'] = self.cluster
        if self.container_name is not None:
            result['container_name'] = self.container_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.pod_name is not None:
            result['pod_name'] = self.pod_name
        if self.since_seconds is not None:
            result['since_seconds'] = self.since_seconds
        if self.tail_lines is not None:
            result['tail_lines'] = self.tail_lines
        if self.timestamps is not None:
            result['timestamps'] = self.timestamps
        if self.minion_cluster_id is not None:
            result['minion_cluster_id'] = self.minion_cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster') is not None:
            self.cluster = m.get('cluster')
        if m.get('container_name') is not None:
            self.container_name = m.get('container_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('pod_name') is not None:
            self.pod_name = m.get('pod_name')
        if m.get('since_seconds') is not None:
            self.since_seconds = m.get('since_seconds')
        if m.get('tail_lines') is not None:
            self.tail_lines = m.get('tail_lines')
        if m.get('timestamps') is not None:
            self.timestamps = m.get('timestamps')
        if m.get('minion_cluster_id') is not None:
            self.minion_cluster_id = m.get('minion_cluster_id')
        return self


class QueryPodLogResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # the logs
        self.data = data

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class CreateSpannerClusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_cpu: int = None,
        container_cpu_exclusive: bool = None,
        container_device_type: str = None,
        container_disk: int = None,
        container_mem: int = None,
        container_network: str = None,
        name: str = None,
        unit_type: int = None,
        workspace_group: str = None,
        address_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器的CPU个数(Core)
        self.container_cpu = container_cpu
        # 容器是否独占CPU
        self.container_cpu_exclusive = container_cpu_exclusive
        # 容器所在的物理机节点标签
        self.container_device_type = container_device_type
        # 容器的磁盘大小(G)
        self.container_disk = container_disk
        # 容器的内存大小（G）
        self.container_mem = container_mem
        # 容器网络
        self.container_network = container_network
        # 集群名称
        self.name = name
        # 集群单元类型，默认为 0 :
        # 0 - 容器
        self.unit_type = unit_type
        # 工作空间组
        self.workspace_group = workspace_group
        # 集群网络类型，internet/intranet/multidomain/office
        self.address_type = address_type

    def validate(self):
        self.validate_required(self.container_cpu, 'container_cpu')
        self.validate_required(self.container_cpu_exclusive, 'container_cpu_exclusive')
        self.validate_required(self.container_device_type, 'container_device_type')
        self.validate_required(self.container_disk, 'container_disk')
        self.validate_required(self.container_mem, 'container_mem')
        self.validate_required(self.container_network, 'container_network')
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.address_type, 'address_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_cpu is not None:
            result['container_cpu'] = self.container_cpu
        if self.container_cpu_exclusive is not None:
            result['container_cpu_exclusive'] = self.container_cpu_exclusive
        if self.container_device_type is not None:
            result['container_device_type'] = self.container_device_type
        if self.container_disk is not None:
            result['container_disk'] = self.container_disk
        if self.container_mem is not None:
            result['container_mem'] = self.container_mem
        if self.container_network is not None:
            result['container_network'] = self.container_network
        if self.name is not None:
            result['name'] = self.name
        if self.unit_type is not None:
            result['unit_type'] = self.unit_type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.address_type is not None:
            result['address_type'] = self.address_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_cpu') is not None:
            self.container_cpu = m.get('container_cpu')
        if m.get('container_cpu_exclusive') is not None:
            self.container_cpu_exclusive = m.get('container_cpu_exclusive')
        if m.get('container_device_type') is not None:
            self.container_device_type = m.get('container_device_type')
        if m.get('container_disk') is not None:
            self.container_disk = m.get('container_disk')
        if m.get('container_mem') is not None:
            self.container_mem = m.get('container_mem')
        if m.get('container_network') is not None:
            self.container_network = m.get('container_network')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('unit_type') is not None:
            self.unit_type = m.get('unit_type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('address_type') is not None:
            self.address_type = m.get('address_type')
        return self


class CreateSpannerClusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cluster_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 集群id
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        return self


class GetSpannerClusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        cluster_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 集群id
        self.cluster_id = cluster_id

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.cluster_id, 'cluster_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        return self


class GetSpannerClusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: SpannerClusterInfo = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # spanner 集群信息
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = SpannerClusterInfo()
            self.data = temp_model.from_map(m['data'])
        return self


class ScaleSpannerClusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_id: str = None,
        container_count: int = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 集群id
        self.cluster_id = cluster_id
        # 需要扩容的单元数目
        self.container_count = container_count
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.cluster_id, 'cluster_id')
        self.validate_required(self.container_count, 'container_count')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.container_count is not None:
            result['container_count'] = self.container_count
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('container_count') is not None:
            self.container_count = m.get('container_count')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ScaleSpannerClusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cluster_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 集群id
        self.cluster_id = cluster_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        return self


class QuerySpannerClusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QuerySpannerClusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        list: List[SpannerClusterInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # spanner集群列表
        self.list = list

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = SpannerClusterInfo()
                self.list.append(temp_model.from_map(k))
        return self


class UpdateSpannerClusterstatusRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_id: str = None,
        status: int = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 集群id
        self.cluster_id = cluster_id
        # 设置集群的状态： 1 运行状态  2 维护状态
        self.status = status
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.cluster_id, 'cluster_id')
        self.validate_required(self.status, 'status')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.status is not None:
            result['status'] = self.status
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateSpannerClusterstatusResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateSpannerUnitstatusRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        cluster_id: str = None,
        container_ids: List[str] = None,
        status: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 集群id
        self.cluster_id = cluster_id
        # 容器id列表
        self.container_ids = container_ids
        # 集群单元状态： 1-下线状态 2- 上线状态 3-删除状态
        self.status = status

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.cluster_id, 'cluster_id')
        self.validate_required(self.container_ids, 'container_ids')
        self.validate_required(self.status, 'status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.container_ids is not None:
            result['container_ids'] = self.container_ids
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('container_ids') is not None:
            self.container_ids = m.get('container_ids')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class UpdateSpannerUnitstatusResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CancelOpsplanServiceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: str = None,
        reason: str = None,
        operator: str = None,
        huanyu_exec_no: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单下应用服务对应的发布id
        self.id = id
        # 取消原因
        self.reason = reason
        # 操作人账号，lks1.23.0才支持
        self.operator = operator
        # [huanyu场景使用]huanyu变更单唯一id
        self.huanyu_exec_no = huanyu_exec_no

    def validate(self):
        self.validate_required(self.reason, 'reason')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.reason is not None:
            result['reason'] = self.reason
        if self.operator is not None:
            result['operator'] = self.operator
        if self.huanyu_exec_no is not None:
            result['huanyu_exec_no'] = self.huanyu_exec_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('reason') is not None:
            self.reason = m.get('reason')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('huanyu_exec_no') is not None:
            self.huanyu_exec_no = m.get('huanyu_exec_no')
        return self


class CancelOpsplanServiceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListSystemUrlRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspaceGroup name
        self.workspace_group = workspace_group

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListSystemUrlResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        url_list: List[SystemURL] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 系统配置的url列表
        self.url_list = url_list

    def validate(self):
        if self.url_list:
            for k in self.url_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['url_list'] = []
        if self.url_list is not None:
            for k in self.url_list:
                result['url_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.url_list = []
        if m.get('url_list') is not None:
            for k in m.get('url_list'):
                temp_model = SystemURL()
                self.url_list.append(temp_model.from_map(k))
        return self


class QueryFlowRecordRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app: str = None,
        end_time: str = None,
        page_no: int = None,
        page_size: int = None,
        result_code: str = None,
        start_time: str = None,
        workspace_group: str = None,
        rule_type: str = None,
        push_target: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app 名称
        self.app = app
        # 结束时间
        self.end_time = end_time
        # 查询页
        self.page_no = page_no
        # 页大小
        self.page_size = page_size
        # 推送状态，可选（SUCCESS，FAILED，INVALID_REQUEST，NO_RECORD，SYSTEM_EXCEPTION，PARAM_QUERY_ERROR，PARAM_INVALID）
        self.result_code = result_code
        # 开始时间
        self.start_time = start_time
        # 环境
        self.workspace_group = workspace_group
        # 规则类型
        self.rule_type = rule_type
        # 推送目标，可选（MAIN、MIDDLEWARE、ALB）
        self.push_target = push_target

    def validate(self):
        if self.end_time is not None:
            self.validate_pattern(self.end_time, 'end_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.start_time is not None:
            self.validate_pattern(self.start_time, 'start_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app is not None:
            result['app'] = self.app
        if self.end_time is not None:
            result['end_time'] = self.end_time
        if self.page_no is not None:
            result['page_no'] = self.page_no
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.start_time is not None:
            result['start_time'] = self.start_time
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.push_target is not None:
            result['push_target'] = self.push_target
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('end_time') is not None:
            self.end_time = m.get('end_time')
        if m.get('page_no') is not None:
            self.page_no = m.get('page_no')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('start_time') is not None:
            self.start_time = m.get('start_time')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('push_target') is not None:
            self.push_target = m.get('push_target')
        return self


class QueryFlowRecordResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        current_page: int = None,
        data: List[DrmOpsRecord] = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 当前页
        self.current_page = current_page
        # 推送记录
        self.data = data
        # 页大小
        self.page_size = page_size
        # 总数
        self.total_count = total_count

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.current_page is not None:
            result['current_page'] = self.current_page
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DrmOpsRecord()
                self.data.append(temp_model.from_map(k))
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class SaveFlowEnvrelRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        dest: str = None,
        src: str = None,
        type: str = None,
        workspace_group: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 目标环境
        self.dest = dest
        # 源环境
        self.src = src
        # 关联关系：可选（PROD，GRAY）
        self.type = type
        # 环境
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator

    def validate(self):
        self.validate_required(self.dest, 'dest')
        self.validate_required(self.src, 'src')
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.dest is not None:
            result['dest'] = self.dest
        if self.src is not None:
            result['src'] = self.src
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('dest') is not None:
            self.dest = m.get('dest')
        if m.get('src') is not None:
            self.src = m.get('src')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class SaveFlowEnvrelResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteFlowEnvrelRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        dest: str = None,
        src: str = None,
        type: str = None,
        workspace_group: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 目标环境
        self.dest = dest
        # 源环境
        self.src = src
        # 关联类型（PROD，GRAY）
        self.type = type
        # 环境
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator

    def validate(self):
        self.validate_required(self.dest, 'dest')
        self.validate_required(self.src, 'src')
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.dest is not None:
            result['dest'] = self.dest
        if self.src is not None:
            result['src'] = self.src
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('dest') is not None:
            self.dest = m.get('dest')
        if m.get('src') is not None:
            self.src = m.get('src')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class DeleteFlowEnvrelResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryFlowEnvrelRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        src: str = None,
        type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境
        self.workspace_group = workspace_group
        # 源环境
        self.src = src
        # 关联类型
        self.type = type

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.src, 'src')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.src is not None:
            result['src'] = self.src
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('src') is not None:
            self.src = m.get('src')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class QueryFlowEnvrelResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        src: str = None,
        dest: str = None,
        type: str = None,
        created_time: str = None,
        modified_time: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 源环境
        self.src = src
        # 目标环境
        self.dest = dest
        # 关联类型（PROD，GRAY）
        self.type = type
        # 创建时间
        self.created_time = created_time
        # 修改时间
        self.modified_time = modified_time

    def validate(self):
        if self.created_time is not None:
            self.validate_pattern(self.created_time, 'created_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.modified_time is not None:
            self.validate_pattern(self.modified_time, 'modified_time', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.src is not None:
            result['src'] = self.src
        if self.dest is not None:
            result['dest'] = self.dest
        if self.type is not None:
            result['type'] = self.type
        if self.created_time is not None:
            result['created_time'] = self.created_time
        if self.modified_time is not None:
            result['modified_time'] = self.modified_time
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('src') is not None:
            self.src = m.get('src')
        if m.get('dest') is not None:
            self.dest = m.get('dest')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('created_time') is not None:
            self.created_time = m.get('created_time')
        if m.get('modified_time') is not None:
            self.modified_time = m.get('modified_time')
        return self


class CreateFlowSitecellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        region: str = None,
        site_name: str = None,
        workspace_group: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 异构机房部署单元
        self.name = name
        # 异构机房地域
        self.region = region
        # 异构机房名称
        self.site_name = site_name
        # 环境
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.region, 'region')
        self.validate_required(self.site_name, 'site_name')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.region is not None:
            result['region'] = self.region
        if self.site_name is not None:
            result['site_name'] = self.site_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('region') is not None:
            self.region = m.get('region')
        if m.get('site_name') is not None:
            self.site_name = m.get('site_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class CreateFlowSitecellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteFlowSitecellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        site_name: str = None,
        workspace_group: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 部署单元
        self.name = name
        # 异构机房名
        self.site_name = site_name
        # 环境
        self.workspace_group = workspace_group
        # 操作人
        self.operator = operator

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.site_name, 'site_name')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.site_name is not None:
            result['site_name'] = self.site_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('site_name') is not None:
            self.site_name = m.get('site_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class DeleteFlowSitecellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryFlowSitecellRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        site_name: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 异构机房名
        self.site_name = site_name
        # 环境
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.site_name, 'site_name')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.site_name is not None:
            result['site_name'] = self.site_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('site_name') is not None:
            self.site_name = m.get('site_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryFlowSitecellResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        site_cells: List[SiteCell] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 部署单元列表
        self.site_cells = site_cells

    def validate(self):
        if self.site_cells:
            for k in self.site_cells:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['site_cells'] = []
        if self.site_cells is not None:
            for k in self.site_cells:
                result['site_cells'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.site_cells = []
        if m.get('site_cells') is not None:
            for k in m.get('site_cells'):
                temp_model = SiteCell()
                self.site_cells.append(temp_model.from_map(k))
        return self


class GetOpsplanServiceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 发布单下应用服务对应的发布id
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class GetOpsplanServiceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: AppSimpleInfo = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 发布应用服务详情
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = AppSimpleInfo()
            self.data = temp_model.from_map(m['data'])
        return self


class QueryFlowRuleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        rule_type: str = None,
        push_target: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境
        self.workspace_group = workspace_group
        # 规则类型：ZONE_INFO,ELASTIC_BIZ_RULE,ZONE_COLOR
        self.rule_type = rule_type
        # 推送目标类型: MAIN, MIDDLEWARE, ALB
        self.push_target = push_target

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.rule_type, 'rule_type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.rule_type is not None:
            result['rule_type'] = self.rule_type
        if self.push_target is not None:
            result['push_target'] = self.push_target
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('rule_type') is not None:
            self.rule_type = m.get('rule_type')
        if m.get('push_target') is not None:
            self.push_target = m.get('push_target')
        return self


class QueryFlowRuleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        rule: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 规则文本
        self.rule = rule

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.rule is not None:
            result['rule'] = self.rule
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('rule') is not None:
            self.rule = m.get('rule')
        return self


class CreateFederationDeploymentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app: str = None,
        clusters: List[str] = None,
        cluster_overrides: List[FedDeploymentClusterOverride] = None,
        dns_policy: str = None,
        host_network: bool = None,
        name: str = None,
        namespace: str = None,
        pod_spec: PodSpec = None,
        replicas: int = None,
        volumes: List[Volume] = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属应用
        self.app = app
        # clusters
        self.clusters = clusters
        # FedDeploymentClusterOverride描述
        self.cluster_overrides = cluster_overrides
        # DNS配置
        self.dns_policy = dns_policy
        # Host networking requested for this pod
        self.host_network = host_network
        # 名称
        self.name = name
        # 命名空间
        self.namespace = namespace
        # Pod模板描述
        self.pod_spec = pod_spec
        # Deployment 副本数
        self.replicas = replicas
        # Pod volume list
        self.volumes = volumes
        # 环境组名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.app, 'app')
        self.validate_required(self.clusters, 'clusters')
        if self.cluster_overrides:
            for k in self.cluster_overrides:
                if k:
                    k.validate()
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.pod_spec, 'pod_spec')
        if self.pod_spec:
            self.pod_spec.validate()
        self.validate_required(self.replicas, 'replicas')
        if self.volumes:
            for k in self.volumes:
                if k:
                    k.validate()
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app is not None:
            result['app'] = self.app
        if self.clusters is not None:
            result['clusters'] = self.clusters
        result['cluster_overrides'] = []
        if self.cluster_overrides is not None:
            for k in self.cluster_overrides:
                result['cluster_overrides'].append(k.to_map() if k else None)
        if self.dns_policy is not None:
            result['dns_policy'] = self.dns_policy
        if self.host_network is not None:
            result['host_network'] = self.host_network
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.pod_spec is not None:
            result['pod_spec'] = self.pod_spec.to_map()
        if self.replicas is not None:
            result['replicas'] = self.replicas
        result['volumes'] = []
        if self.volumes is not None:
            for k in self.volumes:
                result['volumes'].append(k.to_map() if k else None)
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app') is not None:
            self.app = m.get('app')
        if m.get('clusters') is not None:
            self.clusters = m.get('clusters')
        self.cluster_overrides = []
        if m.get('cluster_overrides') is not None:
            for k in m.get('cluster_overrides'):
                temp_model = FedDeploymentClusterOverride()
                self.cluster_overrides.append(temp_model.from_map(k))
        if m.get('dns_policy') is not None:
            self.dns_policy = m.get('dns_policy')
        if m.get('host_network') is not None:
            self.host_network = m.get('host_network')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('pod_spec') is not None:
            temp_model = PodSpec()
            self.pod_spec = temp_model.from_map(m['pod_spec'])
        if m.get('replicas') is not None:
            self.replicas = m.get('replicas')
        self.volumes = []
        if m.get('volumes') is not None:
            for k in m.get('volumes'):
                temp_model = Volume()
                self.volumes.append(temp_model.from_map(k))
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class CreateFederationDeploymentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        name: str = None,
        namespace: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # name
        self.name = name
        # 命名空间
        self.namespace = namespace

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class QueryLoadbalancerRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        type: str = None,
        workspace_group: str = None,
        namespace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 负载均衡类型。
        self.type = type
        # 工作空间组名称。
        self.workspace_group = workspace_group
        # 所属namespace名称。
        self.namespace = namespace

    def validate(self):
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.type is not None:
            result['type'] = self.type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class QueryLoadbalancerResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        load_balancers: List[LoadBalancerInstance] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 负载均衡实例列表。
        self.load_balancers = load_balancers

    def validate(self):
        if self.load_balancers:
            for k in self.load_balancers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['load_balancers'] = []
        if self.load_balancers is not None:
            for k in self.load_balancers:
                result['load_balancers'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.load_balancers = []
        if m.get('load_balancers') is not None:
            for k in m.get('load_balancers'):
                temp_model = LoadBalancerInstance()
                self.load_balancers.append(temp_model.from_map(k))
        return self


class ListContainerserviceServiceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service_name: str = None,
        namespace: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器服务名称
        self.container_service_name = container_service_name
        # 命名空间名称
        self.namespace = namespace
        # 工作空间组名称
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListContainerserviceServiceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        services: List[ServiceInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 容器服务 Service 列表
        self.services = services

    def validate(self):
        if self.services:
            for k in self.services:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['services'] = []
        if self.services is not None:
            for k in self.services:
                result['services'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.services = []
        if m.get('services') is not None:
            for k in m.get('services'):
                temp_model = ServiceInfo()
                self.services.append(temp_model.from_map(k))
        return self


class ListSidecarRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        region_id: str = None,
        scope: str = None,
        workspace: str = None,
        workspace_group_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # region_id
        self.region_id = region_id
        # scope
        self.scope = scope
        # workspace
        self.workspace = workspace
        # workspace_group_id
        self.workspace_group_id = workspace_group_id

    def validate(self):
        self.validate_required(self.scope, 'scope')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.region_id is not None:
            result['region_id'] = self.region_id
        if self.scope is not None:
            result['scope'] = self.scope
        if self.workspace is not None:
            result['workspace'] = self.workspace
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('region_id') is not None:
            self.region_id = m.get('region_id')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        return self


class ListSidecarResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        sidecars: List[SideCar] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # sidecars
        self.sidecars = sidecars

    def validate(self):
        if self.sidecars:
            for k in self.sidecars:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['sidecars'] = []
        if self.sidecars is not None:
            for k in self.sidecars:
                result['sidecars'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.sidecars = []
        if m.get('sidecars') is not None:
            for k in m.get('sidecars'):
                temp_model = SideCar()
                self.sidecars.append(temp_model.from_map(k))
        return self


class ListSidecarTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        region_id: str = None,
        scope: str = None,
        sidecar_name: str = None,
        sidecar_version: str = None,
        workspace: str = None,
        workspace_group_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # region_id
        self.region_id = region_id
        # sidecar生效范围：workspace、workspace_group、region
        self.scope = scope
        # sidecar_name
        self.sidecar_name = sidecar_name
        # sidecar version
        self.sidecar_version = sidecar_version
        # 环境
        self.workspace = workspace
        # workspace_group_id
        self.workspace_group_id = workspace_group_id

    def validate(self):
        self.validate_required(self.scope, 'scope')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.region_id is not None:
            result['region_id'] = self.region_id
        if self.scope is not None:
            result['scope'] = self.scope
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('region_id') is not None:
            self.region_id = m.get('region_id')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        return self


class ListSidecarTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        sidecar_templates: List[SidecarTemplate] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # sidecar 模板列表
        self.sidecar_templates = sidecar_templates

    def validate(self):
        if self.sidecar_templates:
            for k in self.sidecar_templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['sidecar_templates'] = []
        if self.sidecar_templates is not None:
            for k in self.sidecar_templates:
                result['sidecar_templates'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.sidecar_templates = []
        if m.get('sidecar_templates') is not None:
            for k in m.get('sidecar_templates'):
                temp_model = SidecarTemplate()
                self.sidecar_templates.append(temp_model.from_map(k))
        return self


class GetSidecarTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        region_id: str = None,
        scope: str = None,
        sidecar_name: str = None,
        sidecar_version: str = None,
        workspace: str = None,
        workspace_group_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # region_id
        self.region_id = region_id
        # sidecar生效范围：workspace、workspace_group、region
        self.scope = scope
        # sidecar 名称
        self.sidecar_name = sidecar_name
        # sidecar 版本
        self.sidecar_version = sidecar_version
        # 环境
        self.workspace = workspace
        # wsg id
        self.workspace_group_id = workspace_group_id

    def validate(self):
        self.validate_required(self.scope, 'scope')
        self.validate_required(self.sidecar_name, 'sidecar_name')
        self.validate_required(self.sidecar_version, 'sidecar_version')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.region_id is not None:
            result['region_id'] = self.region_id
        if self.scope is not None:
            result['scope'] = self.scope
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.workspace is not None:
            result['workspace'] = self.workspace
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('region_id') is not None:
            self.region_id = m.get('region_id')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('workspace') is not None:
            self.workspace = m.get('workspace')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        return self


class GetSidecarTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        sidecar_template: SidecarTemplate = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # sidecar 版本详情
        self.sidecar_template = sidecar_template

    def validate(self):
        if self.sidecar_template:
            self.sidecar_template.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.sidecar_template is not None:
            result['sidecar_template'] = self.sidecar_template.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('sidecar_template') is not None:
            temp_model = SidecarTemplate()
            self.sidecar_template = temp_model.from_map(m['sidecar_template'])
        return self


class GetFederationDeploymentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # FedDeployment名称
        self.name = name
        # workspaceGroup 名称
        # 
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class GetFederationDeploymentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: FederatedDeployment = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 联邦无状态工作负载
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = FederatedDeployment()
            self.data = temp_model.from_map(m['data'])
        return self


class ListFederationDeploymentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        namespace: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # namespace
        self.namespace = namespace
        # 环境组名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class ListFederationDeploymentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[FederatedDeployment] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # FederatedDeploymment列表
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = FederatedDeployment()
                self.data.append(temp_model.from_map(k))
        return self


class DeleteFederationDeploymentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # FedDeployment名称
        self.name = name
        # 环境组名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class DeleteFederationDeploymentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 删除成功标志
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class SetFlowDefaultuidRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        press: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境
        self.workspace_group = workspace_group
        # 是否压测，默认 false
        self.press = press

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.press is not None:
            result['press'] = self.press
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('press') is not None:
            self.press = m.get('press')
        return self


class SetFlowDefaultuidResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class StartOpsplanServiceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: str = None,
        workspace_group: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务发布ID
        self.id = id
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人账号，lks1.23.0才支持
        self.operator = operator

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class StartOpsplanServiceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ConfirmOpsplanServicerollbackRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: str = None,
        workspace_group: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务发布id
        self.id = id
        # 工作空间组
        self.workspace_group = workspace_group
        # 操作人账号
        self.operator = operator

    def validate(self):
        self.validate_required(self.id, 'id')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class ConfirmOpsplanServicerollbackResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class RetryOpsplanServiceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务发布id
        self.id = id
        # 操作人账号，lks1.23.0才支持
        self.operator = operator

    def validate(self):
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class RetryOpsplanServiceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryFlowElasticsceneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryFlowElasticsceneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        scenes: List[ElasticScene] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 弹性场景列表
        self.scenes = scenes

    def validate(self):
        if self.scenes:
            for k in self.scenes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['scenes'] = []
        if self.scenes is not None:
            for k in self.scenes:
                result['scenes'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.scenes = []
        if m.get('scenes') is not None:
            for k in m.get('scenes'):
                temp_model = ElasticScene()
                self.scenes.append(temp_model.from_map(k))
        return self


class QueryFlowElasticruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        name: str = None,
        type: str = None,
        app_name: str = None,
        scene_name: str = None,
        page_size: int = None,
        page_no: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境
        self.workspace_group = workspace_group
        # 规则名称
        self.name = name
        # 所属类型
        self.type = type
        # 所属应用名称
        self.app_name = app_name
        # 场景名称
        self.scene_name = scene_name
        # 分页大小，默认 10
        self.page_size = page_size
        # 当前页，默认 1
        self.page_no = page_no

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.scene_name is not None:
            result['scene_name'] = self.scene_name
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.page_no is not None:
            result['page_no'] = self.page_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('scene_name') is not None:
            self.scene_name = m.get('scene_name')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('page_no') is not None:
            self.page_no = m.get('page_no')
        return self


class QueryFlowElasticruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        elastic_rules: List[ElasticRuleView] = None,
        total: int = None,
        page_no: int = None,
        page_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 弹性规则列表
        self.elastic_rules = elastic_rules
        # 总数
        self.total = total
        # 当前页
        self.page_no = page_no
        # 分页大小
        self.page_size = page_size

    def validate(self):
        if self.elastic_rules:
            for k in self.elastic_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['elastic_rules'] = []
        if self.elastic_rules is not None:
            for k in self.elastic_rules:
                result['elastic_rules'].append(k.to_map() if k else None)
        if self.total is not None:
            result['total'] = self.total
        if self.page_no is not None:
            result['page_no'] = self.page_no
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.elastic_rules = []
        if m.get('elastic_rules') is not None:
            for k in m.get('elastic_rules'):
                temp_model = ElasticRuleView()
                self.elastic_rules.append(temp_model.from_map(k))
        if m.get('total') is not None:
            self.total = m.get('total')
        if m.get('page_no') is not None:
            self.page_no = m.get('page_no')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryFlowElasticsubruleRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        elastic_rule_id: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境
        self.workspace_group = workspace_group
        # 弹性规则ID
        self.elastic_rule_id = elastic_rule_id

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.elastic_rule_id, 'elastic_rule_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.elastic_rule_id is not None:
            result['elastic_rule_id'] = self.elastic_rule_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('elastic_rule_id') is not None:
            self.elastic_rule_id = m.get('elastic_rule_id')
        return self


class QueryFlowElasticsubruleResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        sub_rules: List[ElasticSubRuleView] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 子规则列表
        self.sub_rules = sub_rules

    def validate(self):
        if self.sub_rules:
            for k in self.sub_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['sub_rules'] = []
        if self.sub_rules is not None:
            for k in self.sub_rules:
                result['sub_rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.sub_rules = []
        if m.get('sub_rules') is not None:
            for k in m.get('sub_rules'):
                temp_model = ElasticSubRuleView()
                self.sub_rules.append(temp_model.from_map(k))
        return self


class QueryFlowElasticvalueRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryFlowElasticvalueResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        elastic_info: List[ElasticInfoView] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 弹性信息
        self.elastic_info = elastic_info

    def validate(self):
        if self.elastic_info:
            for k in self.elastic_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['elastic_info'] = []
        if self.elastic_info is not None:
            for k in self.elastic_info:
                result['elastic_info'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.elastic_info = []
        if m.get('elastic_info') is not None:
            for k in m.get('elastic_info'):
                temp_model = ElasticInfoView()
                self.elastic_info.append(temp_model.from_map(k))
        return self


class ListSystemSwitchRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class ListSystemSwitchResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        switches: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 开关集合jarrya son string
        self.switches = switches

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.switches is not None:
            result['switches'] = self.switches
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('switches') is not None:
            self.switches = m.get('switches')
        return self


class LoadBuildpackDockerfileRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        tech_stack: str = None,
        tech_stack_version: str = None,
        package_url: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 技术栈大版本
        self.tech_stack = tech_stack
        # 云原生技术栈版本
        self.tech_stack_version = tech_stack_version
        # 应用包地址，可以为相对目录，或者远程可访问存储地址. 用于组装Dockerfile模板中对应的应用包获取地址
        self.package_url = package_url

    def validate(self):
        self.validate_required(self.tech_stack, 'tech_stack')
        self.validate_required(self.tech_stack_version, 'tech_stack_version')
        self.validate_required(self.package_url, 'package_url')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.tech_stack is not None:
            result['tech_stack'] = self.tech_stack
        if self.tech_stack_version is not None:
            result['tech_stack_version'] = self.tech_stack_version
        if self.package_url is not None:
            result['package_url'] = self.package_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('tech_stack') is not None:
            self.tech_stack = m.get('tech_stack')
        if m.get('tech_stack_version') is not None:
            self.tech_stack_version = m.get('tech_stack_version')
        if m.get('package_url') is not None:
            self.package_url = m.get('package_url')
        return self


class LoadBuildpackDockerfileResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        commands: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # Dockerfile指令列表
        self.commands = commands

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.commands is not None:
            result['commands'] = self.commands
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('commands') is not None:
            self.commands = m.get('commands')
        return self


class CreateOpsplanPodofflineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        auto_execute: bool = None,
        context: str = None,
        dependency: OpsContainerServiceChain = None,
        group_amount: int = None,
        group_orders: List[str] = None,
        group_strategy: str = None,
        namespace: str = None,
        need_beta: bool = None,
        restricted_cells: List[str] = None,
        restricted_zones: List[str] = None,
        selected_container_services: OpsContainerServiceGroup = None,
        title: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 是否自动执行
        self.auto_execute = auto_execute
        # 运维单扩展信息，jsonStr格式
        self.context = context
        # 容器服务间依赖顺序。 e.g 先发 A，B， 再发C， D {"groups": [{container_services: [{"name": A}, {"name": B}]}, {"container_services": [{"name": C}, {"name": D}]}]}
        self.dependency = dependency
        # 在具体分组策略下，每个执行单元（部署单元，机房等）内部的分组个数。
        self.group_amount = group_amount
        # 用户可自定义分组发布的顺序，结合具体的分组策略并通过指定具体分组维度对应的名称生效。 e.g, 当分组策略为机房时，可以指定先发机房A，再发机房B ["A", "B"]
        self.group_orders = group_orders
        # 分组策略（维度）：
        # - 按部署单元（CELL），按部署单元依次缩容；
        # - 按机房（ZONE），按机房依次缩容；
        # - 按逻辑单元（UNIT），按逻辑单元缩容；
        # - 共分一组（ALL），所有容器一起缩容，仍遵循分组个数控制；
        self.group_strategy = group_strategy
        # 命名空间
        self.namespace = namespace
        # 是否需要beta卡点
        self.need_beta = need_beta
        # 限定操作的部署单元
        self.restricted_cells = restricted_cells
        # 限定操作的机房
        self.restricted_zones = restricted_zones
        # 选定的容器服务列表
        self.selected_container_services = selected_container_services
        # 缩容指定pod的标题
        self.title = title
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        if self.dependency:
            self.dependency.validate()
        self.validate_required(self.group_amount, 'group_amount')
        self.validate_required(self.group_strategy, 'group_strategy')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.need_beta, 'need_beta')
        self.validate_required(self.selected_container_services, 'selected_container_services')
        if self.selected_container_services:
            self.selected_container_services.validate()
        self.validate_required(self.title, 'title')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.auto_execute is not None:
            result['auto_execute'] = self.auto_execute
        if self.context is not None:
            result['context'] = self.context
        if self.dependency is not None:
            result['dependency'] = self.dependency.to_map()
        if self.group_amount is not None:
            result['group_amount'] = self.group_amount
        if self.group_orders is not None:
            result['group_orders'] = self.group_orders
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.need_beta is not None:
            result['need_beta'] = self.need_beta
        if self.restricted_cells is not None:
            result['restricted_cells'] = self.restricted_cells
        if self.restricted_zones is not None:
            result['restricted_zones'] = self.restricted_zones
        if self.selected_container_services is not None:
            result['selected_container_services'] = self.selected_container_services.to_map()
        if self.title is not None:
            result['title'] = self.title
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('auto_execute') is not None:
            self.auto_execute = m.get('auto_execute')
        if m.get('context') is not None:
            self.context = m.get('context')
        if m.get('dependency') is not None:
            temp_model = OpsContainerServiceChain()
            self.dependency = temp_model.from_map(m['dependency'])
        if m.get('group_amount') is not None:
            self.group_amount = m.get('group_amount')
        if m.get('group_orders') is not None:
            self.group_orders = m.get('group_orders')
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('need_beta') is not None:
            self.need_beta = m.get('need_beta')
        if m.get('restricted_cells') is not None:
            self.restricted_cells = m.get('restricted_cells')
        if m.get('restricted_zones') is not None:
            self.restricted_zones = m.get('restricted_zones')
        if m.get('selected_container_services') is not None:
            temp_model = OpsContainerServiceGroup()
            self.selected_container_services = temp_model.from_map(m['selected_container_services'])
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class CreateOpsplanPodofflineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        operation_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 运维单号
        self.operation_id = operation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class CreateDbflowObtenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        description: str = None,
        extend_properties: str = None,
        name: str = None,
        type: str = None,
        uids: List[int] = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 描述信息
        self.description = description
        # 租户扩展属性，格式为序列化后的json字符串
        self.extend_properties = extend_properties
        # OB租户名称
        self.name = name
        # 用于存放对应的业务库租户类型：单库类型或分片库
        self.type = type
        # 租户存放的uid段，用于存放对应业务分片库
        self.uids = uids
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.description is not None:
            result['description'] = self.description
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.uids is not None:
            result['uids'] = self.uids
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('uids') is not None:
            self.uids = m.get('uids')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class CreateDbflowObtenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryDbflowObtenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        type: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 租户类型GZONE|RZONE，分别用于存放单库或分片库
        self.type = type
        # 租户名称前缀
        self.name = name
        # 当前页码，默认为1
        self.page_number = page_number
        # 单页个数，默认为10
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.type is not None:
            result['type'] = self.type
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class QueryDbflowObtenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        list: List[OBTenant] = None,
        page_number: int = None,
        page_size: int = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 租户列表
        self.list = list
        # 当前页码
        self.page_number = page_number
        # 单页个数
        self.page_size = page_size
        # 总计
        self.total_count = total_count

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = OBTenant()
                self.list.append(temp_model.from_map(k))
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class UpdateDbflowObtenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        id: str = None,
        name: str = None,
        type: str = None,
        description: str = None,
        uids: List[int] = None,
        extend_properties: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # OB租户唯一标识
        self.id = id
        # OB租户名称
        self.name = name
        # 用于存放对应的业务库租户类型：单库类型或分片库
        self.type = type
        # 租户描述
        self.description = description
        # 对应uid分片段，用于存放对应分片库
        self.uids = uids
        # 租户扩展属性，格式为序列化后的json字符串
        self.extend_properties = extend_properties

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.id, 'id')
        self.validate_required(self.name, 'name')
        self.validate_required(self.type, 'type')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        if self.type is not None:
            result['type'] = self.type
        if self.description is not None:
            result['description'] = self.description
        if self.uids is not None:
            result['uids'] = self.uids
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('type') is not None:
            self.type = m.get('type')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('uids') is not None:
            self.uids = m.get('uids')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        return self


class UpdateDbflowObtenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteDbflowObtenantRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 租户唯一标识
        self.id = id

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class DeleteDbflowObtenantResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateBuildpackNativetechstackversionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        tech_stack: str = None,
        tech_stack_version: str = None,
        from_image: str = None,
        description: str = None,
        ext_commands: List[str] = None,
        extend_properties: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 技术栈类别
        self.tech_stack = tech_stack
        # 云原生技术栈版本名称
        self.tech_stack_version = tech_stack_version
        # 基础镜像名称
        self.from_image = from_image
        # 版本描述信息
        self.description = description
        # 扩展指令列表
        self.ext_commands = ext_commands
        # 扩展属性 - 表现为Map<String,String>序列化后的字符串
        self.extend_properties = extend_properties

    def validate(self):
        self.validate_required(self.tech_stack, 'tech_stack')
        self.validate_required(self.tech_stack_version, 'tech_stack_version')
        self.validate_required(self.from_image, 'from_image')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.tech_stack is not None:
            result['tech_stack'] = self.tech_stack
        if self.tech_stack_version is not None:
            result['tech_stack_version'] = self.tech_stack_version
        if self.from_image is not None:
            result['from_image'] = self.from_image
        if self.description is not None:
            result['description'] = self.description
        if self.ext_commands is not None:
            result['ext_commands'] = self.ext_commands
        if self.extend_properties is not None:
            result['extend_properties'] = self.extend_properties
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('tech_stack') is not None:
            self.tech_stack = m.get('tech_stack')
        if m.get('tech_stack_version') is not None:
            self.tech_stack_version = m.get('tech_stack_version')
        if m.get('from_image') is not None:
            self.from_image = m.get('from_image')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('ext_commands') is not None:
            self.ext_commands = m.get('ext_commands')
        if m.get('extend_properties') is not None:
            self.extend_properties = m.get('extend_properties')
        return self


class UpdateBuildpackNativetechstackversionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListWorkspacegroupRegionsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace group 名称
        # 
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class ListWorkspacegroupRegionsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        regions: List[Region] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # region列表
        self.regions = regions

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['regions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.regions = []
        if m.get('regions') is not None:
            for k in m.get('regions'):
                temp_model = Region()
                self.regions.append(temp_model.from_map(k))
        return self


class ListClusterInfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace group name
        # 
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListClusterInfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[Cluster] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 集群列表
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = Cluster()
                self.data.append(temp_model.from_map(k))
        return self


class ListClusterOverviewRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace group name
        # 
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListClusterOverviewResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[ClusterStatus] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 集群资源概览信息
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ClusterStatus()
                self.data.append(temp_model.from_map(k))
        return self


class ListCertificatesRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class ListCertificatesResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        certificates: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 证书列表。
        self.certificates = certificates

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.certificates is not None:
            result['certificates'] = self.certificates
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('certificates') is not None:
            self.certificates = m.get('certificates')
        return self


class ListLoadbalancerRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        namespace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组名称。
        self.workspace_group = workspace_group
        # 命名空间名称。
        self.namespace = namespace

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class ListLoadbalancerResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        bound_iaas_ids: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 已经被使用的lb iaas ids。
        self.bound_iaas_ids = bound_iaas_ids

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.bound_iaas_ids is not None:
            result['bound_iaas_ids'] = self.bound_iaas_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('bound_iaas_ids') is not None:
            self.bound_iaas_ids = m.get('bound_iaas_ids')
        return self


class GetCloudconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class GetCloudconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cloud_config: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # cluod_config raw txt
        self.cloud_config = cloud_config

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cloud_config is not None:
            result['cloud_config'] = self.cloud_config
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cloud_config') is not None:
            self.cloud_config = m.get('cloud_config')
        return self


class UpdateCloudconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cloud_config: str = None,
        option: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cloud_config json描述
        self.cloud_config = cloud_config
        # UPDATE或ROLLBACK
        self.option = option

    def validate(self):
        self.validate_required(self.cloud_config, 'cloud_config')
        self.validate_required(self.option, 'option')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cloud_config is not None:
            result['cloud_config'] = self.cloud_config
        if self.option is not None:
            result['option'] = self.option
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cloud_config') is not None:
            self.cloud_config = m.get('cloud_config')
        if m.get('option') is not None:
            self.option = m.get('option')
        return self


class UpdateCloudconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListCloudconfigHistoryRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        return self


class ListCloudconfigHistoryResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        config_lists: List[CloudConfigEntity] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 配置历史列表
        self.config_lists = config_lists

    def validate(self):
        if self.config_lists:
            for k in self.config_lists:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['config_lists'] = []
        if self.config_lists is not None:
            for k in self.config_lists:
                result['config_lists'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.config_lists = []
        if m.get('config_lists') is not None:
            for k in m.get('config_lists'):
                temp_model = CloudConfigEntity()
                self.config_lists.append(temp_model.from_map(k))
        return self


class CreateSidecarOperationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        env: str = None,
        service_key: str = None,
        execute_task_request: SidecarOperationTask = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境信息，对应workspace_group名称
        self.env = env
        # sidecar运维动作：
        # 接入 open
        # 升级 upgrade
        self.service_key = service_key
        # sidecar运维请求体
        self.execute_task_request = execute_task_request

    def validate(self):
        self.validate_required(self.env, 'env')
        self.validate_required(self.service_key, 'service_key')
        self.validate_required(self.execute_task_request, 'execute_task_request')
        if self.execute_task_request:
            self.execute_task_request.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.env is not None:
            result['env'] = self.env
        if self.service_key is not None:
            result['service_key'] = self.service_key
        if self.execute_task_request is not None:
            result['execute_task_request'] = self.execute_task_request.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('env') is not None:
            self.env = m.get('env')
        if m.get('service_key') is not None:
            self.service_key = m.get('service_key')
        if m.get('execute_task_request') is not None:
            temp_model = SidecarOperationTask()
            self.execute_task_request = temp_model.from_map(m['execute_task_request'])
        return self


class CreateSidecarOperationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        operation_id: str = None,
        change_url: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # sidecar运维ID
        self.operation_id = operation_id
        # 跳转链接
        self.change_url = change_url
        # 是否成功
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.change_url is not None:
            result['change_url'] = self.change_url
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('change_url') is not None:
            self.change_url = m.get('change_url')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class RetrySidecarOperationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # operation ID
        self.operation_id = operation_id

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class RetrySidecarOperationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        change_url: str = None,
        operation_id: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 跳转链接
        self.change_url = change_url
        # sidecar运维请求ID
        self.operation_id = operation_id
        # 是否成功
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.change_url is not None:
            result['change_url'] = self.change_url
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('change_url') is not None:
            self.change_url = m.get('change_url')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class CancelSidecarOperationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # Opeartion ID
        self.operation_id = operation_id

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class CancelSidecarOperationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        change_url: str = None,
        operation_id: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 跳转链接
        self.change_url = change_url
        # sidecar运维请求
        self.operation_id = operation_id
        # 是否成功
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.change_url is not None:
            result['change_url'] = self.change_url
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('change_url') is not None:
            self.change_url = m.get('change_url')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class UpdateServiceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        raw_template: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # cluster name to apply a service
        self.cluster_name = cluster_name
        # a string service yaml
        self.raw_template = raw_template
        # xxx
        self.operator = operator

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.raw_template, 'raw_template')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.raw_template is not None:
            result['raw_template'] = self.raw_template
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('raw_template') is not None:
            self.raw_template = m.get('raw_template')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class UpdateServiceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateGpaasReleaseRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_instance_group: str = None,
        app_name: str = None,
        batches: List[ReleaseBatchObj] = None,
        is_first_release: bool = None,
        operator: str = None,
        release_name: str = None,
        release_version: ReleaseVersion = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # aig
        self.app_instance_group = app_instance_group
        # 应用名字
        self.app_name = app_name
        # 发布批次分组
        self.batches = batches
        # 是否是第一次发布
        self.is_first_release = is_first_release
        # operator
        self.operator = operator
        # 发布单名字，或者说标题
        self.release_name = release_name
        # 发布版本信息，包括镜像等
        self.release_version = release_version
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.app_instance_group, 'app_instance_group')
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.batches, 'batches')
        if self.batches:
            for k in self.batches:
                if k:
                    k.validate()
        self.validate_required(self.is_first_release, 'is_first_release')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.release_name, 'release_name')
        self.validate_required(self.release_version, 'release_version')
        if self.release_version:
            self.release_version.validate()
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_instance_group is not None:
            result['app_instance_group'] = self.app_instance_group
        if self.app_name is not None:
            result['app_name'] = self.app_name
        result['batches'] = []
        if self.batches is not None:
            for k in self.batches:
                result['batches'].append(k.to_map() if k else None)
        if self.is_first_release is not None:
            result['is_first_release'] = self.is_first_release
        if self.operator is not None:
            result['operator'] = self.operator
        if self.release_name is not None:
            result['release_name'] = self.release_name
        if self.release_version is not None:
            result['release_version'] = self.release_version.to_map()
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_instance_group') is not None:
            self.app_instance_group = m.get('app_instance_group')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        self.batches = []
        if m.get('batches') is not None:
            for k in m.get('batches'):
                temp_model = ReleaseBatchObj()
                self.batches.append(temp_model.from_map(k))
        if m.get('is_first_release') is not None:
            self.is_first_release = m.get('is_first_release')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('release_name') is not None:
            self.release_name = m.get('release_name')
        if m.get('release_version') is not None:
            temp_model = ReleaseVersion()
            self.release_version = temp_model.from_map(m['release_version'])
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class CreateGpaasReleaseResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        release_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 发布单id
        self.release_id = release_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.release_id is not None:
            result['release_id'] = self.release_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('release_id') is not None:
            self.release_id = m.get('release_id')
        return self


class QuerySidecarOperationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        with_detail: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 运维单号
        self.operation_id = operation_id
        # 是否带运维单执行详情
        self.with_detail = with_detail

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.with_detail is not None:
            result['with_detail'] = self.with_detail
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('with_detail') is not None:
            self.with_detail = m.get('with_detail')
        return self


class QuerySidecarOperationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
        finished: bool = None,
        operation_status: str = None,
        target_processes: List[str] = None,
        process_detail_list: List[SidecarOpsMachineGroup] = None,
        properties: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 是否成功
        self.success = success
        # 是否结束
        self.finished = finished
        # 执行状态
        self.operation_status = operation_status
        # 执行详情
        self.target_processes = target_processes
        # 发布分组执行详情
        self.process_detail_list = process_detail_list
        # 扩展信息
        self.properties = properties

    def validate(self):
        if self.process_detail_list:
            for k in self.process_detail_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        if self.finished is not None:
            result['finished'] = self.finished
        if self.operation_status is not None:
            result['operation_status'] = self.operation_status
        if self.target_processes is not None:
            result['target_processes'] = self.target_processes
        result['process_detail_list'] = []
        if self.process_detail_list is not None:
            for k in self.process_detail_list:
                result['process_detail_list'].append(k.to_map() if k else None)
        if self.properties is not None:
            result['properties'] = self.properties
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('finished') is not None:
            self.finished = m.get('finished')
        if m.get('operation_status') is not None:
            self.operation_status = m.get('operation_status')
        if m.get('target_processes') is not None:
            self.target_processes = m.get('target_processes')
        self.process_detail_list = []
        if m.get('process_detail_list') is not None:
            for k in m.get('process_detail_list'):
                temp_model = SidecarOpsMachineGroup()
                self.process_detail_list.append(temp_model.from_map(k))
        if m.get('properties') is not None:
            self.properties = m.get('properties')
        return self


class ListKubernetesResourcesRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        label_selector: str = None,
        path: str = None,
        namespace: str = None,
        cells: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # 标签选择器。
        self.label_selector = label_selector
        # kubernetes资源路径。
        self.path = path
        # 命名空间名称。
        self.namespace = namespace
        # cell名称列表，只查指定cell的集群
        self.cells = cells

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.path, 'path')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.label_selector is not None:
            result['label_selector'] = self.label_selector
        if self.path is not None:
            result['path'] = self.path
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.cells is not None:
            result['cells'] = self.cells
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('label_selector') is not None:
            self.label_selector = m.get('label_selector')
        if m.get('path') is not None:
            self.path = m.get('path')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        return self


class ListKubernetesResourcesResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        items: List[str] = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # "item1","item2"
        self.items = items
        # 资源总数。
        self.total_count = total_count

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.items is not None:
            result['items'] = self.items
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('items') is not None:
            self.items = m.get('items')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class QueryReleasepipelinestageEventRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        stage_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单发布分组的id，对应ReleasePipeline中的stage
        self.stage_id = stage_id

    def validate(self):
        self.validate_required(self.stage_id, 'stage_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.stage_id is not None:
            result['stage_id'] = self.stage_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('stage_id') is not None:
            self.stage_id = m.get('stage_id')
        return self


class QueryReleasepipelinestageEventResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        event_list: List[RpReleaseEvent] = None,
        stage_id: str = None,
        type_ins_summary: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 事件列表
        self.event_list = event_list
        # ReleasePipelineStage id
        self.stage_id = stage_id
        # 返回列表中类型和对象摘要
        self.type_ins_summary = type_ins_summary

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['event_list'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['event_list'].append(k.to_map() if k else None)
        if self.stage_id is not None:
            result['stage_id'] = self.stage_id
        if self.type_ins_summary is not None:
            result['type_ins_summary'] = self.type_ins_summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.event_list = []
        if m.get('event_list') is not None:
            for k in m.get('event_list'):
                temp_model = RpReleaseEvent()
                self.event_list.append(temp_model.from_map(k))
        if m.get('stage_id') is not None:
            self.stage_id = m.get('stage_id')
        if m.get('type_ins_summary') is not None:
            self.type_ins_summary = m.get('type_ins_summary')
        return self


class GetSlsProjectnameRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # workspace_group
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class GetSlsProjectnameResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        project_name: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # sls projectName
        self.project_name = project_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.project_name is not None:
            result['project_name'] = self.project_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('project_name') is not None:
            self.project_name = m.get('project_name')
        return self


class QueryReleasepipelineEventRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        service_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单对应的service id
        self.service_id = service_id

    def validate(self):
        self.validate_required(self.service_id, 'service_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.service_id is not None:
            result['service_id'] = self.service_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('service_id') is not None:
            self.service_id = m.get('service_id')
        return self


class QueryReleasepipelineEventResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        event_list: List[RpReleaseEvent] = None,
        service_id: str = None,
        type_ins_summary: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 事件列表
        self.event_list = event_list
        # ReleasePipeline service_id
        self.service_id = service_id
        # 返回列表中类型和对象摘要
        self.type_ins_summary = type_ins_summary

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['event_list'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['event_list'].append(k.to_map() if k else None)
        if self.service_id is not None:
            result['service_id'] = self.service_id
        if self.type_ins_summary is not None:
            result['type_ins_summary'] = self.type_ins_summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.event_list = []
        if m.get('event_list') is not None:
            for k in m.get('event_list'):
                temp_model = RpReleaseEvent()
                self.event_list.append(temp_model.from_map(k))
        if m.get('service_id') is not None:
            self.service_id = m.get('service_id')
        if m.get('type_ins_summary') is not None:
            self.type_ins_summary = m.get('type_ins_summary')
        return self


class QueryPodEventRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        service_id: str = None,
        u_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单对应的service_id
        self.service_id = service_id
        # POD对应的u_id
        self.u_id = u_id

    def validate(self):
        self.validate_required(self.service_id, 'service_id')
        self.validate_required(self.u_id, 'u_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.service_id is not None:
            result['service_id'] = self.service_id
        if self.u_id is not None:
            result['u_id'] = self.u_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('service_id') is not None:
            self.service_id = m.get('service_id')
        if m.get('u_id') is not None:
            self.u_id = m.get('u_id')
        return self


class QueryPodEventResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        event_list: List[RpReleaseEvent] = None,
        service_id: str = None,
        u_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 事件列表
        self.event_list = event_list
        # 发布单对应的service_id
        self.service_id = service_id
        # POD对应的uid
        self.u_id = u_id

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['event_list'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['event_list'].append(k.to_map() if k else None)
        if self.service_id is not None:
            result['service_id'] = self.service_id
        if self.u_id is not None:
            result['u_id'] = self.u_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.event_list = []
        if m.get('event_list') is not None:
            for k in m.get('event_list'):
                temp_model = RpReleaseEvent()
                self.event_list.append(temp_model.from_map(k))
        if m.get('service_id') is not None:
            self.service_id = m.get('service_id')
        if m.get('u_id') is not None:
            self.u_id = m.get('u_id')
        return self


class QueryServiceProcesslogRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        object_kind: str = None,
        object_name: str = None,
        service_id: str = None,
        plan_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 观测对象类型，RPV2，RP_STAGE，POD
        self.object_kind = object_kind
        # 观测对象名称
        self.object_name = object_name
        # 发布单对应的service_id
        self.service_id = service_id
        # 发布单id
        self.plan_id = plan_id

    def validate(self):
        self.validate_required(self.object_kind, 'object_kind')
        self.validate_required(self.object_name, 'object_name')
        self.validate_required(self.service_id, 'service_id')
        self.validate_required(self.plan_id, 'plan_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.object_kind is not None:
            result['object_kind'] = self.object_kind
        if self.object_name is not None:
            result['object_name'] = self.object_name
        if self.service_id is not None:
            result['service_id'] = self.service_id
        if self.plan_id is not None:
            result['plan_id'] = self.plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('object_kind') is not None:
            self.object_kind = m.get('object_kind')
        if m.get('object_name') is not None:
            self.object_name = m.get('object_name')
        if m.get('service_id') is not None:
            self.service_id = m.get('service_id')
        if m.get('plan_id') is not None:
            self.plan_id = m.get('plan_id')
        return self


class QueryServiceProcesslogResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        log_list: List[ServiceProcessLog] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # Log列表
        self.log_list = log_list

    def validate(self):
        if self.log_list:
            for k in self.log_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['log_list'] = []
        if self.log_list is not None:
            for k in self.log_list:
                result['log_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.log_list = []
        if m.get('log_list') is not None:
            for k in m.get('log_list'):
                temp_model = ServiceProcessLog()
                self.log_list.append(temp_model.from_map(k))
        return self


class QueryAppServiceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        container_service_name: str = None,
        current_page: int = None,
        deployment_states: List[str] = None,
        namespace: str = None,
        order: str = None,
        page_size: int = None,
        query_type: str = None,
        workspace_group_names: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 根据应用名称查询，不能为空，不支持一次性查询所有应用，是精准查询，不支持模糊匹配
        self.app_name = app_name
        # 容器服务名
        self.container_service_name = container_service_name
        # 当前页码，从1开始，默认为1
        self.current_page = current_page
        # 部署状态
        self.deployment_states = deployment_states
        # 所属命名空间
        self.namespace = namespace
        # 排序规则数组，默认为 UTC_CREATED_DESC，即 根据创建时间降序排序
        self.order = order
        # 分页大小，默认为10
        self.page_size = page_size
        # 查询类型，支持精准查询、模糊查询、前缀模糊查询，这里默认为模糊查询；查询类型针对字段 container_service_name
        self.query_type = query_type
        # 工作空间组id列表
        self.workspace_group_names = workspace_group_names

    def validate(self):
        self.validate_required(self.app_name, 'app_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.deployment_states is not None:
            result['deployment_states'] = self.deployment_states
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.order is not None:
            result['order'] = self.order
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.query_type is not None:
            result['query_type'] = self.query_type
        if self.workspace_group_names is not None:
            result['workspace_group_names'] = self.workspace_group_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('deployment_states') is not None:
            self.deployment_states = m.get('deployment_states')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('query_type') is not None:
            self.query_type = m.get('query_type')
        if m.get('workspace_group_names') is not None:
            self.workspace_group_names = m.get('workspace_group_names')
        return self


class QueryAppServiceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        container_service_list: List[ContainerServiceBasicInfo] = None,
        current_page: int = None,
        page_size: int = None,
        total_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 当前应用关联的容器服务列表
        self.container_service_list = container_service_list
        # 当前页码，从1开始，默认为1
        self.current_page = current_page
        # 分页大小，默认为10
        self.page_size = page_size
        # 总数
        self.total_size = total_size

    def validate(self):
        if self.container_service_list:
            for k in self.container_service_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['container_service_list'] = []
        if self.container_service_list is not None:
            for k in self.container_service_list:
                result['container_service_list'].append(k.to_map() if k else None)
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.total_size is not None:
            result['total_size'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.container_service_list = []
        if m.get('container_service_list') is not None:
            for k in m.get('container_service_list'):
                temp_model = ContainerServiceBasicInfo()
                self.container_service_list.append(temp_model.from_map(k))
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        return self


class QueryAppPlanRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        current_page: int = None,
        order: str = None,
        page_size: int = None,
        states: List[str] = None,
        timeseries_ids: List[str] = None,
        workspace_group_names: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称，精准查询
        self.app_name = app_name
        # 当前页码，从1开始，默认为1
        self.current_page = current_page
        # 排序规则，默认为 UTC_CREATED_DESC，即 根据创建时间降序排序
        self.order = order
        # 分页大小，默认为10
        self.page_size = page_size
        # 状态筛选列表
        self.states = states
        # 查询指定发布单 timeseries_id 列表
        self.timeseries_ids = timeseries_ids
        # 工作空间组id列表
        self.workspace_group_names = workspace_group_names

    def validate(self):
        self.validate_required(self.app_name, 'app_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.order is not None:
            result['order'] = self.order
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.states is not None:
            result['states'] = self.states
        if self.timeseries_ids is not None:
            result['timeseries_ids'] = self.timeseries_ids
        if self.workspace_group_names is not None:
            result['workspace_group_names'] = self.workspace_group_names
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('order') is not None:
            self.order = m.get('order')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('states') is not None:
            self.states = m.get('states')
        if m.get('timeseries_ids') is not None:
            self.timeseries_ids = m.get('timeseries_ids')
        if m.get('workspace_group_names') is not None:
            self.workspace_group_names = m.get('workspace_group_names')
        return self


class QueryAppPlanResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        current_page: int = None,
        page_size: int = None,
        plan_list: List[PlanSimpleView] = None,
        total_size: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 当前页码，从1开始，默认为1
        self.current_page = current_page
        # 分页大小，默认为10
        self.page_size = page_size
        # 发布单列表
        self.plan_list = plan_list
        # 发布单数
        self.total_size = total_size

    def validate(self):
        if self.plan_list:
            for k in self.plan_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.current_page is not None:
            result['current_page'] = self.current_page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        result['plan_list'] = []
        if self.plan_list is not None:
            for k in self.plan_list:
                result['plan_list'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['total_size'] = self.total_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        self.plan_list = []
        if m.get('plan_list') is not None:
            for k in m.get('plan_list'):
                temp_model = PlanSimpleView()
                self.plan_list.append(temp_model.from_map(k))
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        return self


class CreateUnifiedaccessinstanceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        spanner_cluster: str = None,
        unified_access_instance_https_entry: HttpsEntry = None,
        unified_access_instance_http_entry: HttpEntry = None,
        unified_access_instance_name: str = None,
        unified_access_instance_type: str = None,
        workspace_group: str = None,
        entry_settings: EntrySettings = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 关联的Spanner逻辑集群名称，一个逻辑集群由很多个local集群组成
        self.spanner_cluster = spanner_cluster
        # https协议配置
        self.unified_access_instance_https_entry = unified_access_instance_https_entry
        # http协议配置
        self.unified_access_instance_http_entry = unified_access_instance_http_entry
        # 统一接入实例名称
        self.unified_access_instance_name = unified_access_instance_name
        # 统一接入网络类型，内网（intranet），公网（internet）
        self.unified_access_instance_type = unified_access_instance_type
        # 工作空间组
        self.workspace_group = workspace_group
        # 用户自定义实例entry相关信息（vip/id），datacenter粒度
        self.entry_settings = entry_settings

    def validate(self):
        self.validate_required(self.spanner_cluster, 'spanner_cluster')
        if self.unified_access_instance_https_entry:
            self.unified_access_instance_https_entry.validate()
        self.validate_required(self.unified_access_instance_http_entry, 'unified_access_instance_http_entry')
        if self.unified_access_instance_http_entry:
            self.unified_access_instance_http_entry.validate()
        self.validate_required(self.unified_access_instance_name, 'unified_access_instance_name')
        self.validate_required(self.unified_access_instance_type, 'unified_access_instance_type')
        self.validate_required(self.workspace_group, 'workspace_group')
        if self.entry_settings:
            self.entry_settings.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.spanner_cluster is not None:
            result['spanner_cluster'] = self.spanner_cluster
        if self.unified_access_instance_https_entry is not None:
            result['unified_access_instance_https_entry'] = self.unified_access_instance_https_entry.to_map()
        if self.unified_access_instance_http_entry is not None:
            result['unified_access_instance_http_entry'] = self.unified_access_instance_http_entry.to_map()
        if self.unified_access_instance_name is not None:
            result['unified_access_instance_name'] = self.unified_access_instance_name
        if self.unified_access_instance_type is not None:
            result['unified_access_instance_type'] = self.unified_access_instance_type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.entry_settings is not None:
            result['entry_settings'] = self.entry_settings.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('spanner_cluster') is not None:
            self.spanner_cluster = m.get('spanner_cluster')
        if m.get('unified_access_instance_https_entry') is not None:
            temp_model = HttpsEntry()
            self.unified_access_instance_https_entry = temp_model.from_map(m['unified_access_instance_https_entry'])
        if m.get('unified_access_instance_http_entry') is not None:
            temp_model = HttpEntry()
            self.unified_access_instance_http_entry = temp_model.from_map(m['unified_access_instance_http_entry'])
        if m.get('unified_access_instance_name') is not None:
            self.unified_access_instance_name = m.get('unified_access_instance_name')
        if m.get('unified_access_instance_type') is not None:
            self.unified_access_instance_type = m.get('unified_access_instance_type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('entry_settings') is not None:
            temp_model = EntrySettings()
            self.entry_settings = temp_model.from_map(m['entry_settings'])
        return self


class CreateUnifiedaccessinstanceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUnifiedaccessinstanceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        instance_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 可以用来过滤实例
        self.instance_name = instance_name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.instance_name is not None:
            result['instance_name'] = self.instance_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('instance_name') is not None:
            self.instance_name = m.get('instance_name')
        return self


class QueryUnifiedaccessinstanceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        list: List[UnifiedAccessInstanceInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 统一接入实例列表信息
        self.list = list

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = UnifiedAccessInstanceInfo()
                self.list.append(temp_model.from_map(k))
        return self


class GetUnifiedaccessinstanceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        unified_access_instance_name: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 统一接入实例名称
        self.unified_access_instance_name = unified_access_instance_name
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.unified_access_instance_name, 'unified_access_instance_name')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.unified_access_instance_name is not None:
            result['unified_access_instance_name'] = self.unified_access_instance_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('unified_access_instance_name') is not None:
            self.unified_access_instance_name = m.get('unified_access_instance_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class GetUnifiedaccessinstanceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: UnifiedAccessInstanceInfo = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 统一接入实例信息
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = UnifiedAccessInstanceInfo()
            self.data = temp_model.from_map(m['data'])
        return self


class DeleteUnifiedaccessinstanceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        unified_access_instance_name: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 统一接入实例名称
        self.unified_access_instance_name = unified_access_instance_name
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.unified_access_instance_name, 'unified_access_instance_name')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.unified_access_instance_name is not None:
            result['unified_access_instance_name'] = self.unified_access_instance_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('unified_access_instance_name') is not None:
            self.unified_access_instance_name = m.get('unified_access_instance_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class DeleteUnifiedaccessinstanceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateUnifiedaccessinstanceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        data: UnifiedAccessInstanceInfo = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 统一接入实例信息
        self.data = data
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.data, 'data')
        if self.data:
            self.data.validate()
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.data is not None:
            result['data'] = self.data.to_map()
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('data') is not None:
            temp_model = UnifiedAccessInstanceInfo()
            self.data = temp_model.from_map(m['data'])
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateUnifiedaccessinstanceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ExecUnireleasespiRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        request_method: str = None,
        request_param: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 请求方法
        self.request_method = request_method
        # 请求参数的 JSON 字符串
        self.request_param = request_param

    def validate(self):
        self.validate_required(self.request_method, 'request_method')
        self.validate_required(self.request_param, 'request_param')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.request_method is not None:
            result['request_method'] = self.request_method
        if self.request_param is not None:
            result['request_param'] = self.request_param
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('request_method') is not None:
            self.request_method = m.get('request_method')
        if m.get('request_param') is not None:
            self.request_param = m.get('request_param')
        return self


class ExecUnireleasespiResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 请求结果的 JSON 字符串
        self.result = result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.result is not None:
            result['result'] = self.result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('result') is not None:
            self.result = m.get('result')
        return self


class CreateFedspannerclusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        address_type: str = None,
        cpu: str = None,
        disk: str = None,
        host_network: bool = None,
        mem: str = None,
        name: str = None,
        state: str = None,
        sub_clusters_config: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 用于描述联邦spanner 集群内容器实例采用内网还是外网
        self.address_type = address_type
        # 用于描述联邦spanner 集群内容器实例 cpu大小， 单位core
        self.cpu = cpu
        # 用于描述联邦spanner 集群内容器实例disk大小， 单位Gi
        self.disk = disk
        # 用于描述联邦spanner 集群内容器实例的网络是否采用host网络
        self.host_network = host_network
        # 用于描述联邦spanner 集群内容器实例mem 大小， 单位 Gi
        self.mem = mem
        # 用于描述联邦spanner 集群名称
        self.name = name
        # 描述集群初始状态
        self.state = state
        # 定义了container的spec信息，包含多版本，镜像，副本数，标签等
        self.sub_clusters_config = sub_clusters_config
        # 工作空间组信息
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.address_type, 'address_type')
        self.validate_required(self.cpu, 'cpu')
        self.validate_required(self.disk, 'disk')
        self.validate_required(self.host_network, 'host_network')
        self.validate_required(self.mem, 'mem')
        self.validate_required(self.name, 'name')
        self.validate_required(self.state, 'state')
        self.validate_required(self.sub_clusters_config, 'sub_clusters_config')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.address_type is not None:
            result['address_type'] = self.address_type
        if self.cpu is not None:
            result['cpu'] = self.cpu
        if self.disk is not None:
            result['disk'] = self.disk
        if self.host_network is not None:
            result['host_network'] = self.host_network
        if self.mem is not None:
            result['mem'] = self.mem
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.sub_clusters_config is not None:
            result['sub_clusters_config'] = self.sub_clusters_config
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('address_type') is not None:
            self.address_type = m.get('address_type')
        if m.get('cpu') is not None:
            self.cpu = m.get('cpu')
        if m.get('disk') is not None:
            self.disk = m.get('disk')
        if m.get('host_network') is not None:
            self.host_network = m.get('host_network')
        if m.get('mem') is not None:
            self.mem = m.get('mem')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('sub_clusters_config') is not None:
            self.sub_clusters_config = m.get('sub_clusters_config')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class CreateFedspannerclusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cluster_name: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # fed集群名称
        self.cluster_name = cluster_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        return self


class QueryFedspannerclusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 集群名称，模糊匹配
        self.cluster_name = cluster_name
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class QueryFedspannerclusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[QuerySpannerClusterDetail] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 查询集群列表时的简略信息
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = QuerySpannerClusterDetail()
                self.data.append(temp_model.from_map(k))
        return self


class GetFedspannerclusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # fed集群名称
        self.cluster_name = cluster_name
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.workspace_group, 'workspace_group')
        if self.workspace_group is not None:
            self.validate_max_length(self.workspace_group, 'workspace_group', 256)

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class GetFedspannerclusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: GetSpannerClusterDetail = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 获取单个联邦 spanner集群详细信息，包含所含的本地集群信息
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = GetSpannerClusterDetail()
            self.data = temp_model.from_map(m['data'])
        return self


class ListFedspannerclusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 集群名称
        self.cluster_name = cluster_name
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListFedspannerclusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[QuerySpannerClusterDetail] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # list 集群列表
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = QuerySpannerClusterDetail()
                self.data.append(temp_model.from_map(k))
        return self


class DeleteFedspannerclusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_name: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # fed spanner cluster name
        self.cluster_name = cluster_name
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class DeleteFedspannerclusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class BatchdeleteFedspannerclusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        cluster_names: List[str] = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 批量指定fed集群名称
        self.cluster_names = cluster_names
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.cluster_names, 'cluster_names')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.cluster_names is not None:
            result['cluster_names'] = self.cluster_names
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('cluster_names') is not None:
            self.cluster_names = m.get('cluster_names')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class BatchdeleteFedspannerclusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateFedspannerclusterRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        address_type: str = None,
        cluster_name: str = None,
        cpu: str = None,
        disk: str = None,
        host_network: bool = None,
        mem: str = None,
        name: str = None,
        state: str = None,
        sub_clusters_config: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 用于描述联邦spanner 集群内容器实例采用内网还是外网
        self.address_type = address_type
        # 集群名称
        self.cluster_name = cluster_name
        # 用于描述联邦spanner 集群内容器实例 cpu大小， 单位core
        self.cpu = cpu
        # 用于描述联邦spanner 集群内容器实例disk大小， 单位Gi
        self.disk = disk
        # 用于描述联邦spanner 集群内容器实例的网络是否采用host网络
        self.host_network = host_network
        # 用于描述联邦spanner 集群内容器实例mem 大小， 单位 Gi
        self.mem = mem
        # 用于描述联邦spanner 集群名称
        self.name = name
        # 描述集群状态
        self.state = state
        # 定义了sub cluster的config信息，包含多版本，镜像，副本数，标签等
        self.sub_clusters_config = sub_clusters_config
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.address_type, 'address_type')
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.cpu, 'cpu')
        self.validate_required(self.disk, 'disk')
        self.validate_required(self.host_network, 'host_network')
        self.validate_required(self.mem, 'mem')
        self.validate_required(self.name, 'name')
        self.validate_required(self.state, 'state')
        self.validate_required(self.sub_clusters_config, 'sub_clusters_config')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.address_type is not None:
            result['address_type'] = self.address_type
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.cpu is not None:
            result['cpu'] = self.cpu
        if self.disk is not None:
            result['disk'] = self.disk
        if self.host_network is not None:
            result['host_network'] = self.host_network
        if self.mem is not None:
            result['mem'] = self.mem
        if self.name is not None:
            result['name'] = self.name
        if self.state is not None:
            result['state'] = self.state
        if self.sub_clusters_config is not None:
            result['sub_clusters_config'] = self.sub_clusters_config
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('address_type') is not None:
            self.address_type = m.get('address_type')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('cpu') is not None:
            self.cpu = m.get('cpu')
        if m.get('disk') is not None:
            self.disk = m.get('disk')
        if m.get('host_network') is not None:
            self.host_network = m.get('host_network')
        if m.get('mem') is not None:
            self.mem = m.get('mem')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('sub_clusters_config') is not None:
            self.sub_clusters_config = m.get('sub_clusters_config')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateFedspannerclusterResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateReleaseplanRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_services: List[ReleasePlanSpecAppService] = None,
        namespace: str = None,
        workspace_group: str = None,
        is_auto_execute: bool = None,
        title: str = None,
        ops_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 创建发布单需要的应用服务信息
        self.app_services = app_services
        # 命名空间
        self.namespace = namespace
        # 工作空间组
        self.workspace_group = workspace_group
        # 是否自动执行
        self.is_auto_execute = is_auto_execute
        # 发布单标题
        self.title = title
        # 默认CLOUD_NATIVE_GROUP_RELEASE
        self.ops_type = ops_type

    def validate(self):
        self.validate_required(self.app_services, 'app_services')
        if self.app_services:
            for k in self.app_services:
                if k:
                    k.validate()
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.title, 'title')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        result['app_services'] = []
        if self.app_services is not None:
            for k in self.app_services:
                result['app_services'].append(k.to_map() if k else None)
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.is_auto_execute is not None:
            result['is_auto_execute'] = self.is_auto_execute
        if self.title is not None:
            result['title'] = self.title
        if self.ops_type is not None:
            result['ops_type'] = self.ops_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        self.app_services = []
        if m.get('app_services') is not None:
            for k in m.get('app_services'):
                temp_model = ReleasePlanSpecAppService()
                self.app_services.append(temp_model.from_map(k))
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('is_auto_execute') is not None:
            self.is_auto_execute = m.get('is_auto_execute')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('ops_type') is not None:
            self.ops_type = m.get('ops_type')
        return self


class CreateReleaseplanResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        plan_unique_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 发布单的唯一标识，可以认为是timeSeriesId
        self.plan_unique_id = plan_unique_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.plan_unique_id is not None:
            result['plan_unique_id'] = self.plan_unique_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('plan_unique_id') is not None:
            self.plan_unique_id = m.get('plan_unique_id')
        return self


class UpdateFedspannerclusterStatusRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        cluster_name: str = None,
        cluster_status: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # fed spanner cluster 集群名称
        self.cluster_name = cluster_name
        # 期望的集群状态
        self.cluster_status = cluster_status

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.cluster_name, 'cluster_name')
        self.validate_required(self.cluster_status, 'cluster_status')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.cluster_name is not None:
            result['cluster_name'] = self.cluster_name
        if self.cluster_status is not None:
            result['cluster_status'] = self.cluster_status
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('cluster_name') is not None:
            self.cluster_name = m.get('cluster_name')
        if m.get('cluster_status') is not None:
            self.cluster_status = m.get('cluster_status')
        return self


class UpdateFedspannerclusterStatusResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class AddAntvipDomainRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        application: str = None,
        cells: List[str] = None,
        health_check_type: str = None,
        health_check_default_port: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组名称
        self.workspace_group = workspace_group
        # 应用名称
        self.application = application
        # 要添加的部署单元名称列表
        self.cells = cells
        # 健康检查类型，默认为TCP
        self.health_check_type = health_check_type
        # 健康检查端口，非必填项
        self.health_check_default_port = health_check_default_port

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.application, 'application')
        self.validate_required(self.cells, 'cells')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.application is not None:
            result['application'] = self.application
        if self.cells is not None:
            result['cells'] = self.cells
        if self.health_check_type is not None:
            result['health_check_type'] = self.health_check_type
        if self.health_check_default_port is not None:
            result['health_check_default_port'] = self.health_check_default_port
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('application') is not None:
            self.application = m.get('application')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        if m.get('health_check_type') is not None:
            self.health_check_type = m.get('health_check_type')
        if m.get('health_check_default_port') is not None:
            self.health_check_default_port = m.get('health_check_default_port')
        return self


class AddAntvipDomainResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        vip_domains: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 创建的antvip域名全称
        self.vip_domains = vip_domains

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.vip_domains is not None:
            result['vip_domains'] = self.vip_domains
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('vip_domains') is not None:
            self.vip_domains = m.get('vip_domains')
        return self


class DeleteAntvipDomainRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        application: str = None,
        cell: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组名称
        self.workspace_group = workspace_group
        # 应用名称
        self.application = application
        # 部署单元cell名称
        self.cell = cell

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.application, 'application')
        self.validate_required(self.cell, 'cell')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.application is not None:
            result['application'] = self.application
        if self.cell is not None:
            result['cell'] = self.cell
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('application') is not None:
            self.application = m.get('application')
        if m.get('cell') is not None:
            self.cell = m.get('cell')
        return self


class DeleteAntvipDomainResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListContainerserviceIngressRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service_name: str = None,
        namespace: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器服务名称
        self.container_service_name = container_service_name
        # 命名空间名称
        self.namespace = namespace
        # 工作空间组名称
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListContainerserviceIngressResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        ingresses: List[IngressInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 容器服务 Ingress 列表
        self.ingresses = ingresses

    def validate(self):
        if self.ingresses:
            for k in self.ingresses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['ingresses'] = []
        if self.ingresses is not None:
            for k in self.ingresses:
                result['ingresses'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.ingresses = []
        if m.get('ingresses') is not None:
            for k in m.get('ingresses'):
                temp_model = IngressInfo()
                self.ingresses.append(temp_model.from_map(k))
        return self


class CreateContainerserviceOperationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_services: ContainerServiceOperationList = None,
        group_strategy: str = None,
        is_auto_execute: bool = None,
        is_need_beta: bool = None,
        namespace: str = None,
        ops_mode: str = None,
        ops_type: str = None,
        title: str = None,
        workspace_group: str = None,
        group_amount: int = None,
        assignee_ids: List[str] = None,
        operator: str = None,
        huanyu_exec_no: str = None,
        max_group_capacity: int = None,
        max_cell_pod_percentage: int = None,
        cell_weights: List[CellWeightInfo] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器服务列表。
        self.container_services = container_services
        # 分组策略：ALL_ONE、EACH_ONE、CELL，默认EACH_ONE
        self.group_strategy = group_strategy
        # 是否自动执行，默认false
        self.is_auto_execute = is_auto_execute
        # 是否需要beta卡点，默认 true
        self.is_need_beta = is_need_beta
        # 所属命名空间
        self.namespace = namespace
        # 运维类型：重启等
        self.ops_mode = ops_mode
        # 默认值：CLOUD_NATIVE_OPERATION
        self.ops_type = ops_type
        # 运维单名称
        self.title = title
        # 所属工作空间组名称。
        self.workspace_group = workspace_group
        # 最小分组数，同发布单中的group_count
        self.group_amount = group_amount
        # 审批人账号id，暂时不支持
        self.assignee_ids = assignee_ids
        # 操作人账号，lks1.23.0才支持
        self.operator = operator
        # [huanyu场景使用]huanyu变更单id
        self.huanyu_exec_no = huanyu_exec_no
        # 每个批次最大涉及变更的pod个数
        self.max_group_capacity = max_group_capacity
        # 每个部署单元单批次变更pod数量百分比，仅当group_strategey为ALL_CELL_PERCENTAGE时生效
        self.max_cell_pod_percentage = max_cell_pod_percentage
        # 部署单元流量权重
        self.cell_weights = cell_weights

    def validate(self):
        self.validate_required(self.container_services, 'container_services')
        if self.container_services:
            self.container_services.validate()
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.ops_mode, 'ops_mode')
        self.validate_required(self.title, 'title')
        self.validate_required(self.workspace_group, 'workspace_group')
        if self.cell_weights:
            for k in self.cell_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_services is not None:
            result['container_services'] = self.container_services.to_map()
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        if self.is_auto_execute is not None:
            result['is_auto_execute'] = self.is_auto_execute
        if self.is_need_beta is not None:
            result['is_need_beta'] = self.is_need_beta
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.ops_mode is not None:
            result['ops_mode'] = self.ops_mode
        if self.ops_type is not None:
            result['ops_type'] = self.ops_type
        if self.title is not None:
            result['title'] = self.title
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.group_amount is not None:
            result['group_amount'] = self.group_amount
        if self.assignee_ids is not None:
            result['assignee_ids'] = self.assignee_ids
        if self.operator is not None:
            result['operator'] = self.operator
        if self.huanyu_exec_no is not None:
            result['huanyu_exec_no'] = self.huanyu_exec_no
        if self.max_group_capacity is not None:
            result['max_group_capacity'] = self.max_group_capacity
        if self.max_cell_pod_percentage is not None:
            result['max_cell_pod_percentage'] = self.max_cell_pod_percentage
        result['cell_weights'] = []
        if self.cell_weights is not None:
            for k in self.cell_weights:
                result['cell_weights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_services') is not None:
            temp_model = ContainerServiceOperationList()
            self.container_services = temp_model.from_map(m['container_services'])
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        if m.get('is_auto_execute') is not None:
            self.is_auto_execute = m.get('is_auto_execute')
        if m.get('is_need_beta') is not None:
            self.is_need_beta = m.get('is_need_beta')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('ops_mode') is not None:
            self.ops_mode = m.get('ops_mode')
        if m.get('ops_type') is not None:
            self.ops_type = m.get('ops_type')
        if m.get('title') is not None:
            self.title = m.get('title')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('group_amount') is not None:
            self.group_amount = m.get('group_amount')
        if m.get('assignee_ids') is not None:
            self.assignee_ids = m.get('assignee_ids')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('huanyu_exec_no') is not None:
            self.huanyu_exec_no = m.get('huanyu_exec_no')
        if m.get('max_group_capacity') is not None:
            self.max_group_capacity = m.get('max_group_capacity')
        if m.get('max_cell_pod_percentage') is not None:
            self.max_cell_pod_percentage = m.get('max_cell_pod_percentage')
        self.cell_weights = []
        if m.get('cell_weights') is not None:
            for k in m.get('cell_weights'):
                temp_model = CellWeightInfo()
                self.cell_weights.append(temp_model.from_map(k))
        return self


class CreateContainerserviceOperationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        operation_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 创建完成的部署单id
        self.operation_id = operation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class ListMulticlusterEventsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        namespace: str = None,
        container_service: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 环境组名称
        self.workspace_group = workspace_group
        # 命名空间
        self.namespace = namespace
        # 容器服务名称
        self.container_service = container_service

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.container_service is not None:
            result['container_service'] = self.container_service
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('container_service') is not None:
            self.container_service = m.get('container_service')
        return self


class ListMulticlusterEventsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[ClusterEvents] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # kubernetes集群事件信息
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = ClusterEvents()
                self.data.append(temp_model.from_map(k))
        return self


class ApplyContainerserviceDeploymentRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        time_series_id: str = None,
        assignee_ids: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单time_series_id
        self.time_series_id = time_series_id
        # 审批人账号id
        self.assignee_ids = assignee_ids

    def validate(self):
        self.validate_required(self.time_series_id, 'time_series_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        if self.assignee_ids is not None:
            result['assignee_ids'] = self.assignee_ids
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        if m.get('assignee_ids') is not None:
            self.assignee_ids = m.get('assignee_ids')
        return self


class ApplyContainerserviceDeploymentResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        approval_status: str = None,
        approval_url: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 审批状态
        self.approval_status = approval_status
        # 审批详情页面地址
        self.approval_url = approval_url

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.approval_status is not None:
            result['approval_status'] = self.approval_status
        if self.approval_url is not None:
            result['approval_url'] = self.approval_url
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('approval_status') is not None:
            self.approval_status = m.get('approval_status')
        if m.get('approval_url') is not None:
            self.approval_url = m.get('approval_url')
        return self


class UpdateIngressTrafficweightRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        service_id: str = None,
        service_weights: List[ServiceWeight] = None,
        cell_weights: List[CellWeight] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # service id
        self.service_id = service_id
        # 流量权重列表
        self.service_weights = service_weights
        # 流量权重列表蓝绿发布v2
        self.cell_weights = cell_weights

    def validate(self):
        self.validate_required(self.service_id, 'service_id')
        if self.service_weights:
            for k in self.service_weights:
                if k:
                    k.validate()
        if self.cell_weights:
            for k in self.cell_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.service_id is not None:
            result['service_id'] = self.service_id
        result['service_weights'] = []
        if self.service_weights is not None:
            for k in self.service_weights:
                result['service_weights'].append(k.to_map() if k else None)
        result['cell_weights'] = []
        if self.cell_weights is not None:
            for k in self.cell_weights:
                result['cell_weights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('service_id') is not None:
            self.service_id = m.get('service_id')
        self.service_weights = []
        if m.get('service_weights') is not None:
            for k in m.get('service_weights'):
                temp_model = ServiceWeight()
                self.service_weights.append(temp_model.from_map(k))
        self.cell_weights = []
        if m.get('cell_weights') is not None:
            for k in m.get('cell_weights'):
                temp_model = CellWeight()
                self.cell_weights.append(temp_model.from_map(k))
        return self


class UpdateIngressTrafficweightResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetOpsplanBluedetailRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        service_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # antcloud.ldc.opsplan.detail.query 接口返回的 group_collection_list. app_group_list.id
        self.service_id = service_id

    def validate(self):
        self.validate_required(self.service_id, 'service_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.service_id is not None:
            result['service_id'] = self.service_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('service_id') is not None:
            self.service_id = m.get('service_id')
        return self


class GetOpsplanBluedetailResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        pod_list: List[PodInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # pod信息列表
        self.pod_list = pod_list

    def validate(self):
        if self.pod_list:
            for k in self.pod_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['pod_list'] = []
        if self.pod_list is not None:
            for k in self.pod_list:
                result['pod_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.pod_list = []
        if m.get('pod_list') is not None:
            for k in m.get('pod_list'):
                temp_model = PodInfo()
                self.pod_list.append(temp_model.from_map(k))
        return self


class ListIngressTrafficweightRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        service_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # lks_service_id，antcloud.ldc.opsplan.detail.query 接口返回的 group_collection_list. app_group_list.id，和查询应用服务发布单详情的id一样
        self.service_id = service_id

    def validate(self):
        self.validate_required(self.service_id, 'service_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.service_id is not None:
            result['service_id'] = self.service_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('service_id') is not None:
            self.service_id = m.get('service_id')
        return self


class ListIngressTrafficweightResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        service_weights: List[ServiceWeight] = None,
        cell_weights: List[CellWeight] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 流量权重列表
        self.service_weights = service_weights
        # 流量权重列表蓝绿发布v2
        self.cell_weights = cell_weights

    def validate(self):
        if self.service_weights:
            for k in self.service_weights:
                if k:
                    k.validate()
        if self.cell_weights:
            for k in self.cell_weights:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['service_weights'] = []
        if self.service_weights is not None:
            for k in self.service_weights:
                result['service_weights'].append(k.to_map() if k else None)
        result['cell_weights'] = []
        if self.cell_weights is not None:
            for k in self.cell_weights:
                result['cell_weights'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.service_weights = []
        if m.get('service_weights') is not None:
            for k in m.get('service_weights'):
                temp_model = ServiceWeight()
                self.service_weights.append(temp_model.from_map(k))
        self.cell_weights = []
        if m.get('cell_weights') is not None:
            for k in m.get('cell_weights'):
                temp_model = CellWeight()
                self.cell_weights.append(temp_model.from_map(k))
        return self


class CreateOamserviceApplicationconfigurationRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        yamlcontent: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # ApplicationConfiguration yaml字符串
        self.yamlcontent = yamlcontent

    def validate(self):
        self.validate_required(self.yamlcontent, 'yamlcontent')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.yamlcontent is not None:
            result['yamlcontent'] = self.yamlcontent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('yamlcontent') is not None:
            self.yamlcontent = m.get('yamlcontent')
        return self


class CreateOamserviceApplicationconfigurationResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        applicationconfiguraion: OAMApplicationConfiguration = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 
        self.applicationconfiguraion = applicationconfiguraion

    def validate(self):
        if self.applicationconfiguraion:
            self.applicationconfiguraion.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.applicationconfiguraion is not None:
            result['applicationconfiguraion'] = self.applicationconfiguraion.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('applicationconfiguraion') is not None:
            temp_model = OAMApplicationConfiguration()
            self.applicationconfiguraion = temp_model.from_map(m['applicationconfiguraion'])
        return self


class CreateFedloadbalancerRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        namespace: str = None,
        addr_type: str = None,
        spec: str = None,
        cells: List[str] = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 联邦负载均衡实例名称，RFC1035 主机名规范 [a-z]([-a-z0-9]*[a-z0-9])?
        self.name = name
        # 命名空间
        self.namespace = namespace
        # 地址类型，例如公网、内网
        self.addr_type = addr_type
        # 指定负载均衡规格大小
        self.spec = spec
        # 联邦负载均衡实例对应的部署单元列表
        self.cells = cells
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.name, 'name')
        if self.name is not None:
            self.validate_max_length(self.name, 'name', 63)
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.addr_type, 'addr_type')
        self.validate_required(self.cells, 'cells')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.addr_type is not None:
            result['addr_type'] = self.addr_type
        if self.spec is not None:
            result['spec'] = self.spec
        if self.cells is not None:
            result['cells'] = self.cells
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('addr_type') is not None:
            self.addr_type = m.get('addr_type')
        if m.get('spec') is not None:
            self.spec = m.get('spec')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class CreateFedloadbalancerResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        name: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 联邦负载均衡名称
        self.name = name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class UpdateFedloadbalancerRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        namespace: str = None,
        addr_type: str = None,
        spec: str = None,
        cells: List[str] = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 联邦负载均衡实例名称
        self.name = name
        # 联邦负载均衡实例所在命名空间
        self.namespace = namespace
        # 地址类型，例如公网、内网
        self.addr_type = addr_type
        # 指定负载均衡规格
        self.spec = spec
        # 联邦负载均衡实例对应的部署单元列表
        self.cells = cells
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.addr_type, 'addr_type')
        self.validate_required(self.cells, 'cells')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.addr_type is not None:
            result['addr_type'] = self.addr_type
        if self.spec is not None:
            result['spec'] = self.spec
        if self.cells is not None:
            result['cells'] = self.cells
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('addr_type') is not None:
            self.addr_type = m.get('addr_type')
        if m.get('spec') is not None:
            self.spec = m.get('spec')
        if m.get('cells') is not None:
            self.cells = m.get('cells')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class UpdateFedloadbalancerResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListFedloadbalancerRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        namespace: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 命名空间
        self.namespace = namespace
        # 支持模糊搜索
        self.name = name
        # 页数
        self.page_number = page_number
        # 分页大小
        self.page_size = page_size

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        return self


class ListFedloadbalancerResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        fed_loadbalancer_list: List[FedLoadBalancer] = None,
        total_count: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 联邦负载均衡实例列表
        self.fed_loadbalancer_list = fed_loadbalancer_list
        # 查询到的联邦负载均衡实例总数
        self.total_count = total_count

    def validate(self):
        if self.fed_loadbalancer_list:
            for k in self.fed_loadbalancer_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['fed_loadbalancer_list'] = []
        if self.fed_loadbalancer_list is not None:
            for k in self.fed_loadbalancer_list:
                result['fed_loadbalancer_list'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['total_count'] = self.total_count
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.fed_loadbalancer_list = []
        if m.get('fed_loadbalancer_list') is not None:
            for k in m.get('fed_loadbalancer_list'):
                temp_model = FedLoadBalancer()
                self.fed_loadbalancer_list.append(temp_model.from_map(k))
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        return self


class DeleteFedloadbalancerRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        namespace: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 命名空间
        self.namespace = namespace
        # 联邦负载均衡实例的名称
        self.name = name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DeleteFedloadbalancerResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class GetFedloadbalancerRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        namespace: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 命名空间
        self.namespace = namespace
        # 联邦负载均衡名称
        self.name = name

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class GetFedloadbalancerResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        fed_loadbalancer: FedLoadBalancer = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 联邦负载均衡实例信息
        self.fed_loadbalancer = fed_loadbalancer

    def validate(self):
        if self.fed_loadbalancer:
            self.fed_loadbalancer.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.fed_loadbalancer is not None:
            result['fed_loadbalancer'] = self.fed_loadbalancer.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('fed_loadbalancer') is not None:
            temp_model = FedLoadBalancer()
            self.fed_loadbalancer = temp_model.from_map(m['fed_loadbalancer'])
        return self


class ImportUnireleaseSolutionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        solution: str = None,
        tenants: List[str] = None,
        ac_id: str = None,
        env: str = None,
        emergent: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # Line迭代发布Json String
        self.solution = solution
        # 机构列表信息；如果不填默认是所有机构统一发布
        self.tenants = tenants
        # 银数AC工单ID
        self.ac_id = ac_id
        # 环境信息
        self.env = env
        # 是否是紧急发布场景
        self.emergent = emergent

    def validate(self):
        self.validate_required(self.solution, 'solution')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.solution is not None:
            result['solution'] = self.solution
        if self.tenants is not None:
            result['tenants'] = self.tenants
        if self.ac_id is not None:
            result['ac_id'] = self.ac_id
        if self.env is not None:
            result['env'] = self.env
        if self.emergent is not None:
            result['emergent'] = self.emergent
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('solution') is not None:
            self.solution = m.get('solution')
        if m.get('tenants') is not None:
            self.tenants = m.get('tenants')
        if m.get('ac_id') is not None:
            self.ac_id = m.get('ac_id')
        if m.get('env') is not None:
            self.env = m.get('env')
        if m.get('emergent') is not None:
            self.emergent = m.get('emergent')
        return self


class ImportUnireleaseSolutionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
        solution_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 返回结果
        self.success = success
        # 解决方案ID
        self.solution_id = solution_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        if self.solution_id is not None:
            result['solution_id'] = self.solution_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('solution_id') is not None:
            self.solution_id = m.get('solution_id')
        return self


class ListUnireleaseSolutionsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page: int = None,
        page_size: int = None,
        operator: str = None,
        name: str = None,
        creation_time_from: str = None,
        creation_time_to: str = None,
        ac_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 当前页
        self.page = page
        # 页大小
        self.page_size = page_size
        # 操作人
        self.operator = operator
        # 发布名称
        self.name = name
        # 创建时间初始值
        self.creation_time_from = creation_time_from
        # 创建时间结束值
        self.creation_time_to = creation_time_to
        # AC ID
        self.ac_id = ac_id

    def validate(self):
        self.validate_required(self.page, 'page')
        self.validate_required(self.page_size, 'page_size')
        if self.creation_time_from is not None:
            self.validate_pattern(self.creation_time_from, 'creation_time_from', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')
        if self.creation_time_to is not None:
            self.validate_pattern(self.creation_time_to, 'creation_time_to', '\\d{4}[-]\\d{1,2}[-]\\d{1,2}[T]\\d{2}:\\d{2}:\\d{2}([Z]|([\\.]\\d{1,9})?[\\+]\\d{2}[\\:]?\\d{2})')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page is not None:
            result['page'] = self.page
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.operator is not None:
            result['operator'] = self.operator
        if self.name is not None:
            result['name'] = self.name
        if self.creation_time_from is not None:
            result['creation_time_from'] = self.creation_time_from
        if self.creation_time_to is not None:
            result['creation_time_to'] = self.creation_time_to
        if self.ac_id is not None:
            result['ac_id'] = self.ac_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page') is not None:
            self.page = m.get('page')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('creation_time_from') is not None:
            self.creation_time_from = m.get('creation_time_from')
        if m.get('creation_time_to') is not None:
            self.creation_time_to = m.get('creation_time_to')
        if m.get('ac_id') is not None:
            self.ac_id = m.get('ac_id')
        return self


class ListUnireleaseSolutionsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: List[UnireleaseSolution] = None,
        total_size: int = None,
        page_size: int = None,
        current_page: int = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 解决方案列表返回
        self.data = data
        # 总数
        self.total_size = total_size
        # 页大小
        self.page_size = page_size
        # 当前页
        self.current_page = current_page

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        if self.total_size is not None:
            result['total_size'] = self.total_size
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.current_page is not None:
            result['current_page'] = self.current_page
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = UnireleaseSolution()
                self.data.append(temp_model.from_map(k))
        if m.get('total_size') is not None:
            self.total_size = m.get('total_size')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('current_page') is not None:
            self.current_page = m.get('current_page')
        return self


class GetUnireleaseSolutionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        solution_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 解决方案发布ID
        self.solution_id = solution_id

    def validate(self):
        self.validate_required(self.solution_id, 'solution_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.solution_id is not None:
            result['solution_id'] = self.solution_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('solution_id') is not None:
            self.solution_id = m.get('solution_id')
        return self


class GetUnireleaseSolutionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        data: UnireleaseSolution = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 解决方案详情
        self.data = data

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.data is not None:
            result['data'] = self.data.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('data') is not None:
            temp_model = UnireleaseSolution()
            self.data = temp_model.from_map(m['data'])
        return self


class GetUnireleasePipelineRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        solution_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 解决方案发布单ID
        self.solution_id = solution_id

    def validate(self):
        self.validate_required(self.solution_id, 'solution_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.solution_id is not None:
            result['solution_id'] = self.solution_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('solution_id') is not None:
            self.solution_id = m.get('solution_id')
        return self


class GetUnireleasePipelineResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        id: str = None,
        solution_id: str = None,
        state: str = None,
        tenant_pipelines: List[TenantAppReleasePipeline] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # pipeline ID
        self.id = id
        # 解决方案ID
        self.solution_id = solution_id
        # 发布单状态
        self.state = state
        # 应用发布状态
        self.tenant_pipelines = tenant_pipelines

    def validate(self):
        if self.tenant_pipelines:
            for k in self.tenant_pipelines:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.id is not None:
            result['id'] = self.id
        if self.solution_id is not None:
            result['solution_id'] = self.solution_id
        if self.state is not None:
            result['state'] = self.state
        result['tenant_pipelines'] = []
        if self.tenant_pipelines is not None:
            for k in self.tenant_pipelines:
                result['tenant_pipelines'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('solution_id') is not None:
            self.solution_id = m.get('solution_id')
        if m.get('state') is not None:
            self.state = m.get('state')
        self.tenant_pipelines = []
        if m.get('tenant_pipelines') is not None:
            for k in m.get('tenant_pipelines'):
                temp_model = TenantAppReleasePipeline()
                self.tenant_pipelines.append(temp_model.from_map(k))
        return self


class ExecUnireleasePipelinesRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        solution_id: str = None,
        tenants: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 解决方案ID
        self.solution_id = solution_id
        # 租户/机构名称列表，不填默认当前机构所有租户
        self.tenants = tenants

    def validate(self):
        self.validate_required(self.solution_id, 'solution_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.solution_id is not None:
            result['solution_id'] = self.solution_id
        if self.tenants is not None:
            result['tenants'] = self.tenants
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('solution_id') is not None:
            self.solution_id = m.get('solution_id')
        if m.get('tenants') is not None:
            self.tenants = m.get('tenants')
        return self


class ExecUnireleasePipelinesResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 执行成功
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class GetUnireleaseTenantsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        solution: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 解决方案Json
        self.solution = solution

    def validate(self):
        self.validate_required(self.solution, 'solution')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.solution is not None:
            result['solution'] = self.solution
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('solution') is not None:
            self.solution = m.get('solution')
        return self


class GetUnireleaseTenantsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        tenants: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 解决方案租户列表信息
        self.tenants = tenants

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.tenants is not None:
            result['tenants'] = self.tenants
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('tenants') is not None:
            self.tenants = m.get('tenants')
        return self


class AddContainerserviceMiddlewareconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        namespace: str = None,
        workspace_group: str = None,
        container_service_name: str = None,
        container_service_revision: str = None,
        operator: str = None,
        middleware_configs: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 命名空间
        self.namespace = namespace
        # 工作空间组
        self.workspace_group = workspace_group
        # 应用服务名
        self.container_service_name = container_service_name
        # 应用服务版本
        self.container_service_revision = container_service_revision
        # 操作人账号
        self.operator = operator
        # 中间件配置
        self.middleware_configs = middleware_configs

    def validate(self):
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.container_service_revision, 'container_service_revision')
        self.validate_required(self.operator, 'operator')
        self.validate_required(self.middleware_configs, 'middleware_configs')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.container_service_revision is not None:
            result['container_service_revision'] = self.container_service_revision
        if self.operator is not None:
            result['operator'] = self.operator
        if self.middleware_configs is not None:
            result['middleware_configs'] = self.middleware_configs
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('container_service_revision') is not None:
            self.container_service_revision = m.get('container_service_revision')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('middleware_configs') is not None:
            self.middleware_configs = m.get('middleware_configs')
        return self


class AddContainerserviceMiddlewareconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ExportOpsplanStagesRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service: ContainerServiceOperation = None,
        group_strategy: str = None,
        workspace_group_name: str = None,
        namespace: str = None,
        operation: str = None,
        group_amount: int = None,
        max_group_capacity: int = None,
        need_beta: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 容器服务列表
        self.container_service = container_service
        # Pod分组策略。
        self.group_strategy = group_strategy
        # 工作空间组名称
        self.workspace_group_name = workspace_group_name
        # 命名空间
        self.namespace = namespace
        # 目前支持：REBOOT | REPLACE | DEPLOY | SCALEINOUT，其余默认DEPLOY
        self.operation = operation
        # 最小分组数
        self.group_amount = group_amount
        # 每个分组的最大涉及变更pod个数
        self.max_group_capacity = max_group_capacity
        # 是否开启beta分组，目前仅在扩缩容场景下使用，默认false
        self.need_beta = need_beta

    def validate(self):
        if self.container_service:
            self.container_service.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service is not None:
            result['container_service'] = self.container_service.to_map()
        if self.group_strategy is not None:
            result['group_strategy'] = self.group_strategy
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operation is not None:
            result['operation'] = self.operation
        if self.group_amount is not None:
            result['group_amount'] = self.group_amount
        if self.max_group_capacity is not None:
            result['max_group_capacity'] = self.max_group_capacity
        if self.need_beta is not None:
            result['need_beta'] = self.need_beta
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service') is not None:
            temp_model = ContainerServiceOperation()
            self.container_service = temp_model.from_map(m['container_service'])
        if m.get('group_strategy') is not None:
            self.group_strategy = m.get('group_strategy')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operation') is not None:
            self.operation = m.get('operation')
        if m.get('group_amount') is not None:
            self.group_amount = m.get('group_amount')
        if m.get('max_group_capacity') is not None:
            self.max_group_capacity = m.get('max_group_capacity')
        if m.get('need_beta') is not None:
            self.need_beta = m.get('need_beta')
        return self


class ExportOpsplanStagesResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        batches: List[ReleaseBatchObj] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 计算的分批结果，包含各批次及其Pods
        self.batches = batches

    def validate(self):
        if self.batches:
            for k in self.batches:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['batches'] = []
        if self.batches is not None:
            for k in self.batches:
                result['batches'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.batches = []
        if m.get('batches') is not None:
            for k in m.get('batches'):
                temp_model = ReleaseBatchObj()
                self.batches.append(temp_model.from_map(k))
        return self


class DetailAppMetainfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group_label: str = None,
        app_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组的label：SIT, DEV, ...
        self.workspace_group_label = workspace_group_label
        # 应用名字
        # app:appService在此场景下为1:1，否则会报错
        self.app_name = app_name

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group_label is not None:
            result['workspace_group_label'] = self.workspace_group_label
        if self.app_name is not None:
            result['app_name'] = self.app_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group_label') is not None:
            self.workspace_group_label = m.get('workspace_group_label')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        return self


class DetailAppMetainfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_group_name: str = None,
        namespace: str = None,
        container_service_name: str = None,
        container_service_revision: str = None,
        instance_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 工作空间组的名字
        self.workspace_group_name = workspace_group_name
        # 名称空间
        self.namespace = namespace
        # 应用服务名字
        self.container_service_name = container_service_name
        # 应用服务当前revision
        self.container_service_revision = container_service_revision
        # 中间件instanceId
        self.instance_id = instance_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.container_service_revision is not None:
            result['container_service_revision'] = self.container_service_revision
        if self.instance_id is not None:
            result['instance_id'] = self.instance_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('container_service_revision') is not None:
            self.container_service_revision = m.get('container_service_revision')
        if m.get('instance_id') is not None:
            self.instance_id = m.get('instance_id')
        return self


class UpdateSidecaropsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        client_token: str = None,
        namespace: str = None,
        workspace_group: str = None,
        sidecar_config: SidecarConfig = None,
        sidecar_version: str = None,
        cell_name: str = None,
        server_identities: List[str] = None,
        order_num: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称
        self.app_name = app_name
        # 保证请求幂等性
        self.client_token = client_token
        # 所属命名空间
        self.namespace = namespace
        # 所属工作空间组
        self.workspace_group = workspace_group
        # sidecar的类型，如mosn，odp
        self.sidecar_config = sidecar_config
        # 指定sidecar的基线模板版本进行升级，可选，不填时，默认选中指定sidecar的最新版本进行升级
        self.sidecar_version = sidecar_version
        # 单元名称
        self.cell_name = cell_name
        # 要更新的hostname列表
        self.server_identities = server_identities
        # 工单id
        self.order_num = order_num

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.sidecar_config, 'sidecar_config')
        if self.sidecar_config:
            self.sidecar_config.validate()
        self.validate_required(self.cell_name, 'cell_name')
        self.validate_required(self.server_identities, 'server_identities')
        self.validate_required(self.order_num, 'order_num')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.sidecar_config is not None:
            result['sidecar_config'] = self.sidecar_config.to_map()
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.server_identities is not None:
            result['server_identities'] = self.server_identities
        if self.order_num is not None:
            result['order_num'] = self.order_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('sidecar_config') is not None:
            temp_model = SidecarConfig()
            self.sidecar_config = temp_model.from_map(m['sidecar_config'])
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('server_identities') is not None:
            self.server_identities = m.get('server_identities')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        return self


class UpdateSidecaropsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
        updated_pod_numbers: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 是否成功
        self.success = success
        # 返回被更新的podNumber list；可用于回滚流程的入参
        self.updated_pod_numbers = updated_pod_numbers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        if self.updated_pod_numbers is not None:
            result['updated_pod_numbers'] = self.updated_pod_numbers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('updated_pod_numbers') is not None:
            self.updated_pod_numbers = m.get('updated_pod_numbers')
        return self


class CountContainerserviceCellreplicasRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service_name: str = None,
        namespace: str = None,
        workspace_group_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务名称
        self.container_service_name = container_service_name
        # 应用服务的名称空间
        self.namespace = namespace
        # 工作空间名称
        self.workspace_group_name = workspace_group_name

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group_name, 'workspace_group_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        return self


class CountContainerserviceCellreplicasResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cell_replicas_list: List[ReplicaCount] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 应用服务当前的部署单元，及其部署副本数
        self.cell_replicas_list = cell_replicas_list

    def validate(self):
        if self.cell_replicas_list:
            for k in self.cell_replicas_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cell_replicas_list'] = []
        if self.cell_replicas_list is not None:
            for k in self.cell_replicas_list:
                result['cell_replicas_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cell_replicas_list = []
        if m.get('cell_replicas_list') is not None:
            for k in m.get('cell_replicas_list'):
                temp_model = ReplicaCount()
                self.cell_replicas_list.append(temp_model.from_map(k))
        return self


class ListSidecaropsTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        sidecar_name: str = None,
        sidecar_version: str = None,
        workspace_group_id: str = None,
        workspace_group_label: str = None,
        workspace_id: str = None,
        image: str = None,
        tenant_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # sidecar类型
        self.sidecar_name = sidecar_name
        # sidecar版本
        self.sidecar_version = sidecar_version
        # 工作空间组
        self.workspace_group_id = workspace_group_id
        # 工作空间组名
        self.workspace_group_label = workspace_group_label
        # 工作空间
        self.workspace_id = workspace_id
        # 镜像地址
        self.image = image
        # 可以根据租户名称筛选应用于该租户的基线模板
        self.tenant_name = tenant_name

    def validate(self):
        self.validate_required(self.sidecar_name, 'sidecar_name')
        self.validate_required(self.workspace_group_label, 'workspace_group_label')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.workspace_group_id is not None:
            result['workspace_group_id'] = self.workspace_group_id
        if self.workspace_group_label is not None:
            result['workspace_group_label'] = self.workspace_group_label
        if self.workspace_id is not None:
            result['workspace_id'] = self.workspace_id
        if self.image is not None:
            result['image'] = self.image
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('workspace_group_id') is not None:
            self.workspace_group_id = m.get('workspace_group_id')
        if m.get('workspace_group_label') is not None:
            self.workspace_group_label = m.get('workspace_group_label')
        if m.get('workspace_id') is not None:
            self.workspace_id = m.get('workspace_id')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        return self


class ListSidecaropsTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        sidecar_templates: List[SidecarTemplateMeta] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 返回的特定类型的sidecar版本信息列表，只取最近的20条
        self.sidecar_templates = sidecar_templates

    def validate(self):
        if self.sidecar_templates:
            for k in self.sidecar_templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['sidecar_templates'] = []
        if self.sidecar_templates is not None:
            for k in self.sidecar_templates:
                result['sidecar_templates'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.sidecar_templates = []
        if m.get('sidecar_templates') is not None:
            for k in m.get('sidecar_templates'):
                temp_model = SidecarTemplateMeta()
                self.sidecar_templates.append(temp_model.from_map(k))
        return self


class UpdateSidecaropsConsistencyRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        client_token: str = None,
        namespace: str = None,
        workspace_group: str = None,
        cell_names: List[str] = None,
        sidecar_config: SidecarConfig = None,
        sidecar_version: str = None,
        order_num: str = None,
        is_rollback: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称
        self.app_name = app_name
        # 请求唯一性验证
        self.client_token = client_token
        # 命名空间
        self.namespace = namespace
        # 工作空间组
        self.workspace_group = workspace_group
        # 需要更新的cell名称数组
        self.cell_names = cell_names
        # 需要更新的sidecar属性
        self.sidecar_config = sidecar_config
        # 指定sidecar版本进行升级，不填入此字段时，默认使用对应sidecar的最新版本
        self.sidecar_version = sidecar_version
        # 发布单号
        self.order_num = order_num
        # 是否回滚流程
        self.is_rollback = is_rollback

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.cell_names, 'cell_names')
        self.validate_required(self.sidecar_config, 'sidecar_config')
        if self.sidecar_config:
            self.sidecar_config.validate()
        self.validate_required(self.order_num, 'order_num')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.cell_names is not None:
            result['cell_names'] = self.cell_names
        if self.sidecar_config is not None:
            result['sidecar_config'] = self.sidecar_config.to_map()
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.order_num is not None:
            result['order_num'] = self.order_num
        if self.is_rollback is not None:
            result['is_rollback'] = self.is_rollback
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('cell_names') is not None:
            self.cell_names = m.get('cell_names')
        if m.get('sidecar_config') is not None:
            temp_model = SidecarConfig()
            self.sidecar_config = temp_model.from_map(m['sidecar_config'])
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        if m.get('is_rollback') is not None:
            self.is_rollback = m.get('is_rollback')
        return self


class UpdateSidecaropsConsistencyResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        updated_cells: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 已经更新的cell列表
        self.updated_cells = updated_cells

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.updated_cells is not None:
            result['updated_cells'] = self.updated_cells
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('updated_cells') is not None:
            self.updated_cells = m.get('updated_cells')
        return self


class FinishSidecaropsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        client_token: str = None,
        namespace: str = None,
        workspace_group: str = None,
        order_num: str = None,
        cell_names: List[str] = None,
        sidecar_config: SidecarConfig = None,
        is_rollback: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称
        self.app_name = app_name
        # 请求token
        self.client_token = client_token
        # 命名空间
        self.namespace = namespace
        # 工作空间组
        self.workspace_group = workspace_group
        # 请求单号
        self.order_num = order_num
        # 部署单元列表
        self.cell_names = cell_names
        # sidecar配置
        self.sidecar_config = sidecar_config
        # 是否回滚流程
        self.is_rollback = is_rollback

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.order_num, 'order_num')
        self.validate_required(self.cell_names, 'cell_names')
        self.validate_required(self.sidecar_config, 'sidecar_config')
        if self.sidecar_config:
            self.sidecar_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.order_num is not None:
            result['order_num'] = self.order_num
        if self.cell_names is not None:
            result['cell_names'] = self.cell_names
        if self.sidecar_config is not None:
            result['sidecar_config'] = self.sidecar_config.to_map()
        if self.is_rollback is not None:
            result['is_rollback'] = self.is_rollback
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        if m.get('cell_names') is not None:
            self.cell_names = m.get('cell_names')
        if m.get('sidecar_config') is not None:
            temp_model = SidecarConfig()
            self.sidecar_config = temp_model.from_map(m['sidecar_config'])
        if m.get('is_rollback') is not None:
            self.is_rollback = m.get('is_rollback')
        return self


class FinishSidecaropsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QuerySidecaropsStateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        namespace: str = None,
        workspace_group: str = None,
        cell_names: List[str] = None,
        order_num: str = None,
        sidecar_config: SidecarConfig = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称
        self.app_name = app_name
        # 命名空间
        self.namespace = namespace
        # 命名空间组名称
        self.workspace_group = workspace_group
        # 需要查询的部署单元列表
        self.cell_names = cell_names
        # 运维单号
        self.order_num = order_num
        # sidecar配置
        self.sidecar_config = sidecar_config

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.cell_names, 'cell_names')
        self.validate_required(self.order_num, 'order_num')
        self.validate_required(self.sidecar_config, 'sidecar_config')
        if self.sidecar_config:
            self.sidecar_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.cell_names is not None:
            result['cell_names'] = self.cell_names
        if self.order_num is not None:
            result['order_num'] = self.order_num
        if self.sidecar_config is not None:
            result['sidecar_config'] = self.sidecar_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('cell_names') is not None:
            self.cell_names = m.get('cell_names')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        if m.get('sidecar_config') is not None:
            temp_model = SidecarConfig()
            self.sidecar_config = temp_model.from_map(m['sidecar_config'])
        return self


class QuerySidecaropsStateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        release_info: List[SidecarReleaseStatus] = None,
        state: str = None,
        change_targets: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # sidecar运维状态列表
        self.release_info = release_info
        # 状态
        self.state = state
        # 变更核心所需变更后改动的podIp
        self.change_targets = change_targets

    def validate(self):
        if self.release_info:
            for k in self.release_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['release_info'] = []
        if self.release_info is not None:
            for k in self.release_info:
                result['release_info'].append(k.to_map() if k else None)
        if self.state is not None:
            result['state'] = self.state
        if self.change_targets is not None:
            result['change_targets'] = self.change_targets
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.release_info = []
        if m.get('release_info') is not None:
            for k in m.get('release_info'):
                temp_model = SidecarReleaseStatus()
                self.release_info.append(temp_model.from_map(k))
        if m.get('state') is not None:
            self.state = m.get('state')
        if m.get('change_targets') is not None:
            self.change_targets = m.get('change_targets')
        return self


class AddSidecaropsTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        sidecar_name: str = None,
        image: str = None,
        template: str = None,
        scope: List[str] = None,
        description: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # sidecar名称
        self.sidecar_name = sidecar_name
        # 镜像地址
        self.image = image
        # 新的模板
        self.template = template
        # 基线模板作用域范围，如：["gray", "prod"]，不填时默认全局
        self.scope = scope
        # 版本描述
        self.description = description

    def validate(self):
        self.validate_required(self.sidecar_name, 'sidecar_name')
        self.validate_required(self.image, 'image')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.image is not None:
            result['image'] = self.image
        if self.template is not None:
            result['template'] = self.template
        if self.scope is not None:
            result['scope'] = self.scope
        if self.description is not None:
            result['description'] = self.description
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('template') is not None:
            self.template = m.get('template')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        if m.get('description') is not None:
            self.description = m.get('description')
        return self


class AddSidecaropsTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QuerySidecaropsReleaseinfoRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        sidecar_type: str = None,
        workspace_group: str = None,
        namespace: str = None,
        order_num: str = None,
        release_version: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用名称（借花场景即为应用服务名）
        self.app_name = app_name
        # sidecar类型
        self.sidecar_type = sidecar_type
        # 工作空间组
        self.workspace_group = workspace_group
        # 命名空间
        self.namespace = namespace
        # 变更单号
        self.order_num = order_num
        # 应用服务发布sidecar的版本号，每次发布程序会自己分配一个，可用于作为查询key
        self.release_version = release_version

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.sidecar_type, 'sidecar_type')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.sidecar_type is not None:
            result['sidecar_type'] = self.sidecar_type
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.order_num is not None:
            result['order_num'] = self.order_num
        if self.release_version is not None:
            result['release_version'] = self.release_version
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('sidecar_type') is not None:
            self.sidecar_type = m.get('sidecar_type')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        if m.get('release_version') is not None:
            self.release_version = m.get('release_version')
        return self


class QuerySidecaropsReleaseinfoResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        sidecar_config: SidecarConfig = None,
        container_service_name: str = None,
        sidecar_version: str = None,
        param: str = None,
        status: str = None,
        release_version: str = None,
        last_release_version: str = None,
        order_num: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 所查询版本的实际sidecarConfig信息
        self.sidecar_config = sidecar_config
        # 应用服务名
        self.container_service_name = container_service_name
        # sidecar模板的版本号，与应用无关
        self.sidecar_version = sidecar_version
        # 发布相关的应用参数，如feature等
        self.param = param
        # 发布所处状态
        self.status = status
        # 以时间戳生成的发布版本号
        self.release_version = release_version
        # 上一个版本号
        self.last_release_version = last_release_version
        # 执行单号，调用方唯一确定一次发布的单号；
        self.order_num = order_num

    def validate(self):
        if self.sidecar_config:
            self.sidecar_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.sidecar_config is not None:
            result['sidecar_config'] = self.sidecar_config.to_map()
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.param is not None:
            result['param'] = self.param
        if self.status is not None:
            result['status'] = self.status
        if self.release_version is not None:
            result['release_version'] = self.release_version
        if self.last_release_version is not None:
            result['last_release_version'] = self.last_release_version
        if self.order_num is not None:
            result['order_num'] = self.order_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('sidecar_config') is not None:
            temp_model = SidecarConfig()
            self.sidecar_config = temp_model.from_map(m['sidecar_config'])
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('param') is not None:
            self.param = m.get('param')
        if m.get('status') is not None:
            self.status = m.get('status')
        if m.get('release_version') is not None:
            self.release_version = m.get('release_version')
        if m.get('last_release_version') is not None:
            self.last_release_version = m.get('last_release_version')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        return self


class InitSidecaropsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service_name: str = None,
        client_token: str = None,
        namespace: str = None,
        workspace_group: str = None,
        sidecar_configs: List[SidecarConfig] = None,
        cell_name: str = None,
        server_identities: List[str] = None,
        order_num: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务名称
        self.container_service_name = container_service_name
        # 预留用于防止请求重放
        self.client_token = client_token
        # 应用服务所属命名空间
        self.namespace = namespace
        # 工作空间组
        self.workspace_group = workspace_group
        # 需要被注入的sidecar配置列表，可以同时注入多个
        self.sidecar_configs = sidecar_configs
        # 部署单元名称
        self.cell_name = cell_name
        # 要被注入的pod列表，列表元素为pod的名称
        self.server_identities = server_identities
        # 执行单号，所以批次共用同一单号
        self.order_num = order_num

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.sidecar_configs, 'sidecar_configs')
        if self.sidecar_configs:
            for k in self.sidecar_configs:
                if k:
                    k.validate()
        self.validate_required(self.cell_name, 'cell_name')
        self.validate_required(self.server_identities, 'server_identities')
        self.validate_required(self.order_num, 'order_num')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        result['sidecar_configs'] = []
        if self.sidecar_configs is not None:
            for k in self.sidecar_configs:
                result['sidecar_configs'].append(k.to_map() if k else None)
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.server_identities is not None:
            result['server_identities'] = self.server_identities
        if self.order_num is not None:
            result['order_num'] = self.order_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        self.sidecar_configs = []
        if m.get('sidecar_configs') is not None:
            for k in m.get('sidecar_configs'):
                temp_model = SidecarConfig()
                self.sidecar_configs.append(temp_model.from_map(k))
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('server_identities') is not None:
            self.server_identities = m.get('server_identities')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        return self


class InitSidecaropsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class RebootSidecaropsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service_name: str = None,
        client_token: str = None,
        namespace: str = None,
        workspace_group: str = None,
        cell_name: str = None,
        server_identities: List[str] = None,
        order_num: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务名
        self.container_service_name = container_service_name
        # 防重放
        self.client_token = client_token
        # 命名空间
        self.namespace = namespace
        # 工作空间组
        self.workspace_group = workspace_group
        # 部署单元名称
        self.cell_name = cell_name
        # 需要重启的pod列表，元素值为pod的名称
        self.server_identities = server_identities
        # 执行单号
        self.order_num = order_num

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.cell_name, 'cell_name')
        self.validate_required(self.server_identities, 'server_identities')
        self.validate_required(self.order_num, 'order_num')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.server_identities is not None:
            result['server_identities'] = self.server_identities
        if self.order_num is not None:
            result['order_num'] = self.order_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('server_identities') is not None:
            self.server_identities = m.get('server_identities')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        return self


class RebootSidecaropsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class DeleteContainerserviceRevisionRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        revision: str = None,
        workspace_group: str = None,
        namespace: str = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务名称
        self.name = name
        # 版本号
        self.revision = revision
        # 所属工作空间组
        self.workspace_group = workspace_group
        # 所属命名空间
        self.namespace = namespace
        # 操作人账号
        self.operator = operator

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.revision, 'revision')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.operator, 'operator')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.revision is not None:
            result['revision'] = self.revision
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class DeleteContainerserviceRevisionResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ExecContainerserviceApihookRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        url: str = None,
        http_method: str = None,
        query_params: str = None,
        body: str = None,
        content_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # url地址
        self.url = url
        # GET/POST
        self.http_method = http_method
        # 请求参数
        self.query_params = query_params
        # 请求body
        self.body = body
        # application/x-www-form-urlencoded或application/json
        self.content_type = content_type

    def validate(self):
        self.validate_required(self.url, 'url')
        self.validate_required(self.http_method, 'http_method')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.url is not None:
            result['url'] = self.url
        if self.http_method is not None:
            result['http_method'] = self.http_method
        if self.query_params is not None:
            result['query_params'] = self.query_params
        if self.body is not None:
            result['body'] = self.body
        if self.content_type is not None:
            result['content_type'] = self.content_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('url') is not None:
            self.url = m.get('url')
        if m.get('http_method') is not None:
            self.http_method = m.get('http_method')
        if m.get('query_params') is not None:
            self.query_params = m.get('query_params')
        if m.get('body') is not None:
            self.body = m.get('body')
        if m.get('content_type') is not None:
            self.content_type = m.get('content_type')
        return self


class ExecContainerserviceApihookResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        api_result: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 接口返回结果
        self.api_result = api_result

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.api_result is not None:
            result['api_result'] = self.api_result
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('api_result') is not None:
            self.api_result = m.get('api_result')
        return self


class QuerySidecaropsAllservicesRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group_label: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 用于label到metaservice换取wsgName
        self.workspace_group_label = workspace_group_label

    def validate(self):
        self.validate_required(self.workspace_group_label, 'workspace_group_label')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group_label is not None:
            result['workspace_group_label'] = self.workspace_group_label
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group_label') is not None:
            self.workspace_group_label = m.get('workspace_group_label')
        return self


class QuerySidecaropsAllservicesResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        workspace_group_name: str = None,
        namespace: str = None,
        services_sidecar_info: List[AppServiceSidecarReleaseInfo] = None,
        unsatisfied_services_info: List[AppServiceSidecarReleaseInfo] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 根据wsglabel换到的wsgname
        self.workspace_group_name = workspace_group_name
        # 所属命名空间
        self.namespace = namespace
        # 应用服务详细配置信息，主要为sidecar当前在用的参数信息
        self.services_sidecar_info = services_sidecar_info
        # 不满足升级条件的服务信息，包含服务不唯一应用及正在升级的应用。
        self.unsatisfied_services_info = unsatisfied_services_info

    def validate(self):
        if self.services_sidecar_info:
            for k in self.services_sidecar_info:
                if k:
                    k.validate()
        if self.unsatisfied_services_info:
            for k in self.unsatisfied_services_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        result['services_sidecar_info'] = []
        if self.services_sidecar_info is not None:
            for k in self.services_sidecar_info:
                result['services_sidecar_info'].append(k.to_map() if k else None)
        result['unsatisfied_services_info'] = []
        if self.unsatisfied_services_info is not None:
            for k in self.unsatisfied_services_info:
                result['unsatisfied_services_info'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        self.services_sidecar_info = []
        if m.get('services_sidecar_info') is not None:
            for k in m.get('services_sidecar_info'):
                temp_model = AppServiceSidecarReleaseInfo()
                self.services_sidecar_info.append(temp_model.from_map(k))
        self.unsatisfied_services_info = []
        if m.get('unsatisfied_services_info') is not None:
            for k in m.get('unsatisfied_services_info'):
                temp_model = AppServiceSidecarReleaseInfo()
                self.unsatisfied_services_info.append(temp_model.from_map(k))
        return self


class UpdateSidecaropsTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        sidecar_name: str = None,
        sidecar_version: str = None,
        image: str = None,
        template: str = None,
        scope: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 要更新的sidecar名称
        self.sidecar_name = sidecar_name
        # 指定要更新的sidecar版本
        self.sidecar_version = sidecar_version
        # 根据image筛选要更新的基线
        self.image = image
        # 要更新的sidecar模板
        self.template = template
        # 要设置成的scope
        self.scope = scope

    def validate(self):
        self.validate_required(self.sidecar_name, 'sidecar_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.image is not None:
            result['image'] = self.image
        if self.template is not None:
            result['template'] = self.template
        if self.scope is not None:
            result['scope'] = self.scope
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('image') is not None:
            self.image = m.get('image')
        if m.get('template') is not None:
            self.template = m.get('template')
        if m.get('scope') is not None:
            self.scope = m.get('scope')
        return self


class UpdateSidecaropsTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CreateDeploymentTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        description: str = None,
        override_deploy_config: bool = None,
        deploy_config: DeployConfig = None,
        enable_custom_hook: bool = None,
        hook_type: str = None,
        custom_hooks: List[CustomHook] = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 模板编码
        self.name = name
        # 中文名称
        self.display_name = display_name
        # 模板描述
        self.description = description
        # 是否覆盖版本中的发布策略
        self.override_deploy_config = override_deploy_config
        # 发布策略
        self.deploy_config = deploy_config
        # 是否开启变更卡点
        self.enable_custom_hook = enable_custom_hook
        # 卡点类型：api或has
        self.hook_type = hook_type
        # 自定义卡点配置列表
        self.custom_hooks = custom_hooks
        # 操作人
        self.operator = operator

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.override_deploy_config, 'override_deploy_config')
        if self.deploy_config:
            self.deploy_config.validate()
        self.validate_required(self.enable_custom_hook, 'enable_custom_hook')
        if self.custom_hooks:
            for k in self.custom_hooks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.description is not None:
            result['description'] = self.description
        if self.override_deploy_config is not None:
            result['override_deploy_config'] = self.override_deploy_config
        if self.deploy_config is not None:
            result['deploy_config'] = self.deploy_config.to_map()
        if self.enable_custom_hook is not None:
            result['enable_custom_hook'] = self.enable_custom_hook
        if self.hook_type is not None:
            result['hook_type'] = self.hook_type
        result['custom_hooks'] = []
        if self.custom_hooks is not None:
            for k in self.custom_hooks:
                result['custom_hooks'].append(k.to_map() if k else None)
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('override_deploy_config') is not None:
            self.override_deploy_config = m.get('override_deploy_config')
        if m.get('deploy_config') is not None:
            temp_model = DeployConfig()
            self.deploy_config = temp_model.from_map(m['deploy_config'])
        if m.get('enable_custom_hook') is not None:
            self.enable_custom_hook = m.get('enable_custom_hook')
        if m.get('hook_type') is not None:
            self.hook_type = m.get('hook_type')
        self.custom_hooks = []
        if m.get('custom_hooks') is not None:
            for k in m.get('custom_hooks'):
                temp_model = CustomHook()
                self.custom_hooks.append(temp_model.from_map(k))
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class CreateDeploymentTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryUnireleaseSolutionfilesRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        date: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 日期
        self.date = date

    def validate(self):
        self.validate_required(self.date, 'date')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.date is not None:
            result['date'] = self.date
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('date') is not None:
            self.date = m.get('date')
        return self


class QueryUnireleaseSolutionfilesResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        solution_files: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 发布方案列表
        self.solution_files = solution_files

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.solution_files is not None:
            result['solution_files'] = self.solution_files
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('solution_files') is not None:
            self.solution_files = m.get('solution_files')
        return self


class GetUnireleaseSolutionfileRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        file_path: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # Sftp目录：/sftp/linkw/unionpay/date/id/prod/timestamp-solution.json
        # 
        self.file_path = file_path

    def validate(self):
        self.validate_required(self.file_path, 'file_path')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.file_path is not None:
            result['file_path'] = self.file_path
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('file_path') is not None:
            self.file_path = m.get('file_path')
        return self


class GetUnireleaseSolutionfileResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        soultion_content: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 发布方案内容，Json文件
        self.soultion_content = soultion_content

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.soultion_content is not None:
            result['soultion_content'] = self.soultion_content
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('soultion_content') is not None:
            self.soultion_content = m.get('soultion_content')
        return self


class UpdateDeploymentTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        display_name: str = None,
        description: str = None,
        override_deploy_config: bool = None,
        deploy_config: DeployConfig = None,
        enable_custom_hook: bool = None,
        hook_type: str = None,
        custom_hooks: List[CustomHook] = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 模板编码
        self.name = name
        # 中文名称
        self.display_name = display_name
        # 模板描述
        self.description = description
        # 是否覆盖版本中的发布策略
        self.override_deploy_config = override_deploy_config
        # 发布策略
        self.deploy_config = deploy_config
        # 是否开启变更卡点
        self.enable_custom_hook = enable_custom_hook
        # 卡点类型：api或has
        self.hook_type = hook_type
        # 自定义卡点配置列表
        self.custom_hooks = custom_hooks
        # 操作人
        self.operator = operator

    def validate(self):
        self.validate_required(self.name, 'name')
        self.validate_required(self.display_name, 'display_name')
        self.validate_required(self.override_deploy_config, 'override_deploy_config')
        if self.deploy_config:
            self.deploy_config.validate()
        self.validate_required(self.enable_custom_hook, 'enable_custom_hook')
        if self.custom_hooks:
            for k in self.custom_hooks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.display_name is not None:
            result['display_name'] = self.display_name
        if self.description is not None:
            result['description'] = self.description
        if self.override_deploy_config is not None:
            result['override_deploy_config'] = self.override_deploy_config
        if self.deploy_config is not None:
            result['deploy_config'] = self.deploy_config.to_map()
        if self.enable_custom_hook is not None:
            result['enable_custom_hook'] = self.enable_custom_hook
        if self.hook_type is not None:
            result['hook_type'] = self.hook_type
        result['custom_hooks'] = []
        if self.custom_hooks is not None:
            for k in self.custom_hooks:
                result['custom_hooks'].append(k.to_map() if k else None)
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('display_name') is not None:
            self.display_name = m.get('display_name')
        if m.get('description') is not None:
            self.description = m.get('description')
        if m.get('override_deploy_config') is not None:
            self.override_deploy_config = m.get('override_deploy_config')
        if m.get('deploy_config') is not None:
            temp_model = DeployConfig()
            self.deploy_config = temp_model.from_map(m['deploy_config'])
        if m.get('enable_custom_hook') is not None:
            self.enable_custom_hook = m.get('enable_custom_hook')
        if m.get('hook_type') is not None:
            self.hook_type = m.get('hook_type')
        self.custom_hooks = []
        if m.get('custom_hooks') is not None:
            for k in m.get('custom_hooks'):
                temp_model = CustomHook()
                self.custom_hooks.append(temp_model.from_map(k))
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class UpdateDeploymentTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListDeploymentTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        query_type: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 模板编码或名称模糊搜索
        self.name = name
        # 当前页码，从1开始，默认为1
        self.page_number = page_number
        # 分页大小，默认为10
        self.page_size = page_size
        # 查询方式，默认FUZZY，模糊查询
        self.query_type = query_type

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.query_type is not None:
            result['query_type'] = self.query_type
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('query_type') is not None:
            self.query_type = m.get('query_type')
        return self


class ListDeploymentTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        total_count: int = None,
        data: List[DeploymentTemplate] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 总数
        self.total_count = total_count
        # 模板列表
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.total_count is not None:
            result['total_count'] = self.total_count
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = DeploymentTemplate()
                self.data.append(temp_model.from_map(k))
        return self


class DeleteDeploymentTemplateRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 模板编码
        self.name = name

    def validate(self):
        self.validate_required(self.name, 'name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        return self


class DeleteDeploymentTemplateResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class ListEmergencyPlansRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        name: str = None,
        page_number: int = None,
        page_size: int = None,
        emergency_plan_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 预案名称
        self.name = name
        # 当前第几页
        self.page_number = page_number
        # 每页大小
        self.page_size = page_size
        # 预案id，只有传预案id时才返回预案参数
        self.emergency_plan_id = emergency_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.name is not None:
            result['name'] = self.name
        if self.page_number is not None:
            result['page_number'] = self.page_number
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.emergency_plan_id is not None:
            result['emergency_plan_id'] = self.emergency_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('page_number') is not None:
            self.page_number = m.get('page_number')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('emergency_plan_id') is not None:
            self.emergency_plan_id = m.get('emergency_plan_id')
        return self


class ListEmergencyPlansResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        total_count: int = None,
        data: List[EmergencyPlan] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 总数
        self.total_count = total_count
        # 预案列表
        self.data = data

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.total_count is not None:
            result['total_count'] = self.total_count
        result['data'] = []
        if self.data is not None:
            for k in self.data:
                result['data'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        self.data = []
        if m.get('data') is not None:
            for k in m.get('data'):
                temp_model = EmergencyPlan()
                self.data.append(temp_model.from_map(k))
        return self


class UpdateContainerserviceGrayreleaseconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        time_series_id: str = None,
        lks_service_id: str = None,
        gray_release_config: GrayReleaseConfig = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单的time series id
        self.time_series_id = time_series_id
        # lks service id，与plan_id同时传时前者生效。
        self.lks_service_id = lks_service_id
        # 灰度规则
        self.gray_release_config = gray_release_config

    def validate(self):
        self.validate_required(self.gray_release_config, 'gray_release_config')
        if self.gray_release_config:
            self.gray_release_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        if self.lks_service_id is not None:
            result['lks_service_id'] = self.lks_service_id
        if self.gray_release_config is not None:
            result['gray_release_config'] = self.gray_release_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        if m.get('lks_service_id') is not None:
            self.lks_service_id = m.get('lks_service_id')
        if m.get('gray_release_config') is not None:
            temp_model = GrayReleaseConfig()
            self.gray_release_config = temp_model.from_map(m['gray_release_config'])
        return self


class UpdateContainerserviceGrayreleaseconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class QueryContainerserivceGrayreleaseconfigRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        time_series_id: str = None,
        lks_service_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 发布单的time_series_id
        self.time_series_id = time_series_id
        # lks service的id，如果time_series_id与lks_service_id同时指定，后者生效
        self.lks_service_id = lks_service_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.time_series_id is not None:
            result['time_series_id'] = self.time_series_id
        if self.lks_service_id is not None:
            result['lks_service_id'] = self.lks_service_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('time_series_id') is not None:
            self.time_series_id = m.get('time_series_id')
        if m.get('lks_service_id') is not None:
            self.lks_service_id = m.get('lks_service_id')
        return self


class QueryContainerserivceGrayreleaseconfigResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        gray_release_config: GrayReleaseConfig = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 灰度发布配置
        self.gray_release_config = gray_release_config

    def validate(self):
        if self.gray_release_config:
            self.gray_release_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.gray_release_config is not None:
            result['gray_release_config'] = self.gray_release_config.to_map()
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('gray_release_config') is not None:
            temp_model = GrayReleaseConfig()
            self.gray_release_config = temp_model.from_map(m['gray_release_config'])
        return self


class DetailContainerserviceRevisiondiffRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        namespace: str = None,
        tenant_name: str = None,
        workspace_group: str = None,
        container_service_name: str = None,
        source_revision: str = None,
        target_revision: str = None,
        only_summary: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 命名空间
        self.namespace = namespace
        # 租户名
        self.tenant_name = tenant_name
        # 工作空间组
        self.workspace_group = workspace_group
        # 应用服务名称
        self.container_service_name = container_service_name
        # 源版本号，不传取应用服务当前发布成功的版本
        self.source_revision = source_revision
        # 目标版本号，当前需要对比的版本号
        self.target_revision = target_revision
        # 是否只显示摘要信息
        self.only_summary = only_summary

    def validate(self):
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.target_revision, 'target_revision')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.source_revision is not None:
            result['source_revision'] = self.source_revision
        if self.target_revision is not None:
            result['target_revision'] = self.target_revision
        if self.only_summary is not None:
            result['only_summary'] = self.only_summary
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('source_revision') is not None:
            self.source_revision = m.get('source_revision')
        if m.get('target_revision') is not None:
            self.target_revision = m.get('target_revision')
        if m.get('only_summary') is not None:
            self.only_summary = m.get('only_summary')
        return self


class DetailContainerserviceRevisiondiffResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        source_config: ContainerServiceConfig = None,
        source_revision: str = None,
        target_config: ContainerServiceConfig = None,
        target_revision: str = None,
        summary: str = None,
        diff_detail: str = None,
        risk_level: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 源版本配置详情
        self.source_config = source_config
        # 源版本号
        self.source_revision = source_revision
        # 目标版本配置详情
        self.target_config = target_config
        # 目标版本号
        self.target_revision = target_revision
        # 摘要信息
        self.summary = summary
        # diff详情，JSON数组字符串
        self.diff_detail = diff_detail
        # 风险等级: ORDINARY-一般、HIGH-高危
        self.risk_level = risk_level

    def validate(self):
        if self.source_config:
            self.source_config.validate()
        if self.target_config:
            self.target_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.source_config is not None:
            result['source_config'] = self.source_config.to_map()
        if self.source_revision is not None:
            result['source_revision'] = self.source_revision
        if self.target_config is not None:
            result['target_config'] = self.target_config.to_map()
        if self.target_revision is not None:
            result['target_revision'] = self.target_revision
        if self.summary is not None:
            result['summary'] = self.summary
        if self.diff_detail is not None:
            result['diff_detail'] = self.diff_detail
        if self.risk_level is not None:
            result['risk_level'] = self.risk_level
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('source_config') is not None:
            temp_model = ContainerServiceConfig()
            self.source_config = temp_model.from_map(m['source_config'])
        if m.get('source_revision') is not None:
            self.source_revision = m.get('source_revision')
        if m.get('target_config') is not None:
            temp_model = ContainerServiceConfig()
            self.target_config = temp_model.from_map(m['target_config'])
        if m.get('target_revision') is not None:
            self.target_revision = m.get('target_revision')
        if m.get('summary') is not None:
            self.summary = m.get('summary')
        if m.get('diff_detail') is not None:
            self.diff_detail = m.get('diff_detail')
        if m.get('risk_level') is not None:
            self.risk_level = m.get('risk_level')
        return self


class RollbackSidecaropsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        app_name: str = None,
        client_token: str = None,
        namespace: str = None,
        workspace_group: str = None,
        sidecar_config: SidecarConfig = None,
        sidecar_version: str = None,
        cell_name: str = None,
        server_identities: List[str] = None,
        order_num: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务名称
        self.app_name = app_name
        # 请求幂等
        self.client_token = client_token
        # 所属命名空间
        self.namespace = namespace
        # 所属工作空间
        self.workspace_group = workspace_group
        # sidecar相关配置，包含image，feature等
        self.sidecar_config = sidecar_config
        # 指定sidecar的基线模板版本进行回滚
        self.sidecar_version = sidecar_version
        # 部署单元
        self.cell_name = cell_name
        # 要更新的hostname列表
        # 
        self.server_identities = server_identities
        # 工单id
        self.order_num = order_num

    def validate(self):
        self.validate_required(self.app_name, 'app_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.sidecar_config, 'sidecar_config')
        if self.sidecar_config:
            self.sidecar_config.validate()
        self.validate_required(self.cell_name, 'cell_name')
        self.validate_required(self.server_identities, 'server_identities')
        self.validate_required(self.order_num, 'order_num')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.app_name is not None:
            result['app_name'] = self.app_name
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.sidecar_config is not None:
            result['sidecar_config'] = self.sidecar_config.to_map()
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.cell_name is not None:
            result['cell_name'] = self.cell_name
        if self.server_identities is not None:
            result['server_identities'] = self.server_identities
        if self.order_num is not None:
            result['order_num'] = self.order_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('app_name') is not None:
            self.app_name = m.get('app_name')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('sidecar_config') is not None:
            temp_model = SidecarConfig()
            self.sidecar_config = temp_model.from_map(m['sidecar_config'])
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('cell_name') is not None:
            self.cell_name = m.get('cell_name')
        if m.get('server_identities') is not None:
            self.server_identities = m.get('server_identities')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        return self


class RollbackSidecaropsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
        updated_pod_numbers: List[str] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 是否成功
        self.success = success
        # 返回被更新的podNumber list
        self.updated_pod_numbers = updated_pod_numbers

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        if self.updated_pod_numbers is not None:
            result['updated_pod_numbers'] = self.updated_pod_numbers
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        if m.get('updated_pod_numbers') is not None:
            self.updated_pod_numbers = m.get('updated_pod_numbers')
        return self


class ConfirmAppopsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        operation_id: str = None,
        operator: str = None,
        tenant_name: str = None,
        service_group_id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 运维单timeSeriesId
        self.operation_id = operation_id
        # 操作人账号
        self.operator = operator
        # 租户编码
        self.tenant_name = tenant_name
        # 服务分组id
        self.service_group_id = service_group_id

    def validate(self):
        self.validate_required(self.operation_id, 'operation_id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.operator is not None:
            result['operator'] = self.operator
        if self.tenant_name is not None:
            result['tenant_name'] = self.tenant_name
        if self.service_group_id is not None:
            result['service_group_id'] = self.service_group_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('tenant_name') is not None:
            self.tenant_name = m.get('tenant_name')
        if m.get('service_group_id') is not None:
            self.service_group_id = m.get('service_group_id')
        return self


class ConfirmAppopsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class AddContainerserviceLogpvRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        apps: List[str] = None,
        env: str = None,
        pvc_name: str = None,
        storage_class: str = None,
        storage_size: int = None,
        mount_path: str = None,
        disable_init_container: bool = None,
        log_init_container_name: str = None,
        disable_sidecar_pv: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # app名称
        self.apps = apps
        # 环境信息
        self.env = env
        # PVC 名称
        self.pvc_name = pvc_name
        # StorageClass
        self.storage_class = storage_class
        # 存储大小
        self.storage_size = storage_size
        # 挂载路径，默认/home/admin/logs
        self.mount_path = mount_path
        # addDefaultInitContainer, 默认值false
        self.disable_init_container = disable_init_container
        # Init Container名称
        self.log_init_container_name = log_init_container_name
        # 默认值添加Sidecar PV
        self.disable_sidecar_pv = disable_sidecar_pv

    def validate(self):
        self.validate_required(self.apps, 'apps')
        self.validate_required(self.env, 'env')
        self.validate_required(self.pvc_name, 'pvc_name')
        self.validate_required(self.storage_class, 'storage_class')
        self.validate_required(self.storage_size, 'storage_size')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.apps is not None:
            result['apps'] = self.apps
        if self.env is not None:
            result['env'] = self.env
        if self.pvc_name is not None:
            result['pvc_name'] = self.pvc_name
        if self.storage_class is not None:
            result['storage_class'] = self.storage_class
        if self.storage_size is not None:
            result['storage_size'] = self.storage_size
        if self.mount_path is not None:
            result['mount_path'] = self.mount_path
        if self.disable_init_container is not None:
            result['disable_init_container'] = self.disable_init_container
        if self.log_init_container_name is not None:
            result['log_init_container_name'] = self.log_init_container_name
        if self.disable_sidecar_pv is not None:
            result['disable_sidecar_pv'] = self.disable_sidecar_pv
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('apps') is not None:
            self.apps = m.get('apps')
        if m.get('env') is not None:
            self.env = m.get('env')
        if m.get('pvc_name') is not None:
            self.pvc_name = m.get('pvc_name')
        if m.get('storage_class') is not None:
            self.storage_class = m.get('storage_class')
        if m.get('storage_size') is not None:
            self.storage_size = m.get('storage_size')
        if m.get('mount_path') is not None:
            self.mount_path = m.get('mount_path')
        if m.get('disable_init_container') is not None:
            self.disable_init_container = m.get('disable_init_container')
        if m.get('log_init_container_name') is not None:
            self.log_init_container_name = m.get('log_init_container_name')
        if m.get('disable_sidecar_pv') is not None:
            self.disable_sidecar_pv = m.get('disable_sidecar_pv')
        return self


class AddContainerserviceLogpvResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        success: bool = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 是否成功
        self.success = success

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class ListFederationServiceRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group_name: str = None,
        namespace: str = None,
        container_service_name: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group_name = workspace_group_name
        # 命名空间
        self.namespace = namespace
        # 应用服务名称
        self.container_service_name = container_service_name

    def validate(self):
        self.validate_required(self.workspace_group_name, 'workspace_group_name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.container_service_name, 'container_service_name')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group_name is not None:
            result['workspace_group_name'] = self.workspace_group_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group_name') is not None:
            self.workspace_group_name = m.get('workspace_group_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        return self


class ListFederationServiceResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        list: List[FederatedService] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 列表
        self.list = list

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = FederatedService()
                self.list.append(temp_model.from_map(k))
        return self


class QueryOperationlogRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        page_no: int = None,
        page_size: int = None,
        entity_type: str = None,
        target_id: str = None,
        workspace_group: str = None,
        cluster_id: str = None,
        pod_name: str = None,
        namespace: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 页码。起始值：1。默认值：1。
        self.page_no = page_no
        # 分页查询时设置的每页行数。最大值：100，默认值：10。
        self.page_size = page_size
        # 实体类型。LDC_PLAN/LDC_SERVICE/POD_CONTAINER
        self.entity_type = entity_type
        # 目标id。发布单plan_id或者lks_service_id。
        self.target_id = target_id
        # 当前工作空间组名称
        self.workspace_group = workspace_group
        # 集群id，entity_type==POD_CONTAINER 时有用
        self.cluster_id = cluster_id
        # pod名称，entity_type==POD_CONTAINER 时有用
        self.pod_name = pod_name
        # 命名空间，entity_type==POD_CONTAINER 时必传
        self.namespace = namespace

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.page_no is not None:
            result['page_no'] = self.page_no
        if self.page_size is not None:
            result['page_size'] = self.page_size
        if self.entity_type is not None:
            result['entity_type'] = self.entity_type
        if self.target_id is not None:
            result['target_id'] = self.target_id
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.cluster_id is not None:
            result['cluster_id'] = self.cluster_id
        if self.pod_name is not None:
            result['pod_name'] = self.pod_name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('page_no') is not None:
            self.page_no = m.get('page_no')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        if m.get('entity_type') is not None:
            self.entity_type = m.get('entity_type')
        if m.get('target_id') is not None:
            self.target_id = m.get('target_id')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('cluster_id') is not None:
            self.cluster_id = m.get('cluster_id')
        if m.get('pod_name') is not None:
            self.pod_name = m.get('pod_name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        return self


class QueryOperationlogResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        total_count: int = None,
        page_no: int = None,
        page_size: int = None,
        list: List[OperationLog] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 总数。
        self.total_count = total_count
        # 页码
        self.page_no = page_no
        # 每页行数
        self.page_size = page_size
        # operationlog列表
        self.list = list

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.total_count is not None:
            result['total_count'] = self.total_count
        if self.page_no is not None:
            result['page_no'] = self.page_no
        if self.page_size is not None:
            result['page_size'] = self.page_size
        result['list'] = []
        if self.list is not None:
            for k in self.list:
                result['list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('total_count') is not None:
            self.total_count = m.get('total_count')
        if m.get('page_no') is not None:
            self.page_no = m.get('page_no')
        if m.get('page_size') is not None:
            self.page_size = m.get('page_size')
        self.list = []
        if m.get('list') is not None:
            for k in m.get('list'):
                temp_model = OperationLog()
                self.list.append(temp_model.from_map(k))
        return self


class GetEmergencyPlansRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        id: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 预案id
        self.id = id

    def validate(self):
        self.validate_required(self.id, 'id')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.id is not None:
            result['id'] = self.id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('id') is not None:
            self.id = m.get('id')
        return self


class GetEmergencyPlansResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        id: str = None,
        name: str = None,
        params: List[TemplateParam] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 预案id
        self.id = id
        # 预案名称
        self.name = name
        # 预案参数
        self.params = params

    def validate(self):
        if self.params:
            for k in self.params:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.id is not None:
            result['id'] = self.id
        if self.name is not None:
            result['name'] = self.name
        result['params'] = []
        if self.params is not None:
            for k in self.params:
                result['params'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('id') is not None:
            self.id = m.get('id')
        if m.get('name') is not None:
            self.name = m.get('name')
        self.params = []
        if m.get('params') is not None:
            for k in m.get('params'):
                temp_model = TemplateParam()
                self.params.append(temp_model.from_map(k))
        return self


class AddFedspannerclusterZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        name: str = None,
        zones: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 联邦统一接入集群名称
        self.name = name
        # 待添加的机房（可用区）列表
        self.zones = zones

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.name, 'name')
        self.validate_required(self.zones, 'zones')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.name is not None:
            result['name'] = self.name
        if self.zones is not None:
            result['zones'] = self.zones
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('zones') is not None:
            self.zones = m.get('zones')
        return self


class AddFedspannerclusterZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class AddUnifiedaccessinstanceZoneRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        name: str = None,
        zones: List[str] = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 统一接入实例名称
        self.name = name
        # 可用区（机房）列表
        self.zones = zones

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.name, 'name')
        self.validate_required(self.zones, 'zones')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.name is not None:
            result['name'] = self.name
        if self.zones is not None:
            result['zones'] = self.zones
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('zones') is not None:
            self.zones = m.get('zones')
        return self


class AddUnifiedaccessinstanceZoneResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class UpdateContainerserviceJsonpatchRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        client_token: str = None,
        name: str = None,
        namespace: str = None,
        workspace_group: str = None,
        revision: str = None,
        operator: str = None,
        json_patches: List[JsonPatch] = None,
        ops_type: str = None,
        ops_mode: str = None,
        deploy_config: DeployConfig = None,
        is_auto_execute: bool = None,
        graycore_batches: str = None,
        huanyu_exec_no: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 必填：保证请求幂等性。从您的客户端生成一个参数值，确保不同请求间该参数值唯一。ClientToken只支持ASCII字符，且不能超过64个字符。
        self.client_token = client_token
        # 应用服务名称
        self.name = name
        # 命名空间
        self.namespace = namespace
        # 工作空间组
        self.workspace_group = workspace_group
        # 应用服务版本，不传取最新的版本
        self.revision = revision
        # 操作人账号
        self.operator = operator
        # json patch 内容
        self.json_patches = json_patches
        # 配置为CLOUD_NATIVE_GROUP_RELEASE会自动创建发布单
        self.ops_type = ops_type
        # 发布单类型，SLS_CHANGE代表只做sls配置变更
        self.ops_mode = ops_mode
        # 部署策略
        self.deploy_config = deploy_config
        # 是否自动执行发布单，默认 true
        self.is_auto_execute = is_auto_execute
        # 灰度平台pods分批序列化为json的结果
        # 
        self.graycore_batches = graycore_batches
        # [huanyu场景使用]huanyu变更单id
        self.huanyu_exec_no = huanyu_exec_no

    def validate(self):
        self.validate_required(self.client_token, 'client_token')
        self.validate_required(self.name, 'name')
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.json_patches, 'json_patches')
        if self.json_patches:
            for k in self.json_patches:
                if k:
                    k.validate()
        if self.deploy_config:
            self.deploy_config.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.client_token is not None:
            result['client_token'] = self.client_token
        if self.name is not None:
            result['name'] = self.name
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.revision is not None:
            result['revision'] = self.revision
        if self.operator is not None:
            result['operator'] = self.operator
        result['json_patches'] = []
        if self.json_patches is not None:
            for k in self.json_patches:
                result['json_patches'].append(k.to_map() if k else None)
        if self.ops_type is not None:
            result['ops_type'] = self.ops_type
        if self.ops_mode is not None:
            result['ops_mode'] = self.ops_mode
        if self.deploy_config is not None:
            result['deploy_config'] = self.deploy_config.to_map()
        if self.is_auto_execute is not None:
            result['is_auto_execute'] = self.is_auto_execute
        if self.graycore_batches is not None:
            result['graycore_batches'] = self.graycore_batches
        if self.huanyu_exec_no is not None:
            result['huanyu_exec_no'] = self.huanyu_exec_no
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('client_token') is not None:
            self.client_token = m.get('client_token')
        if m.get('name') is not None:
            self.name = m.get('name')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        self.json_patches = []
        if m.get('json_patches') is not None:
            for k in m.get('json_patches'):
                temp_model = JsonPatch()
                self.json_patches.append(temp_model.from_map(k))
        if m.get('ops_type') is not None:
            self.ops_type = m.get('ops_type')
        if m.get('ops_mode') is not None:
            self.ops_mode = m.get('ops_mode')
        if m.get('deploy_config') is not None:
            temp_model = DeployConfig()
            self.deploy_config = temp_model.from_map(m['deploy_config'])
        if m.get('is_auto_execute') is not None:
            self.is_auto_execute = m.get('is_auto_execute')
        if m.get('graycore_batches') is not None:
            self.graycore_batches = m.get('graycore_batches')
        if m.get('huanyu_exec_no') is not None:
            self.huanyu_exec_no = m.get('huanyu_exec_no')
        return self


class UpdateContainerserviceJsonpatchResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        revision: str = None,
        operation_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 新的应用服务版本
        self.revision = revision
        # 部署单id
        self.operation_id = operation_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.revision is not None:
            result['revision'] = self.revision
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('revision') is not None:
            self.revision = m.get('revision')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        return self


class ListFlowCellgroupRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class ListFlowCellgroupResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        cellgroup_list: List[FlowCellGroup] = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 单元组查询列表
        self.cellgroup_list = cellgroup_list

    def validate(self):
        if self.cellgroup_list:
            for k in self.cellgroup_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        result['cellgroup_list'] = []
        if self.cellgroup_list is not None:
            for k in self.cellgroup_list:
                result['cellgroup_list'].append(k.to_map() if k else None)
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        self.cellgroup_list = []
        if m.get('cellgroup_list') is not None:
            for k in m.get('cellgroup_list'):
                temp_model = FlowCellGroup()
                self.cellgroup_list.append(temp_model.from_map(k))
        return self


class SyncFlowMetadataRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        return self


class SyncFlowMetadataResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CheckContainerserviceConflictopsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        namespace: str = None,
        container_service_name: str = None,
        workspace_group: str = None,
        check_sidercar: bool = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 命名空间
        self.namespace = namespace
        # 应用服务名称
        self.container_service_name = container_service_name
        # 工作空间组
        self.workspace_group = workspace_group
        # 是否检查Sidercar有运维工单，默认false
        self.check_sidercar = check_sidercar

    def validate(self):
        self.validate_required(self.namespace, 'namespace')
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.workspace_group, 'workspace_group')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.namespace is not None:
            result['namespace'] = self.namespace
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.check_sidercar is not None:
            result['check_sidercar'] = self.check_sidercar
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('namespace') is not None:
            self.namespace = m.get('namespace')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('check_sidercar') is not None:
            self.check_sidercar = m.get('check_sidercar')
        return self


class CheckContainerserviceConflictopsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
        result: bool = None,
        operation_id: str = None,
        sidercar_plan_id: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg
        # 结果
        self.result = result
        # 冲突的发布单id
        self.operation_id = operation_id
        # sidercar工单id
        self.sidercar_plan_id = sidercar_plan_id

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        if self.result is not None:
            result['result'] = self.result
        if self.operation_id is not None:
            result['operation_id'] = self.operation_id
        if self.sidercar_plan_id is not None:
            result['sidercar_plan_id'] = self.sidercar_plan_id
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        if m.get('result') is not None:
            self.result = m.get('result')
        if m.get('operation_id') is not None:
            self.operation_id = m.get('operation_id')
        if m.get('sidercar_plan_id') is not None:
            self.sidercar_plan_id = m.get('sidercar_plan_id')
        return self


class ExecFlowDisasterswitchRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        workspace_group: str = None,
        disaster_type: str = None,
        disaster_scope: str = None,
        remote: bool = None,
        targets: List[str] = None,
        operator: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 工作空间组
        self.workspace_group = workspace_group
        # 容灾切换类型，枚举型，CUTOFF（切流），RECOVER（恢复）
        self.disaster_type = disaster_type
        # 容灾切换范围，枚举型，GROUP（单元组）、ZONE（单元）、IDC（机房，暂不支持）
        self.disaster_scope = disaster_scope
        # 同城或者异地容灾，true代表异地容灾，false代表同城容灾
        self.remote = remote
        # 容灾切换对象列表
        self.targets = targets
        # 操作者，选填，应填登录名
        self.operator = operator

    def validate(self):
        self.validate_required(self.workspace_group, 'workspace_group')
        self.validate_required(self.disaster_type, 'disaster_type')
        self.validate_required(self.disaster_scope, 'disaster_scope')
        self.validate_required(self.remote, 'remote')
        self.validate_required(self.targets, 'targets')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.workspace_group is not None:
            result['workspace_group'] = self.workspace_group
        if self.disaster_type is not None:
            result['disaster_type'] = self.disaster_type
        if self.disaster_scope is not None:
            result['disaster_scope'] = self.disaster_scope
        if self.remote is not None:
            result['remote'] = self.remote
        if self.targets is not None:
            result['targets'] = self.targets
        if self.operator is not None:
            result['operator'] = self.operator
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('workspace_group') is not None:
            self.workspace_group = m.get('workspace_group')
        if m.get('disaster_type') is not None:
            self.disaster_type = m.get('disaster_type')
        if m.get('disaster_scope') is not None:
            self.disaster_scope = m.get('disaster_scope')
        if m.get('remote') is not None:
            self.remote = m.get('remote')
        if m.get('targets') is not None:
            self.targets = m.get('targets')
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        return self


class ExecFlowDisasterswitchResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


class CancelSidecaropsRequest(TeaModel):
    def __init__(
        self,
        auth_token: str = None,
        container_service_name: str = None,
        sidecar_name: str = None,
        sidecar_version: str = None,
        order_num: str = None,
    ):
        # OAuth模式下的授权token
        self.auth_token = auth_token
        # 应用服务名称
        self.container_service_name = container_service_name
        # mosn/odp
        self.sidecar_name = sidecar_name
        # 具体sidecar的版本，非必填
        self.sidecar_version = sidecar_version
        # 环宇 order number
        self.order_num = order_num

    def validate(self):
        self.validate_required(self.container_service_name, 'container_service_name')
        self.validate_required(self.sidecar_name, 'sidecar_name')
        self.validate_required(self.order_num, 'order_num')

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_token is not None:
            result['auth_token'] = self.auth_token
        if self.container_service_name is not None:
            result['container_service_name'] = self.container_service_name
        if self.sidecar_name is not None:
            result['sidecar_name'] = self.sidecar_name
        if self.sidecar_version is not None:
            result['sidecar_version'] = self.sidecar_version
        if self.order_num is not None:
            result['order_num'] = self.order_num
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('auth_token') is not None:
            self.auth_token = m.get('auth_token')
        if m.get('container_service_name') is not None:
            self.container_service_name = m.get('container_service_name')
        if m.get('sidecar_name') is not None:
            self.sidecar_name = m.get('sidecar_name')
        if m.get('sidecar_version') is not None:
            self.sidecar_version = m.get('sidecar_version')
        if m.get('order_num') is not None:
            self.order_num = m.get('order_num')
        return self


class CancelSidecaropsResponse(TeaModel):
    def __init__(
        self,
        req_msg_id: str = None,
        result_code: str = None,
        result_msg: str = None,
    ):
        # 请求唯一ID，用于链路跟踪和问题排查
        self.req_msg_id = req_msg_id
        # 结果码，一般OK表示调用成功
        self.result_code = result_code
        # 异常信息的文本描述
        self.result_msg = result_msg

    def validate(self):
        pass

    def to_map(self):
        _map = super().to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.req_msg_id is not None:
            result['req_msg_id'] = self.req_msg_id
        if self.result_code is not None:
            result['result_code'] = self.result_code
        if self.result_msg is not None:
            result['result_msg'] = self.result_msg
        return result

    def from_map(self, m: dict = None):
        m = m or dict()
        if m.get('req_msg_id') is not None:
            self.req_msg_id = m.get('req_msg_id')
        if m.get('result_code') is not None:
            self.result_code = m.get('result_code')
        if m.get('result_msg') is not None:
            self.result_msg = m.get('result_msg')
        return self


