import AntchainUtil;
import Util;
import RPCUtil;

type @endpoint = string
type @regionId = string
type @accessKeyId = string
type @accessKeySecret = string
type @protocol = string
type @userAgent = string
type @readTimeout = number
type @connectTimeout = number
type @httpProxy = string
type @httpsProxy = string
type @socks5Proxy = string
type @socks5NetWork = string
type @noProxy = string
type @maxIdleConns = number
type @securityToken = string
type @maxIdleTimeMillis = number
type @keepAliveDurationMillis = number
type @maxRequests = number
type @maxRequestsPerHost = number

/**
 * Model for initing client
 */
model Config {
  accessKeyId?: string(description='accesskey id',default=''),
  accessKeySecret?: string(description='accesskey secret',default=''),
  securityToken?: string(description='security token',default=''),
  protocol?: string(description='http protocol',example='http',default='http'),
  readTimeout?: number(description='read timeout',example='10',default=''),
  connectTimeout?: number(description='connect timeout',example='10',default=''),
  httpProxy?: string(description='http proxy',example='http://localhost',default=''),
  httpsProxy?: string(description='https proxy',example='https://localhost',default=''),
  endpoint?: string(description='endpoint',example='cs.aliyuncs.com',default=''),
  noProxy?: string(description='proxy white list',example='http://localhost',default=''),
  maxIdleConns?: number(description='max idle conns',example='3',default=''),
  userAgent?: string(description='user agent',example='Alibabacloud/1',default=''),
  socks5Proxy?: string(description='socks5 proxy',default=''),
  socks5NetWork?: string(description='socks5 network',example='TCP',default=''),
  maxIdleTimeMillis?: number(description='长链接最大空闲时长',default='60 * 1000L'),
  keepAliveDurationMillis?: number(description='长链接最大连接时长',default='5000'),
  maxRequests?: number(description='最大连接数（长链接最大总数）',default='100'),
  maxRequestsPerHost?: number(description='每个目标主机的最大连接数（分主机域名的长链接最大总数',default='100'),
}

/**
 * Init client with Config
 * @param config config contains the necessary information to create a client
 */
init(config: Config) {
  if (Util.isUnset(config)) {
    throw {
      code = 'ParameterMissing',
      message = '\'config\' can not be unset'
    };
  }

  @accessKeyId = config.accessKeyId;
  @accessKeySecret = config.accessKeySecret;
  @securityToken = config.securityToken;
  @endpoint = config.endpoint;
  @protocol = config.protocol;
  @userAgent = config.userAgent;
  @readTimeout = Util.defaultNumber(config.readTimeout, 20000);
  @connectTimeout = Util.defaultNumber(config.connectTimeout, 20000);
  @httpProxy = config.httpProxy;
  @httpsProxy = config.httpsProxy;
  @noProxy = config.noProxy;
  @socks5Proxy = config.socks5Proxy;
  @socks5NetWork = config.socks5NetWork;
  @maxIdleConns = Util.defaultNumber(config.maxIdleConns, 60000);
  @maxIdleTimeMillis = Util.defaultNumber(config.maxIdleTimeMillis, 5);
  @keepAliveDurationMillis = Util.defaultNumber(config.keepAliveDurationMillis, 5000);
  @maxRequests = Util.defaultNumber(config.maxRequests, 100);
  @maxRequestsPerHost = Util.defaultNumber(config.maxRequestsPerHost, 100);
}

/**
 * Encapsulate the request and invoke the network
 * @param action api name
 * @param protocol http or https
 * @param method e.g. GET
 * @param pathname pathname of every api
 * @param request which contains request params
 * @param runtime which controls some details of call api, such as retry times
 * @return the response
 */
api doRequest(version: string, action: string, protocol: string, method: string, pathname: string, request: object, headers: map[string]string, runtime: Util.RuntimeOptions): object {
  __request.protocol = Util.defaultString(@protocol, protocol);
  __request.method = method;
  __request.pathname = pathname;
  __request.query = {
    method = action,
    version = version,
    sign_type = 'HmacSHA1',
    req_time = AntchainUtil.getTimestamp(),
    req_msg_id = AntchainUtil.getNonce(),
    access_key = @accessKeyId,
    base_sdk_version = 'TeaSDK-2.0',
    sdk_version = '1.6.2',
    _prod_code = 'MYTC',
    _prod_channel = 'undefined'
  };

  if (!Util.empty(@securityToken)) {
    __request.query.security_token = @securityToken;
  }

  __request.headers = {
    host = Util.defaultString(@endpoint, 'openapi.antchain.antgroup.com'),
    user-agent = Util.getUserAgent(@userAgent),
    ...headers
  };

  var tmp = Util.anyifyMapValue(RPCUtil.query(request));
  __request.body = Util.toFormString(tmp);
  __request.headers.content-type = 'application/x-www-form-urlencoded';

  var signedParam = {
    ...__request.query,
    ...RPCUtil.query(request)
  };
  __request.query.sign = AntchainUtil.getSignature(signedParam, @accessKeySecret);
} returns {
  var raw = Util.readAsString(__response.body);
  var obj = Util.parseJSON(raw);
  var res = Util.assertAsMap(obj);
  var resp = Util.assertAsMap(res.response);

  if (AntchainUtil.hasError(raw, @accessKeySecret)) {
    throw {
      message = resp.result_msg,
      data = resp,
      code = resp.result_code
    };
  }
  return resp;
} runtime {
  timeouted = 'retry',
  readTimeout = Util.defaultNumber(runtime.readTimeout, @readTimeout),
  connectTimeout = Util.defaultNumber(runtime.connectTimeout, @connectTimeout),
  httpProxy = Util.defaultString(runtime.httpProxy, @httpProxy),
  httpsProxy = Util.defaultString(runtime.httpsProxy, @httpsProxy),
  noProxy = Util.defaultString(runtime.noProxy, @noProxy),
  maxIdleConns = Util.defaultNumber(runtime.maxIdleConns, @maxIdleConns),
  maxIdleTimeMillis = @maxIdleTimeMillis,
  keepAliveDuration = @keepAliveDurationMillis,
  maxRequests = @maxRequests,
  maxRequestsPerHost = @maxRequestsPerHost,
  retry = {
    retryable = runtime.autoretry,
    maxAttempts = Util.defaultNumber(runtime.maxAttempts, 3)
  },
  backoff = {
    policy = Util.defaultString(runtime.backoffPolicy, 'no'),
    period = Util.defaultNumber(runtime.backoffPeriod, 1)
  },
  ignoreSSL = runtime.ignoreSSL
}

// 上传者信息
model UploaderInfo {
  // 上传者证书hash
  certHash: string(name='cert_hash', example='1654570807000'),
  // 上传者身份证明
  uploader: string(name='uploader', example='123'),
  // 上传时间
  uploadTime: long(name='upload_time', example='1654570807000'),
  // 经度
  longitude?: string(name='longitude', example='123'),
  // 纬度
  latitude?: string(name='latitude', example='123'),
}

// 区块信息
model BlockInfo {
  // 块高度
  blockHeight: long(name='block_height', example='123'),
  // 成块时间戳
  timestamp: long(name='timestamp', example='1654570807000'),
  // 交易摘要
  txHash: string(name='tx_hash', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
}

// 环节项
model PhaseItem {
  // 标题
  title: string(name='title', example='123'),
  // 类型
  // TEXT: 文本，
  // IMAGE： 图片,
  // VIDEO:  视频,
  // LONGTEXT: 长文本,
  // MAP: 地图,
  // BANNER: 广告位,
  // PDF: pdf文件,
  // CERTIFICATE: 认证信息
  // NESTED： 嵌套类型
  // CUSTOMIZE： 自定义类型
  type: string(name='type', example='TEXT'),
  // 值
  value: string(name='value', example='1654570807000'),
  // 扩展信息
  extInfo: string(name='ext_info', example='{"hello": "666"}'),
}

// 用户扫码信息
model ScanUserInfo {
  // 用户昵称
  nick: string(name='nick', example='123'),
  // 用户ID
  userId: string(name='user_id', example='1654570807000'),
  // 经度
  longitude: string(name='longitude', example='123'),
  // 纬度
  latitude: string(name='latitude', example='123'),
  // 用户来源
  srcType: string(name='src_type', example='alipay'),
  // 扫码时间
  scanTime?: long(name='scan_time', example='1654570807000'),
}

// 码注册信息
model CodeRegisterInfo {
  // 溯源码，代表该账户的唯一资源标识
  code: string(maxLength=160, minLength=1, name='code', example='http://taobao.com/12345'),
  // 状态,客户自定义状态，用于过滤查询使用
  status?: string(maxLength=32, minLength=2, name='status', example='ACTIVE'),
  // 关联溯源码列表，可以通过接口查询关联溯源码绑定的信息
  relationCodes?: [ string ](name='relation_codes', example='http://taobao.com/12345'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度128
  bizLabels?: [ string ](name='biz_labels', example='1654570807000'),
  // 注册内容
  content?: string(name='content', example='{"cipher": "123456"} '),
  // 区块链上交易哈希
  txHash?: string(name='tx_hash', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
  // 注册溯源码记录唯一标识
  uniqueId?: string(name='unique_id', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
}

// 商品信息
model ProudctInfo {
  // 商品名称
  name: string(name='name', example='爆款鞋子'),
  // 商品图片链接列表
  proudctImages?: [ string ](name='proudct_images', example=''),
  // 商品描述
  productDesc?: string(name='product_desc', example='匠心铸造，大师杰作'),
}

// 溯源码关联信息
model CodeRelationInfo {
  // 溯源码，代表该账户的唯一资源标识
  code: string(name='code', example='http://taobao.com/12345'),
  // 状态,客户自定义状态，用于过滤查询使用，仅支持字母数字构成
  // 
  status?: string(name='status', example='ACTIVE'),
  // 关联内容
  content?: string(name='content', example='{"cipher": "123456"}'),
  // 区块链上交易哈希
  txHash?: string(name='tx_hash', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度128
  bizLabels?: [ string ](name='biz_labels', example='1654570807000'),
  // 溯源码信息关联记录唯一标识
  uniqueId?: string(name='unique_id', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
}

// 区块链交易信息
model BlockChainTransactionInfo {
  // 区块链上交易哈希
  txHash: string(name='tx_hash', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
  // 区块链标识
  bizId: string(name='biz_id', example='1654570807000'),
  // 消耗gas数量
  gasUsed: string(name='gas_used', example='123'),
  // 父区块哈希
  parentHash: string(name='parent_hash', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
  // 收据根
  receiptRoot: string(name='receipt_root', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
  // 状态树根
  stateRoot: string(name='state_root', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
  // 交易根
  transactionRoot: string(name='transaction_root', example='2ba028918edd6566fd0674dd33fc5e53b72c8e33439562e1598d1bdab341b0f1'),
  // 版本
  version: string(name='version', example='1'),
  // 区块高度
  number: long(name='number', example='165457'),
  // 成块时间
  timestamp: long(name='timestamp', example='1654570807000'),
}

// 首次扫描信息
model ScanHeadInfo {
  // 扫描时间
  scanTime: long(name='scan_time', example='1654570807000'),
  // 扫码次数
  scanCount: long(name='scan_count', example='123'),
  // 扫码地址
  scanAddr: string(name='scan_addr', example='1654570807000'),
}

// 环节信息
model PhaseInfo {
  // 环节名称
  name: string(name='name', example='商品信息'),
  // 环节项
  items: [ PhaseItem ](name='items', example=''),
  // 上传者信息
  uploadInfo: UploaderInfo(name='upload_info', example=''),
  // 区块信息
  blockInfo: BlockInfo(name='block_info', example=''),
}

// 键值对
model XNameValuePair {
  // 键名
  name: string(name='name', example='key'),
  // 键值
  value: string(name='value', example='value'),
}

model RecognizeAntiQrcodeacRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 上传图片使用的设备类型,用于更精准的识别,非必填。
  deviceType?: string(name='device_type'),
  // Base64格式的图片数据
  imageStr?: string(name='image_str'),
  // 图片文件id，通过小程序拍照，上传的二维码图片信息。
  fileObject?: readable(description='待上传文件', ignore='true'),
  fileObjectName?: string(description='待上传文件名', ignore='true'),
  fileId?: string(name='file_id'),
}

model RecognizeAntiQrcodeacResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 解码结果,0:失败,1:成功，如果解码成功，可忽略detectState字段返回结果
  code?: string(name='code'),
  // 识别状态
  detectState?: string(name='detect_state'),
  // 识别状态描述
  detectDesc?: string(name='detect_desc'),
  // 加密数据
  encryptData?: string(name='encrypt_data'),
}

/**
 * Description: 主要用于二维码防伪识别，内部集成安创的二维码验真能力。
 * Summary: 二维码防伪识别
 */
async function recognizeAntiQrcodeac(request: RecognizeAntiQrcodeacRequest): RecognizeAntiQrcodeacResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return recognizeAntiQrcodeacEx(request, headers, runtime);
}

/**
 * Description: 主要用于二维码防伪识别，内部集成安创的二维码验真能力。
 * Summary: 二维码防伪识别
 */
async function recognizeAntiQrcodeacEx(request: RecognizeAntiQrcodeacRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecognizeAntiQrcodeacResponse {
  if (!Util.isUnset(request.fileObject)) {
    var uploadReq = new CreateAntcloudGatewayxFileUploadRequest{
      authToken = request.authToken,
      apiCode = 'antchain.mytc.anti.qrcodeac.recognize',
      fileName = request.fileObjectName,
    };
    var uploadResp = createAntcloudGatewayxFileUploadEx(uploadReq, headers, runtime);
    if (!AntchainUtil.isSuccess(uploadResp.resultCode, "ok")) {
      var recognizeAntiQrcodeacResponse = new RecognizeAntiQrcodeacResponse{
        reqMsgId = uploadResp.reqMsgId,
        resultCode = uploadResp.resultCode,
        resultMsg = uploadResp.resultMsg,
      };
      return recognizeAntiQrcodeacResponse;
    }
    var uploadHeaders = AntchainUtil.parseUploadHeaders(uploadResp.uploadHeaders);
    AntchainUtil.putObject(request.fileObject, uploadHeaders, uploadResp.uploadUrl);
    request.fileId = uploadResp.fileId;
  }
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.anti.qrcodeac.recognize', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model CheckCodeFakeRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 设备型号
  deviceType?: string(name='device_type'),
  // 图片文件id，通过小程序拍照，上传的二维码图片信息。	
  fileObject?: readable(description='待上传文件', ignore='true'),
  fileObjectName?: string(description='待上传文件名', ignore='true'),
  fileId: string(name='file_id'),
}

model CheckCodeFakeResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 验真是否成功
  detectSuccess?: boolean(name='detect_success'),
  // 返回编码
  detectCode?: string(name='detect_code'),
  // 调用返回信息
  detectMessage?: string(name='detect_message'),
}

/**
 * Description: 二维码防伪图片验证
 * Summary: 二维码防伪图片验证
 */
async function checkCodeFake(request: CheckCodeFakeRequest): CheckCodeFakeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return checkCodeFakeEx(request, headers, runtime);
}

/**
 * Description: 二维码防伪图片验证
 * Summary: 二维码防伪图片验证
 */
async function checkCodeFakeEx(request: CheckCodeFakeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckCodeFakeResponse {
  if (!Util.isUnset(request.fileObject)) {
    var uploadReq = new CreateAntcloudGatewayxFileUploadRequest{
      authToken = request.authToken,
      apiCode = 'antchain.mytc.code.fake.check',
      fileName = request.fileObjectName,
    };
    var uploadResp = createAntcloudGatewayxFileUploadEx(uploadReq, headers, runtime);
    if (!AntchainUtil.isSuccess(uploadResp.resultCode, "ok")) {
      var checkCodeFakeResponse = new CheckCodeFakeResponse{
        reqMsgId = uploadResp.reqMsgId,
        resultCode = uploadResp.resultCode,
        resultMsg = uploadResp.resultMsg,
      };
      return checkCodeFakeResponse;
    }
    var uploadHeaders = AntchainUtil.parseUploadHeaders(uploadResp.uploadHeaders);
    AntchainUtil.putObject(request.fileObject, uploadHeaders, uploadResp.uploadUrl);
    request.fileId = uploadResp.fileId;
  }
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.fake.check', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model CheckCodeFakescreenRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 设备型号	
  deviceType?: string(name='device_type'),
  // 闪光前或闪光后的图片
  fileObject?: readable(description='待上传文件', ignore='true'),
  fileObjectName?: string(description='待上传文件名', ignore='true'),
  fileId: string(name='file_id'),
  // 配对标识，闪光前后需要用同一个配对标识。
  pairId: string(name='pair_id'),
  // 文件类型.
  // unflashed: 未闪光图片
  // flashed: 闪光后图片
  fileType: string(name='file_type'),
}

model CheckCodeFakescreenResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 验真是否成功	
  detectSuccess?: boolean(name='detect_success'),
  // 返回编码	
  detectCode?: string(name='detect_code'),
  // 调用返回信息	
  detectMessage?: string(name='detect_message'),
}

/**
 * Description: 二维码防伪防屏拍图片验证
 * Summary: 二维码防伪防屏拍图片验证
 */
async function checkCodeFakescreen(request: CheckCodeFakescreenRequest): CheckCodeFakescreenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return checkCodeFakescreenEx(request, headers, runtime);
}

/**
 * Description: 二维码防伪防屏拍图片验证
 * Summary: 二维码防伪防屏拍图片验证
 */
async function checkCodeFakescreenEx(request: CheckCodeFakescreenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckCodeFakescreenResponse {
  if (!Util.isUnset(request.fileObject)) {
    var uploadReq = new CreateAntcloudGatewayxFileUploadRequest{
      authToken = request.authToken,
      apiCode = 'antchain.mytc.code.fakescreen.check',
      fileName = request.fileObjectName,
    };
    var uploadResp = createAntcloudGatewayxFileUploadEx(uploadReq, headers, runtime);
    if (!AntchainUtil.isSuccess(uploadResp.resultCode, "ok")) {
      var checkCodeFakescreenResponse = new CheckCodeFakescreenResponse{
        reqMsgId = uploadResp.reqMsgId,
        resultCode = uploadResp.resultCode,
        resultMsg = uploadResp.resultMsg,
      };
      return checkCodeFakescreenResponse;
    }
    var uploadHeaders = AntchainUtil.parseUploadHeaders(uploadResp.uploadHeaders);
    AntchainUtil.putObject(request.fileObject, uploadHeaders, uploadResp.uploadUrl);
    request.fileId = uploadResp.fileId;
  }
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.fakescreen.check', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model UploadAntiFileRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 文件上传
  fileObject?: readable(description='待上传文件', ignore='true'),
  fileObjectName?: string(description='待上传文件名', ignore='true'),
  fileId: string(name='file_id'),
}

model UploadAntiFileResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 上传文件公网可访问路径
  url?: string(name='url'),
}

/**
 * Description: 防伪文件上传API
 * Summary: 防伪文件上传API
 */
async function uploadAntiFile(request: UploadAntiFileRequest): UploadAntiFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return uploadAntiFileEx(request, headers, runtime);
}

/**
 * Description: 防伪文件上传API
 * Summary: 防伪文件上传API
 */
async function uploadAntiFileEx(request: UploadAntiFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UploadAntiFileResponse {
  if (!Util.isUnset(request.fileObject)) {
    var uploadReq = new CreateAntcloudGatewayxFileUploadRequest{
      authToken = request.authToken,
      apiCode = 'antchain.mytc.anti.file.upload',
      fileName = request.fileObjectName,
    };
    var uploadResp = createAntcloudGatewayxFileUploadEx(uploadReq, headers, runtime);
    if (!AntchainUtil.isSuccess(uploadResp.resultCode, "ok")) {
      var uploadAntiFileResponse = new UploadAntiFileResponse{
        reqMsgId = uploadResp.reqMsgId,
        resultCode = uploadResp.resultCode,
        resultMsg = uploadResp.resultMsg,
      };
      return uploadAntiFileResponse;
    }
    var uploadHeaders = AntchainUtil.parseUploadHeaders(uploadResp.uploadHeaders);
    AntchainUtil.putObject(request.fileObject, uploadHeaders, uploadResp.uploadUrl);
    request.fileId = uploadResp.fileId;
  }
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.anti.file.upload', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model JudgeCodeFakescreenRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 设备型号
  deviceType?: string(name='device_type'),
  // 未闪光图片的fileId
  unflashedFileId: string(name='unflashed_file_id'),
  // 闪光后图片fileId
  flashedFileId: string(name='flashed_file_id'),
  // 上传文件类型，默认为id。
  // id标识通过网关上传，参数为网关的fileId。
  // url标识上传的为图片可访问链接。
  fileType?: string(name='file_type'),
}

model JudgeCodeFakescreenResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 验真是否成功
  detectSuccess?: boolean(name='detect_success'),
  // 返回编码
  detectCode?: string(name='detect_code'),
  // 调用返回信息
  detectMessage?: string(name='detect_message'),
}

/**
 * Description: 开放产品管理中心
 * Summary: 二维码防伪防屏拍图片验证，非文件上传
 */
async function judgeCodeFakescreen(request: JudgeCodeFakescreenRequest): JudgeCodeFakescreenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return judgeCodeFakescreenEx(request, headers, runtime);
}

/**
 * Description: 开放产品管理中心
 * Summary: 二维码防伪防屏拍图片验证，非文件上传
 */
async function judgeCodeFakescreenEx(request: JudgeCodeFakescreenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): JudgeCodeFakescreenResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.fakescreen.judge', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model InitAntiImagesyncRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 防伪码类型标识,由蚂蚁侧分配
  codeType?: string(name='code_type'),
  // 防伪码批次号
  batchNo: string(name='batch_no'),
  // 批次下要上传的防伪码总数
  total: long(name='total'),
}

model InitAntiImagesyncResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 批次号
  batchNo?: string(name='batch_no'),
  // 批次下的访问码总数
  total?: string(name='total'),
}

/**
 * Description: 防伪码平台防伪底图上传，初始化上传记录
 * Summary: 防伪码平台防伪底图上传初始化
 */
async function initAntiImagesync(request: InitAntiImagesyncRequest): InitAntiImagesyncResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return initAntiImagesyncEx(request, headers, runtime);
}

/**
 * Description: 防伪码平台防伪底图上传，初始化上传记录
 * Summary: 防伪码平台防伪底图上传初始化
 */
async function initAntiImagesyncEx(request: InitAntiImagesyncRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitAntiImagesyncResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.anti.imagesync.init', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model UploadAntiImagesyncRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 防伪码码值
  code: string(name='code'),
  // 文件id
  fileObject?: readable(description='待上传文件', ignore='true'),
  fileObjectName?: string(description='待上传文件名', ignore='true'),
  fileId: string(name='file_id'),
  // 防伪码批次号，若不填写，则会获取当天最新批次号。若批次不存在，则创建一个新的批次。
  batchNo?: string(name='batch_no'),
}

model UploadAntiImagesyncResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 防伪码码值
  code?: string(name='code'),
  // 批次号
  batchNo?: string(name='batch_no'),
  // 该批次号，已上传底图次数
  count?: long(name='count'),
}

/**
 * Description: 防伪码图片上传
 * Summary: 防伪码平台防伪码图片上传
 */
async function uploadAntiImagesync(request: UploadAntiImagesyncRequest): UploadAntiImagesyncResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return uploadAntiImagesyncEx(request, headers, runtime);
}

/**
 * Description: 防伪码图片上传
 * Summary: 防伪码平台防伪码图片上传
 */
async function uploadAntiImagesyncEx(request: UploadAntiImagesyncRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UploadAntiImagesyncResponse {
  if (!Util.isUnset(request.fileObject)) {
    var uploadReq = new CreateAntcloudGatewayxFileUploadRequest{
      authToken = request.authToken,
      apiCode = 'antchain.mytc.anti.imagesync.upload',
      fileName = request.fileObjectName,
    };
    var uploadResp = createAntcloudGatewayxFileUploadEx(uploadReq, headers, runtime);
    if (!AntchainUtil.isSuccess(uploadResp.resultCode, "ok")) {
      var uploadAntiImagesyncResponse = new UploadAntiImagesyncResponse{
        reqMsgId = uploadResp.reqMsgId,
        resultCode = uploadResp.resultCode,
        resultMsg = uploadResp.resultMsg,
      };
      return uploadAntiImagesyncResponse;
    }
    var uploadHeaders = AntchainUtil.parseUploadHeaders(uploadResp.uploadHeaders);
    AntchainUtil.putObject(request.fileObject, uploadHeaders, uploadResp.uploadUrl);
    request.fileId = uploadResp.fileId;
  }
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.anti.imagesync.upload', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model FinishAntiImagesyncRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 批次号
  batchNo: string(name='batch_no'),
}

model FinishAntiImagesyncResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 批次号
  batchNo?: string(name='batch_no'),
  // 该批次号，已上传底图次数
  // 
  count?: long(name='count'),
}

/**
 * Description: 防伪码平台防伪底图上传完成
 * Summary: 防伪码平台防伪底图上传完成
 */
async function finishAntiImagesync(request: FinishAntiImagesyncRequest): FinishAntiImagesyncResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return finishAntiImagesyncEx(request, headers, runtime);
}

/**
 * Description: 防伪码平台防伪底图上传完成
 * Summary: 防伪码平台防伪底图上传完成
 */
async function finishAntiImagesyncEx(request: FinishAntiImagesyncRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FinishAntiImagesyncResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.anti.imagesync.finish', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model CreateAntiQrcodeimageRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 要生成图片二维码的字符串信息
  qrCode: string(name='qr_code'),
}

model CreateAntiQrcodeimageResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 生成的二维码图片的oss地址
  qrcodeUrl?: string(name='qrcode_url'),
  // 生成结果码，用于异常场景下细化错误信息
  generateCode?: string(name='generate_code'),
  // 生成结果码含义,用于异常场景下细化错误信息
  generateMessage?: string(name='generate_message'),
  // 生成失败时的解决方案,用于异常场景下细化错误信息
  unableGenerateSolution?: string(name='unable_generate_solution'),
}

/**
 * Description: 自研二维码生成
 * Summary: 二维码防伪图片生成
 */
async function createAntiQrcodeimage(request: CreateAntiQrcodeimageRequest): CreateAntiQrcodeimageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return createAntiQrcodeimageEx(request, headers, runtime);
}

/**
 * Description: 自研二维码生成
 * Summary: 二维码防伪图片生成
 */
async function createAntiQrcodeimageEx(request: CreateAntiQrcodeimageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAntiQrcodeimageResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.anti.qrcodeimage.create', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model CreateCodeRegistrationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  code: string(maxLength=160, minLength=1, name='code'),
  // 状态,客户自定义状态，用于过滤查询使用。只能由字符+数字构成
  status: string(maxLength=32, minLength=1, name='status'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
  // 注册内容
  content?: string(name='content'),
  // 关联溯源码列表。最多200条关联码，关联码格式要求和溯源码要求一致。
  // 可以通过接口查询关联溯源码绑定的信息。
  relationCodes?: [ string ](name='relation_codes'),
  // 关联溯源码递归检查，检查最多5层。默认NO_CHECK。枚举值如下，
  // NO_CHECK:  不做递归检查;
  // TREE_CHECK: 树结构检查;
  // DAG_CHECK: 有向无环图检查;
  recursionType?: string(maxLength=32, minLength=1, name='recursion_type'),
  // 是否上链，默认true。
  // 为false时，仅做DB数据保存不上链。
  // 若content数据大小超过要求限制，仅会保存content的hash值上链
  upChainFlag?: boolean(name='up_chain_flag'),
}

model CreateCodeRegistrationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 区块链上交易哈希
  txHash?: string(name='tx_hash'),
  // 注册记录唯一标识
  uniqueId?: string(name='unique_id'),
}

/**
 * Description: 溯源码注册, 会根据bizType+code确定唯一一条记录信息。
主要用于绑定关联码(relationCodes)、自定义维度(bizLables)等码全局信息，在没有码全局信息的情况下，可以不注册。
 * Summary: 溯源码注册
 */
async function createCodeRegistration(request: CreateCodeRegistrationRequest): CreateCodeRegistrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return createCodeRegistrationEx(request, headers, runtime);
}

/**
 * Description: 溯源码注册, 会根据bizType+code确定唯一一条记录信息。
主要用于绑定关联码(relationCodes)、自定义维度(bizLables)等码全局信息，在没有码全局信息的情况下，可以不注册。
 * Summary: 溯源码注册
 */
async function createCodeRegistrationEx(request: CreateCodeRegistrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCodeRegistrationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.registration.create', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model DeleteCodeRegistrationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  code: string(maxLength=160, minLength=1, name='code'),
  // 注册记录唯一标识
  uniqueId: string(maxLength=64, minLength=1, name='unique_id'),
}

model DeleteCodeRegistrationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 若溯源码注册的最新记录未上链，则可以被删除。若删除后，通过antchain.mytc.code.combine.query接口不能查询到相关码注册记录
 * Summary: 溯源码注册记录删除
 */
async function deleteCodeRegistration(request: DeleteCodeRegistrationRequest): DeleteCodeRegistrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return deleteCodeRegistrationEx(request, headers, runtime);
}

/**
 * Description: 若溯源码注册的最新记录未上链，则可以被删除。若删除后，通过antchain.mytc.code.combine.query接口不能查询到相关码注册记录
 * Summary: 溯源码注册记录删除
 */
async function deleteCodeRegistrationEx(request: DeleteCodeRegistrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCodeRegistrationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.registration.delete', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model CreateCodeRelationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  code: string(maxLength=160, minLength=1, name='code'),
  // 状态,客户自定义状态，用于过滤查询使用。只能由字符+数字构成
  status: string(maxLength=32, minLength=1, name='status'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
  // 是否上链，默认true。 为false时，仅做DB数据保存不上链。 
  // 若content数据大小超过要求限制，仅会保存content的hash值上链
  upChainFlag?: boolean(name='up_chain_flag'),
  // 关联内容
  // 
  content?: string(name='content'),
}

model CreateCodeRelationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 区块链上交易哈希
  txHash?: string(name='tx_hash'),
  // 绑定信息记录唯一标识
  uniqueId?: string(name='unique_id'),
}

/**
 * Description: 将关联信息绑定到溯源码上。
该接口调用存在以下业务维度限制：
1. code + bizLables + bizType做唯一性判断。


 * Summary: 溯源码关联信息
 */
async function createCodeRelation(request: CreateCodeRelationRequest): CreateCodeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return createCodeRelationEx(request, headers, runtime);
}

/**
 * Description: 将关联信息绑定到溯源码上。
该接口调用存在以下业务维度限制：
1. code + bizLables + bizType做唯一性判断。


 * Summary: 溯源码关联信息
 */
async function createCodeRelationEx(request: CreateCodeRelationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCodeRelationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.relation.create', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model DeleteCodeRelationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  code?: string(maxLength=160, minLength=1, name='code'),
  // 关联信息记录唯一标识
  // 
  uniqueId: string(maxLength=64, minLength=1, name='unique_id'),
}

model DeleteCodeRelationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 仅未上链的码关联信息可以被删除。仅删除code,bizType,bizSub1,bizSub2,bizSub3全部匹配的未上链的关联信息。
若删除后，通过antchain.mytc.code.combine.query接口不能查询到该码关联记录。
 * Summary: 溯源码关联信息删除
 */
async function deleteCodeRelation(request: DeleteCodeRelationRequest): DeleteCodeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return deleteCodeRelationEx(request, headers, runtime);
}

/**
 * Description: 仅未上链的码关联信息可以被删除。仅删除code,bizType,bizSub1,bizSub2,bizSub3全部匹配的未上链的关联信息。
若删除后，通过antchain.mytc.code.combine.query接口不能查询到该码关联记录。
 * Summary: 溯源码关联信息删除
 */
async function deleteCodeRelationEx(request: DeleteCodeRelationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCodeRelationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.relation.delete', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryCodeCombineRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  code: string(maxLength=160, minLength=1, name='code'),
  // 页码,当且仅当pageNum=1时返回溯源码最新注册信息
  pageNum: long(minimum=1, name='page_num'),
  // 页大小
  pageSize: long(maximum=200, name='page_size'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
  // 状态,客户自定义状态，用于过滤查询使用，只能由字符+数字构成，多个可以用"|"分隔
  status?: string(maxLength=256, minLength=1, name='status'),
  // 是否递归查询，默认false, 最多递归5层
  // 
  recursionFlag?: boolean(name='recursion_flag'),
}

model QueryCodeCombineResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 总数据量
  total?: long(name='total'),
  // 注册码信息
  registerInfo?: CodeRegisterInfo(name='register_info'),
  // 关联信息
  relationInfos?: [ CodeRelationInfo ](name='relation_infos'),
}

/**
 * Description: 查询当前账户下的溯源码信息。
会查询最新的溯源码注册信息，以及各个业务维度的最新关联信息列表。

 * Summary: 溯源码查询
 */
async function queryCodeCombine(request: QueryCodeCombineRequest): QueryCodeCombineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryCodeCombineEx(request, headers, runtime);
}

/**
 * Description: 查询当前账户下的溯源码信息。
会查询最新的溯源码注册信息，以及各个业务维度的最新关联信息列表。

 * Summary: 溯源码查询
 */
async function queryCodeCombineEx(request: QueryCodeCombineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryCodeCombineResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.combine.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryCodeRegistrationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  // 
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  code: string(maxLength=160, minLength=1, name='code'),
  // 页码
  pageNum: long(minimum=1, name='page_num'),
  // 页大小
  pageSize: long(maximum=200, name='page_size'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
  // 注册记录唯一标识
  uniqueId?: string(maxLength=64, minLength=1, name='unique_id'),
  // 状态,客户自定义状态，用于过滤查询使用。
  // 状态信息只能由字母+数字构成，多个状态可以用"|"分隔
  status?: string(maxLength=256, minLength=1, name='status'),
  // 仅能取如下值范围：
  // 1. ASC     按注册时间升序
  // 2. DESC   按注册时间降序
  // 默认降序
  sortType?: string(name='sort_type'),
}

model QueryCodeRegistrationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 总数据量
  total?: long(name='total'),
  // 溯源码历史注册信息
  data?: [ CodeRegisterInfo ](name='data'),
}

/**
 * Description: 溯源码注册历史查询
 * Summary: 溯源码注册历史查询
 */
async function queryCodeRegistration(request: QueryCodeRegistrationRequest): QueryCodeRegistrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryCodeRegistrationEx(request, headers, runtime);
}

/**
 * Description: 溯源码注册历史查询
 * Summary: 溯源码注册历史查询
 */
async function queryCodeRegistrationEx(request: QueryCodeRegistrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryCodeRegistrationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.registration.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryCodeRelationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  code: string(maxLength=160, minLength=1, name='code'),
  // 页码
  pageNum: long(minimum=1, name='page_num'),
  // 页大小
  pageSize: long(maximum=200, name='page_size'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
  // 绑定信息记录唯一标识
  uniqueId?: string(maxLength=64, minLength=1, name='unique_id'),
  // 状态,客户自定义状态，用于过滤查询使用，只能由字符+数字构成，多个可以用"|"分隔
  status?: string(maxLength=256, minLength=1, name='status'),
  // 仅能取如下值范围： 1. ASC 按注册时间升序 2. DESC 按注册时间降序 默认降序
  sortType?: string(name='sort_type'),
}

model QueryCodeRelationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 总历史记录条数
  total?: long(name='total'),
  // 溯源码关联信息列表
  data?: [ CodeRelationInfo ](name='data'),
}

/**
 * Description: 溯源码关联历史信息查询
 * Summary: 溯源码关联历史信息查询
 */
async function queryCodeRelation(request: QueryCodeRelationRequest): QueryCodeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryCodeRelationEx(request, headers, runtime);
}

/**
 * Description: 溯源码关联历史信息查询
 * Summary: 溯源码关联历史信息查询
 */
async function queryCodeRelationEx(request: QueryCodeRelationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryCodeRelationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.relation.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model AddCodeDepositRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 存证内容
  // 
  content: string(name='content'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
}

model AddCodeDepositResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 区块链上交易哈希
  txHash?: string(name='tx_hash'),
  // 注册记录唯一标识
  uniqueId?: string(name='unique_id'),
}

/**
 * Description: 1. 原生存证，交易内容上链存证，返回链上唯一交易哈希。
2. 存证内容超过链上限制仅会将存证内容hash值上链。
 * Summary: 原生存证
 */
async function addCodeDeposit(request: AddCodeDepositRequest): AddCodeDepositResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return addCodeDepositEx(request, headers, runtime);
}

/**
 * Description: 1. 原生存证，交易内容上链存证，返回链上唯一交易哈希。
2. 存证内容超过链上限制仅会将存证内容hash值上链。
 * Summary: 原生存证
 */
async function addCodeDepositEx(request: AddCodeDepositRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddCodeDepositResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.deposit.add', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryCodeCertRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 区块链上交易哈希
  txHash: string(maxLength=64, minLength=1, name='tx_hash'),
  // 是否展示交易具体内容，默认false
  contentFlag?: boolean(name='content_flag'),
}

model QueryCodeCertResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 存证内容。
  // 在注册溯源码、溯源码关联信息等接口调用情况下，上链内容会包装加密后上链。
  // 因此返回内容不可读，需要按照指定要求解密读取。
  content?: string(name='content'),
  // 链交易信息
  chainTransactionInfo?: BlockChainTransactionInfo(name='chain_transaction_info'),
}

/**
 * Description: 链上交易详情查询
 * Summary: 链上交易证书查询
 */
async function queryCodeCert(request: QueryCodeCertRequest): QueryCodeCertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryCodeCertEx(request, headers, runtime);
}

/**
 * Description: 链上交易详情查询
 * Summary: 链上交易证书查询
 */
async function queryCodeCertEx(request: QueryCodeCertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryCodeCertResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.cert.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryCodeStatRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签
  // 
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 开始时间
  startTime?: long(name='start_time'),
  // 截止时间
  endTime?: long(name='end_time'),
  // 支持以下查询维度：
  // REGISTRATION  注册码统计
  // RELATION  关联码信息统计
  // DEPOSIT    存证信息统计
  codeType?: string(maxLength=32, minLength=1, name='code_type'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
}

model QueryCodeStatResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 上链交易量
  transactionSize?: long(name='transaction_size'),
  // 上链总数据存储容量占用
  chainCapacity?: long(name='chain_capacity'),
  // 记录条数，包括上链和未上链的总数据条数
  recordSize?: long(name='record_size'),
  // 对重复操作仅做一次记录的数据统计量。eg: 实际溯源码注册量，实际绑定信息的数据量。
  validSize?: long(name='valid_size'),
}

/**
 * Description: 溯源统计信息查询，不填写starTime和endTime会查询全量注册信息。 
若填写starTime和endTime，统计时间范围不能超过7天。
 * Summary: 溯源统计信息查询
 */
async function queryCodeStat(request: QueryCodeStatRequest): QueryCodeStatResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryCodeStatEx(request, headers, runtime);
}

/**
 * Description: 溯源统计信息查询，不填写starTime和endTime会查询全量注册信息。 
若填写starTime和endTime，统计时间范围不能超过7天。
 * Summary: 溯源统计信息查询
 */
async function queryCodeStatEx(request: QueryCodeStatRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryCodeStatResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.stat.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model AddCodeRegistrationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  code: string(maxLength=160, minLength=1, name='code'),
  // 状态,客户自定义状态，用于过滤查询使用。只能由字符+数字构成
  // 
  status: string(maxLength=32, minLength=1, name='status'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
  // 注册内容
  // 
  content?: string(name='content'),
  // 关联溯源码列表。最多200条关联码，关联码格式要求和溯源码要求一致。 可以通过接口查询关联溯源码绑定的信息。
  relationCodes?: [ string ](name='relation_codes'),
  // 关联溯源码递归检查，检查最多5层。默认NO_CHECK。枚举值如下，
  // NO_CHECK: 不做递归检查;
  // TREE_CHECK: 树结构检查; 
  // DAG_CHECK: 有向无环图检查;
  recursionType?: string(maxLength=32, minLength=1, name='recursion_type'),
  // 是否上链，默认true。 为false时，仅做DB数据保存不上链。 若content数据大小超过要求限制，仅会保存content的hash值上链
  upChainFlag?: boolean(name='up_chain_flag'),
}

model AddCodeRegistrationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 区块链上交易哈希
  txHash?: string(name='tx_hash'),
  // 注册记录唯一标识
  uniqueId?: string(name='unique_id'),
}

/**
 * Description: 溯源码注册，可重复注册。 主要用于绑定关联码(relationCodes)、自定义维度(bizLables)等码全局信息，在没有码全局信息的情况下，可以不注册。
 * Summary: 溯源码(可重复)注册
 */
async function addCodeRegistration(request: AddCodeRegistrationRequest): AddCodeRegistrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return addCodeRegistrationEx(request, headers, runtime);
}

/**
 * Description: 溯源码注册，可重复注册。 主要用于绑定关联码(relationCodes)、自定义维度(bizLables)等码全局信息，在没有码全局信息的情况下，可以不注册。
 * Summary: 溯源码(可重复)注册
 */
async function addCodeRegistrationEx(request: AddCodeRegistrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddCodeRegistrationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.registration.add', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model UpdateCodeRegistrationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识。该字段不更新，仅做过滤使用。
  code?: string(maxLength=160, minLength=1, name='code'),
  // 注册记录唯一标识
  uniqueId: string(maxLength=64, minLength=1, name='unique_id'),
  // 状态,客户自定义状态，用于过滤查询使用。只能由字符+数字构成
  status?: string(maxLength=32, minLength=1, name='status'),
  // 注册内容。若已上链，则不可更新该信息。
  // 
  content?: string(name='content'),
  // 关联溯源码列表。最多200条关联码，关联码格式要求和溯源码要求一致。 可以通过接口查询关联溯源码绑定的信息。若已上链，则不可更新该信息。
  relationCodes?: [ string ](name='relation_codes'),
  // 关联溯源码递归检查，检查最多5层。默认NO_CHECK。枚举值如下， 
  // NO_CHECK: 不做递归检查; 
  // TREE_CHECK: 树结构检查;
  // DAG_CHECK: 有向无环图检查;
  recursionType?: string(maxLength=32, minLength=1, name='recursion_type'),
  // 是否上链，默认true。 为false时，仅做DB数据保存不上链。 若content数据大小超过要求限制，仅会保存content的hash值上链
  upChainFlag?: boolean(name='up_chain_flag'),
}

model UpdateCodeRegistrationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 区块链上交易哈希
  txHash?: string(name='tx_hash'),
}

/**
 * Description: 更新已注册的溯源信息
 * Summary: 溯源注册信息更新
 */
async function updateCodeRegistration(request: UpdateCodeRegistrationRequest): UpdateCodeRegistrationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return updateCodeRegistrationEx(request, headers, runtime);
}

/**
 * Description: 更新已注册的溯源信息
 * Summary: 溯源注册信息更新
 */
async function updateCodeRegistrationEx(request: UpdateCodeRegistrationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCodeRegistrationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.registration.update', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model AddCodeRelationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  // 
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  // 
  code: string(maxLength=160, minLength=1, name='code'),
  // 状态,客户自定义状态，用于过滤查询使用。只能由字符+数字构成
  // 
  status: string(maxLength=32, minLength=1, name='status'),
  // 业务维度列表，最多5个。各个业务维度依次从高到低。每个业务维度最大长度64
  bizLabels?: [ string ](name='biz_labels'),
  // 是否上链，默认true。 为false时，仅做DB数据保存不上链。 若content数据大小超过要求限制，仅会保存content的hash值上链
  upChainFlag?: boolean(name='up_chain_flag'),
  // 关联内容
  // 
  content?: string(name='content'),
}

model AddCodeRelationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 区块链上交易哈希
  txHash?: string(name='tx_hash'),
  // 绑定信息记录唯一标识
  uniqueId?: string(name='unique_id'),
}

/**
 * Description: 将关联信息绑定到溯源码上，可重复注册。 该接口调用存在以下业务维度限制： 1. code + bizLables + bizType做唯一性判断。
 * Summary: 溯源码(可重复)关联信息
 */
async function addCodeRelation(request: AddCodeRelationRequest): AddCodeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return addCodeRelationEx(request, headers, runtime);
}

/**
 * Description: 将关联信息绑定到溯源码上，可重复注册。 该接口调用存在以下业务维度限制： 1. code + bizLables + bizType做唯一性判断。
 * Summary: 溯源码(可重复)关联信息
 */
async function addCodeRelationEx(request: AddCodeRelationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddCodeRelationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.relation.add', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model UpdateCodeRelationRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 业务类型，客户自定义标签，做code数据隔离使用
  bizType: string(maxLength=32, minLength=1, name='biz_type'),
  // 溯源码，代表该账户的唯一资源标识
  // 
  code: string(maxLength=160, minLength=1, name='code'),
  // 绑定信息记录唯一标识
  uniqueId: string(maxLength=64, minLength=1, name='unique_id'),
  // 状态,客户自定义状态，用于过滤查询使用。只能由字符+数字构成
  status?: string(maxLength=32, minLength=1, name='status'),
  // 是否上链，默认true。 为false时，仅做DB数据保存不上链。 若content数据大小超过要求限制，仅会保存content的hash值上链
  upChainFlag?: boolean(name='up_chain_flag'),
  // 关联信息内容。若已上链，则不可更新该信息。
  content?: string(name='content'),
}

model UpdateCodeRelationResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
}

/**
 * Description: 更新绑定到溯源码上的关联信息。
 * Summary: 溯源码关联信息更新
 */
async function updateCodeRelation(request: UpdateCodeRelationRequest): UpdateCodeRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return updateCodeRelationEx(request, headers, runtime);
}

/**
 * Description: 更新绑定到溯源码上的关联信息。
 * Summary: 溯源码关联信息更新
 */
async function updateCodeRelationEx(request: UpdateCodeRelationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCodeRelationResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.code.relation.update', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryMiniCodeRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 溯源码
  code: string(maxLength=160, name='code'),
  // 用户信息
  userInfo?: ScanUserInfo(name='user_info'),
}

model QueryMiniCodeResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 首次扫描信息
  scanInfo?: ScanHeadInfo(name='scan_info'),
  // 商品信息
  productInfo?: ProudctInfo(name='product_info'),
  // 溯源环节信息列表
  phaseInfos?: [ PhaseInfo ](name='phase_infos'),
}

/**
 * Description: 溯源码详情查询
 * Summary: 溯源码详情查询
 */
async function queryMiniCode(request: QueryMiniCodeRequest): QueryMiniCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryMiniCodeEx(request, headers, runtime);
}

/**
 * Description: 溯源码详情查询
 * Summary: 溯源码详情查询
 */
async function queryMiniCodeEx(request: QueryMiniCodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryMiniCodeResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.mini.code.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model QueryMiniCertRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 溯源码信息
  code: string(maxLength=160, name='code'),
  // 交易哈希
  txHash: string(maxLength=64, name='tx_hash'),
}

model QueryMiniCertResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 区块信息
  blockInfo?: BlockInfo(name='block_info'),
  // 上传者信息
  uploadInfo?: UploaderInfo(name='upload_info'),
}

/**
 * Description: 溯源证书查询
 * Summary: 溯源证书查询
 */
async function queryMiniCert(request: QueryMiniCertRequest): QueryMiniCertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return queryMiniCertEx(request, headers, runtime);
}

/**
 * Description: 溯源证书查询
 * Summary: 溯源证书查询
 */
async function queryMiniCertEx(request: QueryMiniCertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryMiniCertResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.mini.cert.query', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model VerifyMiniNfcRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  productInstanceId?: string(name='product_instance_id'),
  // 动态秘钥字符串信息
  code: string(maxLength=250, name='code'),
  // NFC UID
  uid?: string(name='uid'),
}

model VerifyMiniNfcResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 校验结果
  status?: string(name='status'),
  // 校验信息
  message?: string(name='message'),
  // 校验解析溯源码
  code?: string(name='code'),
  // NFC UID
  uid?: string(name='uid'),
}

/**
 * Description: 动态秘钥NFC二维码校验
 * Summary: 动态秘钥NFC二维码校验
 */
async function verifyMiniNfc(request: VerifyMiniNfcRequest): VerifyMiniNfcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return verifyMiniNfcEx(request, headers, runtime);
}

/**
 * Description: 动态秘钥NFC二维码校验
 * Summary: 动态秘钥NFC二维码校验
 */
async function verifyMiniNfcEx(request: VerifyMiniNfcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VerifyMiniNfcResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antchain.mytc.mini.nfc.verify', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

model CreateAntcloudGatewayxFileUploadRequest = {
  // OAuth模式下的授权token
  authToken?: string(name='auth_token'),
  // 上传文件作用的openapi method
  apiCode: string(name='api_code'),
  // 文件标签，多个标签;分割
  fileLabel?: string(maxLength=100, name='file_label'),
  // 自定义的文件元数据
  fileMetadata?: string(maxLength=1000, name='file_metadata'),
  // 文件名，不传则随机生成文件名
  fileName?: string(maxLength=100, name='file_name'),
  // 文件的多媒体类型
  mimeType?: string(name='mime_type'),
  // 产品方的api归属集群，即productInstanceId
  apiCluster?: string(name='api_cluster'),
}

model CreateAntcloudGatewayxFileUploadResponse = {
  // 请求唯一ID，用于链路跟踪和问题排查
  reqMsgId?: string(name='req_msg_id'),
  // 结果码，一般OK表示调用成功
  resultCode?: string(name='result_code'),
  // 异常信息的文本描述
  resultMsg?: string(name='result_msg'),
  // 上传有效期
  expiredTime?: string(pattern='\\\\d{4}[-]\\\\d{1,2}[-]\\\\d{1,2}[T]\\\\d{2}:\\\\d{2}:\\\\d{2}([Z]|([\\\\.]\\\\d{1,9})?[\\\\+]\\\\d{2}[\\\\:]?\\\\d{2})', name='expired_time'),
  // 32位文件唯一id
  fileId?: string(name='file_id'),
  // 放入http请求头里
  uploadHeaders?: [ XNameValuePair ](name='upload_headers'),
  // 文件上传地址
  uploadUrl?: string(name='upload_url'),
}

/**
 * Description: 创建HTTP PUT提交的文件上传
 * Summary: 文件上传创建
 */
async function createAntcloudGatewayxFileUpload(request: CreateAntcloudGatewayxFileUploadRequest): CreateAntcloudGatewayxFileUploadResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string= {};
  return createAntcloudGatewayxFileUploadEx(request, headers, runtime);
}

/**
 * Description: 创建HTTP PUT提交的文件上传
 * Summary: 文件上传创建
 */
async function createAntcloudGatewayxFileUploadEx(request: CreateAntcloudGatewayxFileUploadRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAntcloudGatewayxFileUploadResponse {
  Util.validateModel(request);
  return doRequest('1.0' ,'antcloud.gatewayx.file.upload.create', 'HTTPS', 'POST', `/gateway.do`, request, headers, runtime);
}

